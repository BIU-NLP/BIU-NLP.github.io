(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(e,t,a){e.exports=a("zUnb")},WciA:function(e){e.exports=JSON.parse('{"PhD Student":[{"name":"Amit Moryossef","scholarId":"Aaj_RBEAAAAJ","startYear":2018,"advisors":["Yoav Goldberg"],"previousDegrees":["MSc Student"]},{"name":"Avi Caciularu","startYear":2019,"advisors":["Ido Dagan","Jacob Goldberger"],"homepage":"http://aviclu.github.io/"},{"name":"Mosh Levy","startYear":2020,"advisors":["Yoav Goldberg"],"image":false},{"name":"Omer Goldman","startYear":2020,"advisors":["Reut Tsarfaty"]},{"name":"Uri Goren","startYear":2019,"advisors":["Reut Tsarfaty"],"homepage":"http://www.goren.ml"},{"name":"Amir David Nissan Cohen","startYear":2019,"advisors":["Yoav Goldberg"],"endYear":2023},{"name":"Ori Shapira","startYear":2017,"advisors":["Ido Dagan","Yael Amsterdamer"],"previousDegrees":["MSc Student"],"homepage":"https://orishapira.wordpress.com/"},{"name":"Natalie Shapira","startYear":2018,"advisors":["Yoav Goldberg"],"homepage":"https://twitter.com/NatalieShapira"},{"name":"Tzuf Paz-Argaman","image":false,"startYear":2019,"advisors":["Reut Tsarfaty"],"endYear":2023},{"name":"Shauli Ravfogel","startYear":2020,"advisors":["Yoav Goldberg"],"endYear":2024,"previousDegrees":["MSc Student"],"homepage":"https://shauli-ravfogel.netlify.app/"},{"name":"Valentina Pyatkin","scholarId":"E9EgKkMAAAAJ","startYear":2019,"advisors":["Reut Tsarfaty","Ido Dagan"],"homepage":"https://valentinapy.github.io"},{"name":"Ori Ernst","startYear":2019,"advisors":["Ido Dagan","Jacob Goldberger"],"homepage":"https://oriern.netlify.app/"},{"name":"Ayal Klein","startYear":2019,"advisors":["Ido Dagan"],"endYear":2023,"previousDegrees":["MSc Student"],"interests":"Semantics, Semantic Representations, Psycholinguistics"},{"name":"Yanai Elazar","scholarId":"7p_Ce8kAAAAJ","startYear":2016,"advisors":["Yoav Goldberg"],"endYear":2022,"previousDegrees":["MSc Student"],"homepage":"https://yanaiela.github.io/","interests":"Interpretability and Analysis, Commonsense Reasoning, Biases"},{"name":"Ohad Rozen","startYear":2018,"advisors":["Ido Dagan"],"endYear":2022,"interests":"Inference, Question answering"},{"name":"Moran Baruch","startYear":2019,"advisors":["Yoav Goldberg"],"endYear":2022},{"name":"Matan Ben Noach","image":false,"startYear":2020,"advisors":["Yoav Goldberg","Jacob Goldberger"],"endYear":2024,"previousDegrees":["MSc Student"]},{"name":"Alon Jacovi","startYear":2019,"advisors":["Yoav Goldberg"],"previousDegrees":["MSc Student"],"homepage":"https://alonjacovi.github.io/","interests":"XAI for NLP"},{"name":"Arie Cattan","startYear":2020,"advisors":["Ido Dagan"],"previousDegrees":["MSc Student"]},{"name":"Paul Roit","startYear":2018,"advisors":["Yoav Goldberg","Ido Dagan"],"endYear":2024,"previousDegrees":["MSc Student"]},{"name":"Eran Hirsch","startYear":"2022","advisors":["Ido Dagan"],"endYear":"2026"},{"name":"Alon Eirew","startYear":2022,"advisors":["Ido Dagan"],"previousDegrees":["MSc Student"],"homepage":"https://www.linkedin.com/in/aloneirew/"}],"MSc Student":[{"name":"Shachar Rosenman","startYear":2019,"advisors":["Yoav Goldberg"]},{"name":"Ruben Wolhandler","startYear":2021,"advisors":["Ido Dagan"],"homepage":"https://www.linkedin.com/in/ruben-wolhandler/"},{"name":"Shir Ashury Tahan","startYear":2022,"advisors":["Yoav Goldberg"]},{"name":"Daniela Brook Weiss","aliases":["Daniela Stepanov"],"startYear":2018,"advisors":["Ido Dagan"],"previousDegrees":["MSc Student"]},{"name":"Eyal Orbach","startYear":2017,"advisors":["Yoav Goldberg"],"previousDegrees":["MSc Student"]},{"name":"Eviatar Nachshoni","startYear":2022,"advisors":["Ido Dagan"]},{"name":"Aryeh Tiktinsky","startYear":2018,"advisors":["Yoav Goldberg"]},{"name":"Ari Bornstein","aliases":["Aaron Bornstein"],"startYear":2017,"advisors":["Ido Dagan"]},{"name":"Aviv Weinstein","startYear":2019,"advisors":["Yoav Goldberg"],"endYear":2021,"interests":"Relation Extraction"},{"name":"David Guriel","startYear":2019,"advisors":["Reut Tsarfaty"],"endYear":2021,"interests":"Morphology, Reinflection, minimal supervision algorithms"},{"name":"Elad Ben Zaken","startYear":2021,"advisors":["Yoav Goldberg"],"homepage":"https://www.linkedin.com/in/elad-ben-zaken-4904a1127/","interests":"Machine Learning, Deep Learning & NLP"},{"name":"Amit Seker","startYear":2016,"advisors":["Reut Tsarfaty"]},{"name":"Eylon Gueta","startYear":2019,"advisors":["Reut Tsarfaty"]},{"name":"Ben Hagag","startYear":2020,"advisors":["Reut Tsarfaty"],"endYear":2022,"previousDegrees":["MSc Student"]},{"name":"Dan Bareket","startYear":2018,"advisors":["Reut Tsarfaty"]},{"name":"Elron Bandel","startYear":2020,"advisors":["Yoav Goldberg","Yanai Elazar"],"homepage":"https://www.linkedin.com/in/elron/"},{"name":"Asaf Achi Mordechai","startYear":2019,"advisors":["Yoav Goldberg","Reut Tsarfaty"],"endYear":2021,"homepage":"https://github.com/asafam","interests":"NBA fantasy, sci-fi books, international soccer"},{"name":"Mor Peled","startYear":2019,"advisors":["Yoav Goldberg"],"interests":"Deep learning, Health care & Rock\'nroll"},{"name":"Shmuel Amar","startYear":2019,"advisors":["Ido Dagan"],"homepage":"https://github.com/shmuelamar","interests":"AI, ML, DL, NLP, Big Data"},{"name":"Leon Pesahov","startYear":null,"image":false,"advisors":["Ido Dagan"]}],"Alumni":[{"name":"Gabriel Stanovsky","startYear":2014,"advisors":["Ido Dagan"],"previousDegrees":["PhD Student"],"endYear":2018,"homepage":"https://gabrielstanovsky.github.io/","current":{"position":"Faculty","employer":"Hebrew University"}},{"name":"Roee Aharoni","startYear":2016,"advisors":["Yoav Goldberg"],"endYear":2020,"previousDegrees":["PhD Student"],"homepage":"https://www.roeeaharoni.com","current":{"position":"Research Scientist","employer":"Google"}},{"name":"Omer Levy","startYear":2012,"advisors":["Yoav Goldberg","Ido Dagan"],"endYear":2016,"previousDegrees":["PhD Student"],"homepage":"https://www.cs.tau.ac.il/~levyomer/","current":{"position":"Senior Lecturer","employer":"Tel Aviv University"}},{"name":"Karin Brisker","startYear":2017,"advisors":["Yoav Goldberg"],"endYear":2020,"previousDegrees":["MSc Student"],"current":{"position":"Data Scientist ","employer":"Microsoft, healthcare team"}},{"name":"Daniel Juravski","startYear":2018,"advisors":["Yoav Goldberg"],"endYear":2020,"previousDegrees":["MSc Student"]},{"name":"Ofer Sabo","startYear":2018,"advisors":["Yoav Goldberg","Ido Dagan"],"endYear":2020,"previousDegrees":["MSc Student"],"current":{"position":"NLP Researcher","employer":"Zebra Medical"}},{"name":"Vered Shwartz","startYear":2015,"advisors":["Ido Dagan"],"endYear":2019,"previousDegrees":["PhD Student"],"homepage":"https://vered1986.github.io","current":{"position":"Postdoctoral Researcher","employer":"Allen Institute for AI (AI2) & University of Washington"}},{"name":"Eliyahu Kiperwasser","startYear":2014,"advisors":["Yoav Goldberg"],"endYear":2019,"previousDegrees":["PhD Student"],"homepage":"http://elki.cc","current":{"position":"Senior research scientist","employer":"eBay"}},{"name":"Hila Gonen","scholarId":"URThmtMAAAAJ","startYear":2015,"advisors":["Yoav Goldberg"],"endYear":2020,"previousDegrees":["PhD Student"],"homepage":"https://u.cs.biu.ac.il/~gonenhi/","current":{"position":"Postdoc","employer":"Amazon"}},{"name":"Noa Lubin","startYear":2017,"advisors":["Yoav Goldberg"],"endYear":2019,"previousDegrees":["MSc Student"],"homepage":"https://www.linkedin.com/in/noalu/","current":{"position":"Senior Machine Learning Researcher","employer":"Diagnostic Robotics"}},{"name":"Lili Kotlerman","image":false,"startYear":2010,"advisors":["Ido Dagan"],"endYear":2016,"previousDegrees":["PhD Student"],"current":{"position":"Senior NLP researcher","employer":"Intuition Robotics"}},{"name":"Shany Barhom","startYear":2017,"advisors":["Ido Dagan"],"endYear":2020,"previousDegrees":["MSc Student"],"interests":"Coreference, discourse and representation learning","current":{"position":"Algorithm Researcher","employer":"BeyondMinds"}},{"name":"Oren Melamud","startYear":2012,"advisors":["Ido Dagan","Jacob Goldberger"],"endYear":2016,"previousDegrees":["PhD Student"],"homepage":"https://u.cs.biu.ac.il/~melamuo/","current":{"position":"Director of Data Science","employer":"Keywee Inc."}},{"name":"Zvika Marx","image":false,"startYear":null,"previousDegrees":["Ph.D"],"endYear":2005,"advisors":["Ido Dagan","Eli Shamir"]},{"name":"Oren Glickman","startYear":null,"previousDegrees":["Ph.D"],"endYear":2006,"advisors":["Ido Dagan","Moshe Koppel"]},{"name":"Maayan Gefet","image":false,"startYear":null,"previousDegrees":["Ph.D"],"endYear":2006,"advisors":["Ido Dagan","Dror Feitelson"]},{"name":"Roy Bar-Haim","image":false,"startYear":null,"previousDegrees":["Ph.D"],"endYear":2009,"advisors":["Ido Dagan"]},{"name":"Jonathan Berant","homepage":"http://www.cs.tau.ac.il/~joberant/","startYear":null,"previousDegrees":["Ph.D"],"endYear":2012,"advisors":["Ido Dagan"],"current":{"position":"Assistant Professor","employer":"Tel Aviv University"}},{"name":"Eyal Shnarch","image":false,"startYear":null,"previousDegrees":["Ph.D"],"endYear":2014,"advisors":["Ido Dagan","Jacob Goldberger"]},{"name":"Asher Stern","image":false,"homepage":"https://www.linkedin.com/in/asherstern/","startYear":null,"previousDegrees":["Ph.D"],"endYear":2015,"advisors":["Ido Dagan"],"current":{"position":"Applied Researcher","employer":"eBay"}},{"name":"Shlomit Hazan","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":1997,"advisors":["Ido Dagan","Ronen Feldman"]},{"name":"Erez Lotan","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":1998,"advisors":["Ido Dagan"]},{"name":"Alex Avramovitch","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":1998,"advisors":["Ido Dagan"]},{"name":"Shelly Katz","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":1998,"advisors":["Ido Dagan","Ariel Frank"]},{"name":"Roman Mitnitsky","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":1998,"advisors":["Ido Dagan"]},{"name":"Michal Finkelstein-Landau","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":1999,"advisors":["Ido Dagan"]},{"name":"Marina Risher","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2001,"advisors":["Ido Dagan"]},{"name":"Ehud Conley","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2002,"advisors":["Ido Dagan"]},{"name":"Idan Szpektor","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2005,"advisors":["Ido Dagan","Yossi Matias"]},{"name":"Shachar Mirkin","homepage":"https://sites.google.com/site/shacharmirkin","startYear":null,"previousDegrees":["M.Sc"],"endYear":2006,"advisors":["Ido Dagan","Ari Rappoport"],"current":{"position":"NLP Researcher","employer":"Digimind"}},{"name":"Moshe Friedman","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2006,"advisors":["Ido Dagan","Moshe Koppel"]},{"name":"Tal Itzhak Ron","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2006,"advisors":["Ido Dagan"]},{"name":"Efrat Hershkovitz","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2006,"advisors":["Ido Dagan"]},{"name":"Libby Berkovitch","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2008,"advisors":["Ido Dagan"]},{"name":"Ephi Sachs","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2008,"advisors":["Ido Dagan"]},{"name":"Chen Erez","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2009,"advisors":["Ido Dagan"]},{"name":"Chaya Liebeskind","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2009,"advisors":["Ido Dagan"],"current":{"position":"Lecturer","employer":"Machon Lev"}},{"name":"Roni Ben Aharon","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2010,"advisors":["Ido Dagan"]},{"name":"Hadas Zohar","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2011,"advisors":["Ido Dagan","Jonathan Schler"]},{"name":"Naomi Frankel","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2012,"advisors":["Ido Dagan","Meni Adler"]},{"name":"Amnon Lotan","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2012,"advisors":["Ido Dagan"]},{"name":"Hila Weisman","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2013,"advisors":["Ido Dagan","Idan Szpektor"]},{"name":"Ofer Bronstein","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2015,"advisors":["Ido Dagan"]},{"name":"Vasily Konovalov","image":false,"startYear":null,"previousDegrees":["M.Sc"],"endYear":2016,"advisors":["Ido Dagan"]},{"name":"Rachel wities","startYear":2004,"advisors":["Ido Dagan"],"endYear":2007,"previousDegrees":["MSc Student"],"current":{"position":"NLP Data Scientist","employer":"Zebra Medical Vision"}},{"name":"Yehudit Meged","startYear":2017,"previousDegrees":["M.Sc"],"endYear":2020,"advisors":["Ido Dagan"]},{"name":"Assaf Toledo","homepage":"https://www.linkedin.com/in/assaf-toledo-a3608b27/","startYear":null,"previousDegrees":["Post-doc"],"endYear":null,"current":{"position":"Research Staff Member","employer":"IBM Research"}}],"Employee":[{"name":"Victoria Basmov","startYear":2018,"advisors":["Reut Tsarfaty"]},{"name":"Yuval Krymolowski","startYear":1999,"advisors":["Ido Dagan"],"endYear":2006,"previousDegrees":["PhD Student"],"interests":"event discovery, parsing, lexical semantics","current":{"position":"Lab employee","employer":"BIU NLP Lab"}},{"name":"Shoval Sadde","startYear":2018,"advisors":["Reut Tsarfaty"],"endYear":2020,"current":{"position":"Computational Linguist","employer":"AI2"}}],"Faculty":[{"name":"Ido Dagan","scholarId":"YzGAGtoAAAAJ","homepage":"https://u.cs.biu.ac.il/~dagan/"},{"name":"Reut Tsarfaty","scholarId":"0Eome9MAAAAJ","homepage":"https://research.biu.ac.il/researcher/prof-reut-tsarfaty/"},{"name":"Yoav Goldberg","scholarId":"0rskDKgAAAAJ","homepage":"https://www.cs.bgu.ac.il/~yoavg/uni/"}]}')},bjCJ:function(e){e.exports=JSON.parse('[{"id":"562b4688ff0cd423fb3263ab0c87f78e.html","title":"The MRL 2022 Shared Task on Multilingual Clause-level Morphology","url":"https://hal.inria.fr/hal-03878174/","authors":["Omer Goldman","Francesco Tinner","Hila Gonen","Benjamin Muller","Victoria Basmov","Shadrack Kirimi","Lydia Nishimwe","Beno\\\\xc3\\\\xaet Sagot","Djam\\\\xc3\\\\xa9 Seddah","Reut Tsarfaty","Duygu Ataman"],"date":"2022/12/08","abstract":""},{"id":"15bba53641bfbcc9b0ffa4d1b5d305f9.html","title":"Draw Me a Flower: Processing and Grounding Abstraction in Natural Language","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_a_00522/114048","authors":["Royi Lachmy","Valentina Pyatkin","Avshalom Manevich","Reut Tsarfaty"],"date":"2022/11/28","journal":"Transactions of the Association for Computational Linguistics","abstract":"Abstraction is a core tenet of human cognition and communication. When composing natural language instructions, humans naturally evoke abstraction to convey complex procedures in an efficient and concise way. Yet, interpreting and grounding abstraction expressed in NL has not yet been systematically studied in NLP, with no accepted benchmarks specifically eliciting abstraction in NL. In this work, we set the foundation for a systematic study of processing and grounding abstraction in NLP. First, we deliver a novel abstraction elicitation method and present <span class=\\"gs_fscp\\">Hexagons</span>, a 2D instruction-following game. Using <span class=\\"gs_fscp\\">Hexagons</span> we collected over 4k naturally occurring visually-grounded instructions rich with diverse types of abstractions. From these data, we derive an <i>instruction-to-execution</i> task and assess different types of neural models. Our results show that contemporary models and modeling practices are\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"be49a8643342011222c53fd2eb551b99.html","title":"Large Pre-Trained Models with Extra-Large Vocabularies: A Contrastive Analysis of Hebrew BERT Models and a New One to Outperform Them All","url":"https://arxiv.org/abs/2211.15199","authors":["Eylon Guetta","Avi Shmidman","Shaltiel Shmidman","Cheyn Shmuel Shmidman","Joshua Guedalia","Moshe Koppel","Dan Bareket","Amit Seker","Reut Tsarfaty"],"date":"2022/11/28","journal":"arXiv preprint arXiv:2211.15199","abstract":""},{"id":"0e0a62946133b07050d498e9154a29ab.html","title":"Ham2Pose: Animating Sign Language Notation into Pose Sequences","url":"https://arxiv.org/abs/2211.13613","authors":["Rotem Shalev-Arkushin","Amit Moryossef","Ohad Fried"],"date":"2022/11/24","journal":"arXiv preprint arXiv:2211.13613","abstract":""},{"id":"acc88982fe6e9c1e84152c3887d7dab7.html","title":"Breakpoint Transformers for Modeling and Tracking Intermediate Beliefs","url":"https://arxiv.org/abs/2211.07950","authors":["Kyle Richardson","Ronen Tamari","Oren Sultan","Reut Tsarfaty","Dafna Shahaf","Ashish Sabharwal"],"date":"2022/11/15","journal":"arXiv preprint arXiv:2211.07950","abstract":""},{"id":"effe9c45a7607e83818374acfe3da42a.html","title":"Prompting Language Models for Linguistic Structure","url":"https://arxiv.org/abs/2211.07830","authors":["Terra Blevins","Hila Gonen","Luke Zettlemoyer"],"date":"2022/11/15","journal":"arXiv preprint arXiv:2211.07830","abstract":""},{"id":"d359b6a9541adc91ea278f25b2109d77.html","title":"Just-DREAM-about-it: Figurative Language Understanding with DREAM-FLUTE","url":"https://arxiv.org/abs/2210.16407","authors":["Yuling Gu","Yao Fu","Valentina Pyatkin","Ian Magnusson","Bhavana Dalvi Mishra","Peter Clark"],"date":"2022/10/28","journal":"arXiv preprint arXiv:2210.16407","abstract":""},{"id":"68c740649f21202e5aad2517c809ff11.html","title":"Controlled Text Reduction","url":"https://arxiv.org/abs/2210.13449","authors":["Aviv Slobodkin","Paul Roit","Eran Hirsch","Ori Ernst","Ido Dagan"],"date":"2022/10/24","journal":"arXiv preprint arXiv:2210.13449","abstract":""},{"id":"24bebc80901f6da4901b4b5f52da8d42.html","title":"How\\" Multi\\" is Multi-Document Summarization?","url":"https://arxiv.org/abs/2210.12688","authors":["Ruben Wolhandler","Arie Cattan","Ori Ernst","Ido Dagan"],"date":"2022/10/23","journal":"arXiv preprint arXiv:2210.12688","abstract":""},{"id":"53079a45d32a1539c8c17095b16f39fc.html","title":"Lexical Generalization Improves with Larger Models and Longer Training","url":"https://arxiv.org/abs/2210.12673","authors":["Elron Bandel","Yanai Elazar"],"date":"2022/10/23","journal":"arXiv preprint arXiv:2210.12673","abstract":""},{"id":"feede2b6c8a51f7905dd448894832bc6.html","title":"Cross-document Event Coreference Search: Task, Dataset and Modeling","url":"https://arxiv.org/abs/2210.12654","authors":["Alon Eirew","Avi Caciularu","Ido Dagan"],"date":"2022/10/23","journal":"arXiv preprint arXiv:2210.12654","abstract":""},{"id":"3e5e534a2ac1c832daa67caa53e21f48.html","title":"DALLE-2 is Seeing Double: Flaws in Word-to-Concept Mapping in Text2Image Models","url":"https://arxiv.org/abs/2210.10606","authors":["Royi Rassin","Shauli Ravfogel","Yoav Goldberg"],"date":"2022/10/19","journal":"arXiv preprint arXiv:2210.10606","abstract":""},{"id":"bd484eaaae104c11af625cbe10948472.html","title":"Linear Guardedness and its Implications","url":"https://arxiv.org/abs/2210.10012","authors":["Shauli Ravfogel","Yoav Goldberg","Ryan Cotterell"],"date":"2022/10/18","journal":"arXiv preprint arXiv:2210.10012","abstract":""},{"id":"6b0fc2da358ddf11512486a542cb3c47.html","title":"Machine Translation between Spoken Languages and Signed Languages Represented in SignWriting","url":"https://arxiv.org/abs/2210.05404","authors":["Zifan Jiang","Amit Moryossef","Mathias M\\\\xc3\\\\xbcller","Sarah Ebling"],"date":"2022/10/11","journal":"arXiv preprint arXiv:2210.05404","abstract":""},{"id":"f466e84301a795fa91f187d9200893af.html","title":"State-of-the-art generalisation research in NLP: a taxonomy and review","url":"https://arxiv.org/abs/2210.03050","authors":["Dieuwke Hupkes","Mario Giulianelli","Verna Dankers","Mikel Artetxe","Yanai Elazar","Tiago Pimentel","Christos Christodoulopoulos","Karim Lasri","Naomi Saphra","Arabella Sinclair","Dennis Ulmer","Florian Schottmann","Khuyagbaatar Batsuren","Kaiser Sun","Koustuv Sinha","Leila Khalatbari","Rita Frieske","Ryan Cotterell","Zhijing Jin"],"date":"2022/10/06","journal":"arXiv preprint arXiv:2210.03050","abstract":""},{"id":"285d6190d13a0c4e8c25942354010d6b.html","title":"Measuring Causal Effects of Data Statistics on Language Model\\\\\'sFactual\\\\\'Predictions","url":"https://arxiv.org/abs/2207.14251","authors":["Yanai Elazar","Nora Kassner","Shauli Ravfogel","Amir Feder","Abhilasha Ravichander","Marius Mosbach","Yonatan Belinkov","Hinrich Sch\\\\xc3\\\\xbctze","Yoav Goldberg"],"date":"2022/07/28","journal":"arXiv preprint arXiv:2207.14251","abstract":""},{"id":"9036af0188a7901150f8a5a4780ed987.html","title":"Text-based NP enrichment","url":"https://arxiv.org/abs/2109.12085","authors":["Yanai Elazar","Yoav Goldberg","Reut Tsarfaty"],"date":"2022/07/27","journal":"Transactions of the Association for Computational Linguistics","abstract":""},{"id":"4b88001487482391a022f0a711d85faf.html","title":"Proceedings of the 4th Workshop on Gender Bias in Natural Language Processing (GeBNLP)","url":"https://aclanthology.org/2022.gebnlp-1.0.pdf","authors":["Christian Hardmeier","Christine Basta","Marta R Costa-juss\\\\xc3\\\\xa0","Gabriel Stanovsky","Hila Gonen"],"date":"2022/07","abstract":"This volume contains the proceedings of the Fourth Workshop on Gender Bias in Natural Language Processing, held in conjunction with the 2022 Conference of the North American Chapter of the Association for Computational Linguistics\\\\xe2\\\\x80\\\\x93Human Language Technologies (NAACL-HLT2022). This year, the organization committee changed membership: Kellie Webster made way for Christine Basta and Gabriel Stanovsky. Kellie has been one of the main reasons for the success of this workshop and we would like to thank her for her valuable and enthusiastic contribution to this workshop. We are glad to welcome our two co-organizers and look forward to sharing their insights and expertise."},{"id":"5234f3f42255750dcf489493b6000787.html","title":"Proceedings of the Second Workshop on Understanding Implicit and Underspecified Language","url":"https://aclanthology.org/2022.unimplicit-1.0.pdf","authors":["Valentina Pyatkin","Daniel Fried","Talita Anthonio"],"date":"2022/07","abstract":"Welcome to UnImplicit: The Second Workshop on Understanding Implicit and Underspecified Language. The focus of this workshop is on implicit and underspecified phenomena in language, which pose serious challenges to standard natural language processing models as they often require incorporating greater context, using symbolic inference and common-sense reasoning, or more generally, going beyond strictly lexical and compositional meaning constructs. This challenge spans all phases of the NLP model\\\\xe2\\\\x80\\\\x99s life cycle: from collecting and annotating relevant data, through devising computational methods for modeling such phenomena, to evaluating and designing proper evaluation metrics. In this workshop, our goal is to bring together theoreticians and practitioners from the entire NLP cycle, from annotation and benchmarking to modeling and applications, and to provide an umbrella for the development\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"71d0c481f90dff0e3eac89bbcc0cc881.html","title":"Long Context Question Answering via Supervised Contrastive Learning","url":"https://aclanthology.org/2022.naacl-main.207/","authors":["Avi Caciularu","Ido Dagan","Jacob Goldberger","Arman Cohan"],"date":"2022/07","abstract":"Long-context question answering (QA) tasks require reasoning over a long document or multiple documents. Addressing these tasks often benefits from identifying a set of evidence spans (eg, sentences), which provide supporting evidence for answering the question. In this work, we propose a novel method for equipping long-context QA models with an additional sequence-level objective for better identification of the supporting evidence. We achieve this via an additional contrastive supervision signal in finetuning, where the model is encouraged to explicitly discriminate supporting evidence sentences from negative ones by maximizing question-evidence similarity. The proposed additional loss exhibits consistent improvements on three different strong long-context transformer models, across two challenging question answering benchmarks\\\\xe2\\\\x80\\\\x93HotpotQA and QAsper."},{"id":"b5db2126f65faa374dac8947aa7f3c60.html","title":"Proposition-level clustering for multi-document summarization","url":"https://aclanthology.org/2022.naacl-main.128/","authors":["Ori Ernst","Avi Caciularu","Ori Shapira","Ramakanth Pasunuru","Mohit Bansal","Jacob Goldberger","Ido Dagan"],"date":"2022/07","abstract":"Text clustering methods were traditionally incorporated into multi-document summarization (MDS) as a means for coping with considerable information repetition. Particularly, clusters were leveraged to indicate information saliency as well as to avoid redundancy. Such prior methods focused on clustering sentences, even though closely related sentences usually contain also non-aligned parts. In this work, we revisit the clustering approach, grouping together sub-sentential propositions, aiming at more precise information alignment. Specifically, our method detects salient propositions, clusters them into paraphrastic clusters, and generates a representative sentence for each cluster via text fusion. Our summarization method improves over the previous state-of-the-art MDS method in the DUC 2004 and TAC 2011 datasets, both in automatic ROUGE scores and human preference."},{"id":"eda6f8a4db1ecf9b29ccb0cfe3c3ee10.html","title":"Interactive Query-Assisted Summarization via Deep Reinforcement Learning","url":"https://aclanthology.org/2022.naacl-main.184/","authors":["Ori Shapira","Ramakanth Pasunuru","Mohit Bansal","Ido Dagan","Yael Amsterdamer"],"date":"2022/07","abstract":"Interactive summarization is a task that facilitates user-guided exploration of information within a document set. While one would like to employ state of the art neural models to improve the quality of interactive summarization, many such technologies cannot ingest the full document set or cannot operate at sufficient speed for interactivity. To that end, we propose two novel deep reinforcement learning models for the task that address, respectively, the subtask of summarizing salient information that adheres to user queries, and the subtask of listing suggested queries to assist users throughout their exploration. In particular, our models allow encoding the interactive session state and history to refrain from redundancy. Together, these models compose a state of the art solution that addresses all of the task requirements. We compare our solution to a recent interactive summarization system, and show through an experimental study involving real users that our models are able to improve informativeness while preserving positive user experience."},{"id":"15a1a635ff8ceb74efd1d7185d875103.html","title":"Linear adversarial concept erasure","url":"https://proceedings.mlr.press/v162/ravfogel22a.html","authors":["Shauli Ravfogel","Michael Twiton","Yoav Goldberg","Ryan D Cotterell"],"date":"2022/06/28","abstract":"Modern neural models trained on textual data rely on pre-trained representations that emerge without direct supervision. As these representations are increasingly being used in real-world applications, the inability to control their content becomes an increasingly important problem. In this work, we formulate the problem of identifying a linear subspace that corresponds to a given concept, and removing it from the representation. We formulate this problem as a constrained, linear minimax game, and show that existing solutions are generally not optimal for this task. We derive a closed-form solution for certain objectives, and propose a convex relaxation that works well for others. When evaluated in the context of binary gender removal, the method recovers a low-dimensional subspace whose removal mitigates bias by intrinsic and extrinsic evaluation. Surprisingly, we show that the method\\\\xe2\\\\x80\\\\x94despite being linear\\\\xe2\\\\x80\\\\x94is highly expressive, effectively mitigating bias in the output layers of deep, nonlinear classifiers while maintaining tractability and interpretability."},{"id":"5897f9ffd4cb2255aba034eff1044889.html","title":"Design choices in crowdsourcing discourse relation annotations: The effect of worker selection and training","url":"https://aclanthology.org/2022.lrec-1.231/","authors":["Merel Scholman","Valentina Pyatkin","Frances Yung","Ido Dagan","Reut Tsarfaty","Vera Demberg"],"date":"2022/06","abstract":"Obtaining linguistic annotation from novice crowdworkers is far from trivial. A case in point is the annotation of discourse relations, which is a complicated task. Recent methods have obtained promising results by extracting relation labels from either discourse connectives (DCs) or question-answer (QA) pairs that participants provide. The current contribution studies the effect of worker selection and training on the agreement on implicit relation labels between workers and gold labels, for both the DC and the QA method. In Study 1, workers were not specifically selected or trained, and the results show that there is much room for improvement. Study 2 shows that a combination of selection and training does lead to improved results, but the method is cost-and time-intensive. Study 3 shows that a selection-only approach is a viable alternative; it results in annotations of comparable quality compared to annotations from trained participants. The results generalized over both the DC and QA method and therefore indicate that a selection-only approach could also be effective for other crowdsourced discourse annotation tasks."},{"id":"a5231e38695c3329b3a89354659ee661.html","title":"LingMess: Linguistically Informed Multi Expert Scorers for Coreference Resolution","url":"https://arxiv.org/abs/2205.12644","authors":["Shon Otmazgin","Arie Cattan","Yoav Goldberg"],"date":"2022/05/25","journal":"arXiv preprint arXiv:2205.12644","abstract":""},{"id":"f05fef7aa7bbf99e439040a67ed5d69b.html","title":"Analyzing the Mono-and Cross-Lingual Pretraining Dynamics of Multilingual Language Models","url":"https://arxiv.org/abs/2205.11758","authors":["Terra Blevins","Hila Gonen","Luke Zettlemoyer"],"date":"2022/05/24","journal":"arXiv preprint arXiv:2205.11758","abstract":""},{"id":"a0163628cd6cf9d59fcf9f8f5ab4abf7.html","title":"QASem Parsing: Text-to-text Modeling of QA-based Semantics","url":"https://arxiv.org/abs/2205.11413","authors":["Ayal Klein","Eran Hirsch","Ron Eliav","Valentina Pyatkin","Avi Caciularu","Ido Dagan"],"date":"2022/05/23","journal":"arXiv preprint arXiv:2205.11413","abstract":""},{"id":"fd8b47dc17a4c1bfa00a6890f1b108fc.html","title":"UniMorph 4.0: Universal Morphology","url":"https://arxiv.org/abs/2205.03608","authors":["Khuyagbaatar Batsuren","Omer Goldman","Salam Khalifa","Nizar Habash","Witold Kiera\\\\xc5\\\\x9b","G\\\\xc3\\\\xa1bor Bella","Brian Leonard","Garrett Nicolai","Kyle Gorman","Yustinus Ghanggo Ate","Maria Ryskina","Sabrina J Mielke","Elena Budianskaya","Charbel El-Khaissi","Tiago Pimentel","Michael Gasser","William Lane","Mohit Raj","Matt Coler","Jaime Rafael Montoya Samame","Delio Siticonatzi Camaiteri","Esa\\\\xc3\\\\xba Zumaeta Rojas","Didier L\\\\xc3\\\\xb3pez Francis","Arturo Oncevay","Juan L\\\\xc3\\\\xb3pez Bautista","Gema Celeste Silva Villegas","Lucas Torroba Hennigen","Adam Ek","David Guriel","Peter Dirix","Jean-Philippe Bernardy","Andrey Scherbakov","Aziyana Bayyr-ool","Antonios Anastasopoulos","Roberto Zariquiey","Karina Sheifer","Sofya Ganieva","Hilaria Cruz","Ritv\\\\xc3\\\\xa1n Karah\\\\xc3\\\\xb3\\\\xc7\\\\xa7a","Stella Markantonatou","George Pavlidis","Matvey Plugaryov","Elena Klyachko","Ali Salehi","Candy Angulo","Jatayu Baxi","Andrew Krizhanovsky","Natalia Krizhanovskaya","Elizabeth Salesky","Clara Vania","Sardana Ivanova","Jennifer White","Rowan Hall Maudslay","Josef Valvoda","Ran Zmigrod","Paula Czarnowska","Irene Nikkarinen","Aelita Salchak","Brijesh Bhatt","Christopher Straughn","Zoey Liu","Jonathan North Washington","Yuval Pinter","Duygu Ataman","Marcin Wolinski","Totok Suhardijanto","Anna Yablonskaya","Niklas Stoehr","Hossep Dolatian","Zahroh Nuriah","Shyam Ratan","Francis M Tyers","Edoardo M Ponti","Grant Aiton","Aryaman Arora","Richard J Hatcher","Ritesh Kumar","Jeremiah Young","Daria Rodionova","Anastasia Yemelina","Taras Andrushko","Igor Marchenko","Polina Mashkovtseva","Alexandra Serova","Emily Prud\\\\\'hommeaux","Maria Nepomniashchaya","Fausto Giunchiglia","Eleanor Chodroff","Mans Hulden","Miikka Silfverberg","Arya D McCarthy","David Yarowsky","Ryan Cotterell","Reut Tsarfaty","Ekaterina Vylomova"],"date":"2022/05/07","journal":"arXiv preprint arXiv:2205.03608","abstract":""},{"id":"a6f6ebb11f5edc2cd063d3ed87a07ba7.html","title":"Opinion-based Relational Pivoting for Cross-domain Aspect Term Extraction","url":"https://aclanthology.org/2022.wassa-1.11/","authors":["Ayal Klein","Oren Pereg","Daniel Korat","Vasudev Lal","Moshe Wasserblat","Ido Dagan"],"date":"2022/05","abstract":"Domain adaptation methods often exploit domain-transferable input features, aka pivots. The task of Aspect and Opinion Term Extraction presents a special challenge for domain transfer: while opinion terms largely transfer across domains, aspects change drastically from one domain to another (eg from restaurants to laptops). In this paper, we investigate and establish empirically a prior conjecture, which suggests that the linguistic relations connecting opinion terms to their aspects transfer well across domains and therefore can be leveraged for cross-domain aspect term extraction. We present several analyses supporting this conjecture, via experiments with four linguistic dependency formalisms to represent relation patterns. Subsequently, we present an aspect term extraction method that drives models to consider opinion\\\\xe2\\\\x80\\\\x93aspect relations via explicit multitask objectives. This method provides significant performance gains, even on top of a prior state-of-the-art linguistically-informed model, which are shown in analysis to stem from the relational pivoting signal."},{"id":"b097615026657653cad9c221088c4cae.html","title":"AlephBERT: Language Model Pre-training and Evaluation from Sub-Word to Sentence Level","url":"https://aclanthology.org/2022.acl-long.4/","authors":["Amit Seker","Elron Bandel","Dan Bareket","Idan Brusilovsky","Refael Greenfeld","Reut Tsarfaty"],"date":"2022/05","abstract":"Large Pre-trained Language Models (PLMs) have become ubiquitous in the development of language understanding technology and lie at the heart of many artificial intelligence advances. While advances reported for English using PLMs are unprecedented, reported advances using PLMs for Hebrew are few and far between. The problem is twofold. First, so far, Hebrew resources for training large language models are not of the same magnitude as their English counterparts. Second, most benchmarks available to evaluate progress in Hebrew NLP require morphological boundaries which are not available in the output of standard PLMs. In this work we remedy both aspects. We present AlephBERT, a large PLM for Modern Hebrew, trained on larger vocabulary and a larger dataset than any Hebrew PLM before. Moreover, we introduce a novel neural architecture that recovers the morphological segments encoded in contextualized embedding vectors. Based on this new morphological component we offer an evaluation suite consisting of multiple tasks and benchmarks that cover sentence-level, word-level and sub-word level analyses. On all tasks, AlephBERT obtains state-of-the-art results beyond contemporary Hebrew baselines. We make our AlephBERT model, the morphological extraction model, and the Hebrew evaluation suite publicly available, for evaluating future Hebrew PLMs."},{"id":"d2ef03bede16313466a240cd92c525b2.html","title":"LM-Debugger: An Interactive Tool for Inspection and Intervention in Transformer-Based Language Models","url":"https://arxiv.org/abs/2204.12130","authors":["Mor Geva","Avi Caciularu","Guy Dar","Paul Roit","Shoval Sadde","Micah Shlain","Bar Tamir","Yoav Goldberg"],"date":"2022/04/26","journal":"arXiv preprint arXiv:2204.12130","abstract":""},{"id":"1bac1fda4d4a9a1f4dfb3e6afc98a500.html","title":"Analyzing Gender Representation in Multilingual Models","url":"https://arxiv.org/abs/2204.09168","authors":["Hila Gonen","Shauli Ravfogel","Yoav Goldberg"],"date":"2022/04/20","journal":"arXiv preprint arXiv:2204.09168","abstract":""},{"id":"4afcacbe373c4e7b395ff70d35364a9d.html","title":"Breaking Character: Are Subwords Good Enough for MRLs After All?","url":"https://arxiv.org/abs/2204.04748","authors":["Omri Keren","Tal Avinari","Reut Tsarfaty","Omer Levy"],"date":"2022/04/10","journal":"arXiv preprint arXiv:2204.04748","abstract":""},{"id":"67f0cbaa061b4c230d304c87b2fbbf0d.html","title":"Neural Token Segmentation for High Token-Internal Complexity","url":"https://arxiv.org/abs/2203.10845","authors":["Idan Brusilovsky","Reut Tsarfaty"],"date":"2022/03/21","journal":"arXiv preprint arXiv:2203.10845","abstract":""},{"id":"7a3f9aa301fbd747e72a6d69f973b077.html","title":"Morphological Reinflection with Multiple Arguments: An Extended Annotation schema and a Georgian Case Study","url":"https://arxiv.org/abs/2203.08527","authors":["David Guriel","Omer Goldman","Reut Tsarfaty"],"date":"2022/03/16","journal":"arXiv preprint arXiv:2203.08527","abstract":""},{"id":"b0826628f0a31049131b031fd12a56f7.html","title":"CIKQA: Learning Commonsense Inference with a Unified Knowledge-in-the-loop QA Paradigm","url":"https://openreview.net/forum?id=S6Pl8ztg_b5","authors":["Hongming Zhang","Yintong Huo","Yanai Elazar","Yangqiu Song","Yoav Goldberg","Dan Roth"],"date":"2022/03/10","abstract":"Recently, the community has achieved substantial progress on many commonsense reasoning benchmarks. However, it is still unclear what was learned from the training process: the knowledge, how to do inference, or both? We argue that due to the large scale of commonsense knowledge, it is infeasible to annotate a large enough training set for each task to cover all commonsense for learning. Thus we should separate the commonsense knowledge acquisition and inference over commonsense knowledge as two separate tasks. In this work, we focus on investigating models\\\\\' commonsense inference capabilities from two perspectives:(1) Whether models can know if the knowledge they have is enough to solve the task;(2) Whether models can learn commonsense inference capabilities, that generalize across commonsense tasks. We first align commonsense tasks with relevant knowledge from commonsense knowledge bases and ask humans to annotate whether the knowledge is enough or not. Then, we convert different commonsense tasks into a unified question answering format to evaluate models\\\\\' generalization capabilities. We name the benchmark as Commonsense Inference with knowledge-in-the-loop Question Answering (CIKQA)."},{"id":"08e537ec47a88484fb9aa35cde607d0d.html","title":"Infrastructure for rapid open knowledge network development","url":"https://onlinelibrary.wiley.com/doi/abs/10.1002/aaai.12038","authors":["Michael Cafarella","Michael Anderson","Iz Beltagy","Arie Cattan","Sarah Chasins","Ido Dagan","Doug Downey","Oren Etzioni","Sergey Feldman","Tian Gao","Tom Hope","Kexin Huang","Sophie Johnson","Daniel King","Kyle Lo","Yuze Lou","Matthew Shapiro","Dinghao Shen","Shivashankar Subramanian","Lucy Lu Wang","Yuning Wang","Yitong Wang","Daniel S Weld","Jenny Vo\\\\xe2\\\\x80\\\\x90Phamhi","Anna Zeng","Jiayun Zou"],"date":"2022/03","journal":"AI Magazine","abstract":"The past decade has witnessed a growth in the use of knowledge graph technologies for advanced data search, data integration, and query\\\\xe2\\\\x80\\\\x90answering applications. The leading example of a public, general\\\\xe2\\\\x80\\\\x90purpose open knowledge network (<i>aka</i> knowledge graph) is Wikidata, which has demonstrated remarkable advances in quality and coverage over this time. Proprietary knowledge graphs drive some of the leading applications of the day including, for example, Google Search, Alexa, Siri, and Cortana. Open Knowledge Networks are exciting: they promise the power of structured database\\\\xe2\\\\x80\\\\x90like queries with the potential for the wide coverage that is today only provided by the Web. With the current state of the art, building, using, and scaling large knowledge networks can still be frustratingly slow. This article describes a National Science Foundation Convergence Accelerator project to build a set of Knowledge\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"b3ecaca059c96da37ff79e9f0f0a3f43.html","title":"Morphology Without Borders: Clause-Level Morphological Annotation","url":"https://arxiv.org/abs/2202.12832","authors":["Omer Goldman","Reut Tsarfaty"],"date":"2022/02/25","journal":"arXiv preprint arXiv:2202.12832","abstract":""},{"id":"19f9fd3f9103cf3458009cf8e778d87f.html","title":"Sex and gender bias in natural language processing","url":"https://www.sciencedirect.com/science/article/pii/B9780128213926000091","authors":["Davide Cirillo","Hila Gonen","Enrico Santus","Alfonso Valencia","Marta R Costa-juss\\\\xc3\\\\xa0","Marta Villegas"],"date":"2022/01/1","abstract":"<div><div class=\\"gsh_csp\\">Natural language processing (NLP) is increasingly applied to a broad range of sensitive tasks, such as human resources, biomedicine, and healthcare. Accordingly, a growing body of research is investigating the impact of sex and gender bias in the models and the data on which such models are trained. As NLP systems become more pervasive in our societies, the vulnerability to sex and gender bias may cause the perpetuation of prejudice and discriminatory decisions. To address this challenge, a widespread awareness of bias needs to be created in the NLP community and more robust learning algorithms and fair solutions are required for the development and evaluation of NLP methods. In this chapter, we survey the state-of-the-art NLP models and some popular applications to biomedicine and health, with special emphasis on chatbots for mental health. Moreover, we discuss sources and implications of bias\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"f24c16c830cabafb87ac197c2aeab083.html","title":"\\" Um... it\\\\\'s really difficult to... um.. speak fluently\\": Neural tracking of spontaneous speech","url":"https://www.biorxiv.org/content/10.1101/2022.09.20.508802.abstract","authors":["Galit Agmon","Manuela Jaeger","Reut Tsarfaty","Martin G Bleichner","Elana Zion Golumbic"],"date":"2022/01/1","journal":"bioRxiv","abstract":"Spontaneous real-life speech is imperfect in many ways. It contains disfluencies and ill-formed utterances that the brain needs to contend with in order to extract meaning out of speech. Here, we studied how the neural speech-tracking response is affected by three specific factors that are prevalent in spontaneous colloquial speech: (1) the presence of non-lexical fillers, (2) the need to detect syntactic boundaries in disfluent speech and (3) the effort involved in processing syntactically complex phrases. Neural activity (EEG) was recorded from individuals as they listened to an unscripted, spontaneous narrative, which was analyzed in a time-resolved fashion to identify fillers, detect syntactic boundaries and assess the syntactic complexity of different phrases. When considering these factors in the speech-tracking analysis, we found that it was affected by all of them. The most consistent effect, observed for all three factors, was modulation of a centro-frontal negative response that peaked around 350 ms, highly resembling the well-known N400 ERP response linked to various aspects of lexical access and semantic processing. This response was observed for lexical words but not for fillers, was larger for opening vs. closing words of a clause and was enhanced in response to high-complexity phrases. These findings broaden ongoing efforts to understand neural processing of speech under increasingly realistic conditions. They highlight the importance of considering the imperfect nature of real-life spoken language, linking past research on linguistically well-formed and meticulously controlled speech to the type of speech that the brain actually deals\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"487ee42eaf144108997648125d4f3ea8.html","title":"Morphology Without Borders: Clause-Level Morphology","url":"http://114.215.220.151:8000/20221020/Morphology%20Without%20Borders-%20Clause-Level%20Morphology.pdf","authors":["Omer Goldman","Reut Tsarfaty"],"date":"2022","journal":"Transactions of the Association for Computational Linguistics","abstract":"Morphological tasks use large multi-lingual datasets that organize words into inflection tables, which then serve as training and evaluation data for various tasks. However, a closer inspection of these data reveals profound cross-linguistic inconsistencies, that arise from the lack of a clear linguistic and operational definition of what is a word, and that severely impair the universality of the derived tasks. To overcome this deficiency, we propose to view morphology as a clauselevel phenomenon, rather than word-level. It is anchored in a fixed yet inclusive set of features, that encapsulates all functions realized in a saturated clause. We deliver MIGHTYMORPH, a novel dataset for clause-level morphology covering 4 typologically-different languages: English, German, Turkish and Hebrew. We use this dataset to derive 3 clause-level morphological tasks: inflection, reinflection and analysis. Our experiments show that the clause-level tasks are substantially harder than the respective word-level tasks, while having comparable complexity across languages. Furthermore, redefining morphology to the clause-level provides a neat interface with contextualized language models (LMs) and allows assessing the morphological knowledge encoded in these models and their usability for morphological tasks. Taken together, this work opens up new horizons in the study of computational morphology, leaving ample space for studying neural morphology cross-linguistically."},{"id":"a347f34c1e96e44a01bf3aaa346178fe.html","title":"Annotation Scheme for Aggregated Argumentation in Online Educational Forums","url":"https://www.researchgate.net/profile/Noa-Brandel/publication/363039612_Annotation_Scheme_for_Aggregated_Argumentation_in_Online_Educational_Forums/links/632b2a520a708521500f281c/Annotation-Scheme-for-Aggregated-Argumentation-in-Online-Educational-Forums.pdf","authors":["Noa Brandel","Royi Lachmy","Noa Yomtovyan","Reut Tsarfaty","Baruch Schwarz"],"date":"2022","abstract":"We present an ongoing work of collecting small-group online discussions written in Hebrew. Discussants deal with contentious topics, while complying with educational ground rules. Our growing repository comprises 152 discussions containing over 3k turns. We propose an annotation procedure for turning such unstructured data into structured argument data in three stages:(i) segmenting to discourse and e-talk units,(ii) classifying e-talk units, and (iii) identifying and classifying relations between e-talk units. We applied the scheme to a sample. The results indicate the feasibility of the scheme as well as the abundance of natural argumentation and the intensity of interaction in the data."},{"id":"e0cb3ea66ec2bbd28f82a7f14c474c39.html","title":"McPhraSy: Multi context phrase similarity and clustering","url":"https://www.amazon.science/publications/mcphrasy-multi-context-phrase-similarity-and-clustering","authors":["Amir DN Cohen","Hila Gonen","Ori Shapira","Ran Levy","Yoav Goldberg"],"date":"2022","abstract":"Phrase similarity is a key component of many NLP applications. Current phrase similarity methods focus on embedding the phrase itself and use the phrase context only during training of the pretrained model. To better leverage the information in the context, we propose McPhraSy (Multi-context Phrase Similarity), a novel algorithm for estimating the similarity of phrases based on multiple contexts. At inference time, McPhraSy represents each phrase by considering multiple contexts in which it appears and computes the similarity of two phrases by aggregating the pairwise similarities between the contexts of the phrases. Incorporating context during inference enables McPhraSy to outperform current state-of-theart models on two phrase similarity datasets by up to 13.3%. Finally, we also present a new downstream task that relies on phrase similarity\\\\xe2\\\\x80\\\\x93keyphrase clustering\\\\xe2\\\\x80\\\\x93and create a new benchmark for it in the product reviews domain. We show that McPhraSy surpasses all other baselines for this task."},{"id":"b3b3e87a2b04e58a2c135454d7f9ea9d.html","title":"A proposition-level clustering approach for multi-document summarization","url":"https://arxiv.org/abs/2112.08770","authors":["Ori Ernst","Avi Caciularu","Ori Shapira","Ramakanth Pasunuru","Mohit Bansal","Jacob Goldberger","Ido Dagan"],"date":"2021/12/16","journal":"arXiv preprint arXiv:2112.08770","abstract":""},{"id":"b50aec380dd86ee681952fccde2b69d4.html","title":"Utilizing Evidence Spans via Sequence-Level Contrastive Learning for Long-Context Question Answering","url":"https://arxiv.org/abs/2112.08777","authors":["Avi Caciularu","Ido Dagan","Jacob Goldberger","Arman Cohan"],"date":"2021/12/16","journal":"arXiv preprint arXiv:2112.08777","abstract":""},{"id":"dd4123c3c445f65b2b0474821d00efbe.html","title":"Erratum: Measuring and Improving Consistency in Pretrained Language Models","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_x_00455/108602","authors":["Yanai Elazar","Nora Kassner","Shauli Ravfogel","Abhilasha Ravichander","Eduard Hovy","Hinrich Sch\\\\xc3\\\\xbctze","Yoav Goldberg"],"date":"2021/12/06","journal":"Transactions of the Association for Computational Linguistics","abstract":"During production of this paper, an error was introduced to the formula on the bottom of the right column of page 1020. In the last two terms of the formula, the n and m subscripts were swapped. The correct formula is:Lc=\\\\xe2\\\\x88\\\\x91n=1k\\\\xe2\\\\x88\\\\x91m=n+1kDKL(Qnri\\\\xe2\\\\x88\\\\xa5Qmri)+DKL(Qmri\\\\xe2\\\\x88\\\\xa5Qnri)The paper has been updated."},{"id":"7ce905c5f5921dd3b7f37343a5f84f12.html","title":"Proceedings of the Fifth Workshop on Universal Dependencies (UDW, SyntaxFest 2021)","url":"https://aclanthology.org/2021.udw-1.0.pdf","authors":["Miryam de Lhoneux","Reut Tsarfaty"],"date":"2021/12","abstract":"Universal Dependencies (UD) is a framework for cross-linguistically consistent treebank annotation that has so far been applied to over 100 languages (http://universaldependencies. org/). The framework is aiming to capture similarities as well as idiosyncrasies among typologically different languages (eg, morphologically rich languages, pro-drop languages, and languages featuring clitic doubling). The goal in developing UD was not only to support comparative evaluation and cross-lingual learning but also to facilitate multilingual natural language processing and enable comparative linguistic studies."},{"id":"2492b5eb66c9992f66e20deadbf55cc2.html","title":"Dyna-bAbI: unlocking bAbI\\\\\'s potential with dynamic synthetic benchmarking","url":"https://arxiv.org/abs/2112.00086","authors":["Ronen Tamari","Kyle Richardson","Aviad Sar-Shalom","Noam Kahlon","Nelson Liu","Reut Tsarfaty","Dafna Shahaf"],"date":"2021/11/30","journal":"arXiv preprint arXiv:2112.00086","abstract":"99% accuracy), neither approach succeeded in the compositional generalization setting, indicating the limitations of the original training data. We explored ways to augment the original data, and found that though diversifying training data was far more useful than simply increasing dataset size, it was still insufficient for driving robust compositional generalization (with <70% accuracy for complex compositions). Our results underscore the importance of highly controllable task generators for creating robust NLU systems through a virtuous cycle of model and data development."},{"id":"3a7395970dce2ba0258d886c2876fd66.html","title":"Well-defined morphology is sentence-level morphology","url":"https://aclanthology.org/2021.mrl-1.23/","authors":["Omer Goldman","Reut Tsarfaty"],"date":"2021/11","abstract":"Morphological tasks have gained decent popularity within the NLP community in the recent years, with large multi-lingual datasets providing morphological analysis of words, either in or out of context. However, the lack of a clear linguistic definition for words destines the annotative work to be incomplete and mired in inconsistencies, especially cross-linguistically. In this work we expand morphological inflection of words to inflection of sentences to provide true universality disconnected from orthographic traditions of white-space usage. To allow annotation for sentence-inflection we define a morphological annotation scheme by a fixed set of inflectional features. We present a small cross-linguistic dataset including semi-manually generated simple sentences in 4 typologically diverse languages annotated according to our suggested scheme, and show that the task of reinflection gets substantially more difficult but that the change of scope from words to well-defined sentences allows interface with contextualized language models."},{"id":"49dd869f1f5e47d5009735cf40bec935.html","title":"Extending Multi-Text Sentence Fusion Resources via Pyramid Annotations","url":"https://arxiv.org/abs/2110.04517","authors":["Daniela Brook Weiss","Paul Roit","Ori Ernst","Ido Dagan"],"date":"2021/10/09","journal":"arXiv preprint arXiv:2110.04517","abstract":""},{"id":"3ee304f6496e818f9d02eba9239e8e7b.html","title":"Multi-Document Keyphrase Extraction: A Literature Review and the First Dataset","url":"https://arxiv.org/abs/2110.01073","authors":["Ori Shapira","Ramakanth Pasunuru","Ido Dagan","Yael Amsterdamer"],"date":"2021/10/03","abstract":""},{"id":"c1d628449bb8c857b2abd704c469605e.html","title":"ifacetsum: Coreference-based interactive faceted summarization for multi-document exploration","url":"https://arxiv.org/abs/2109.11621","authors":["Eran Hirsch","Alon Eirew","Ori Shapira","Avi Caciularu","Arie Cattan","Ori Ernst","Ramakanth Pasunuru","Hadar Ronen","Mohit Bansal","Ido Dagan"],"date":"2021/09/23","journal":"arXiv preprint arXiv:2109.11621","abstract":""},{"id":"38493c710fe9f3d5aa21b13ef47170d7.html","title":"Asking it all: Generating contextualized questions for any semantic role","url":"https://arxiv.org/abs/2109.04832","authors":["Valentina Pyatkin","Paul Roit","Julian Michael","Reut Tsarfaty","Yoav Goldberg","Ido Dagan"],"date":"2021/09/10","journal":"arXiv preprint arXiv:2109.04832","abstract":""},{"id":"007cbefebd815eb34519ac816809ef99.html","title":"QA-Align: Representing Cross-Text Content Overlap by Aligning Question-Answer Propositions","url":"https://ui.adsabs.harvard.edu/abs/2021arXiv210912655B/abstract","authors":["Daniela Brook Weiss","Paul Roit","Ayal Klein","Ori Ernst","Ido Dagan"],"date":"2021/09","journal":"arXiv e-prints","abstract":"Multi-text applications, such as multi-document summarization, are typically required to model redundancies across related texts. Current methods confronting consolidation struggle to fuse overlapping information. In order to explicitly represent content overlap, we propose to align predicate-argument relations across texts, providing a potential scaffold for information consolidation. We go beyond clustering coreferring mentions, and instead model overlap with respect to redundancy at a propositional level, rather than merely detecting shared referents. Our setting exploits QA-SRL, utilizing question-answer pairs to capture predicate-argument relations, facilitating laymen annotation of cross-text alignments. We employ crowd-workers for constructing a dataset of QA-based alignments, and present a baseline QA alignment model trained over our dataset. Analyses show that our new task is semantically challenging\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"a2e8249360d6096eaf3c7fbee82a93c4.html","title":"(Un) solving Morphological Inflection: Lemma Overlap Artificially Inflates Models\\\\\' Performance","url":"https://arxiv.org/abs/2108.05682","authors":["Omer Goldman","David Guriel","Reut Tsarfaty"],"date":"2021/08/12","journal":"arXiv preprint arXiv:2108.05682","abstract":""},{"id":"347b12d8a25711df92a879220358e3e2.html","title":"Proceedings of the 17th International Conference on Parsing Technologies and the IWPT 2021 Shared Task on Parsing into Enhanced Universal Dependencies (IWPT 2021)","url":"https://aclanthology.org/2021.iwpt-1.0.pdf","authors":["Stephan Oepen","Kenji Sagae","Reut Tsarfaty","Gosse Bouma","Djam\\\\xc3\\\\xa9 Seddah","Daniel Zeman"],"date":"2021/08","abstract":"Welcome to the 17th International Conference on Parsing Technologies (IWPT 2021), which this year (for only the second time since 2007) is co-located with the Annual Meeting of the Association for Computational Linguistics and of the Asian Federation of Natural Language Processing (ACL-IJCNLP). The IWPT meeting series, hosted by the ACL Special Interest Group in Natural Language Parsing (SIGPARSE), has been held biennualy since its inaugual meeting in 1989 in Pittsburgh, PA (USA)."},{"id":"43278519e32daa2ce64d5794bdd069de.html","title":"Teach the Rules, Provide the Facts: Targeted Relational-knowledge Enhancement for Textual Inference","url":"https://aclanthology.org/2021.starsem-1.8/","authors":["Ohad Rozen","Shmuel Amar","Vered Shwartz","Ido Dagan"],"date":"2021/08","abstract":"We present InferBert, a method to enhance transformer-based inference models with relevant relational knowledge. Our approach facilitates learning generic inference patterns requiring relational knowledge (eg inferences related to hypernymy) during training, while injecting on-demand the relevant relational facts (eg pangolin is an animal) at test time. We apply InferBERT to the NLI task over a diverse set of inference types (hypernymy, location, color, and country of origin), for which we collected challenge datasets. In this setting, InferBert succeeds to learn general inference patterns, from a relatively small number of training instances, while not hurting performance on the original NLI data and substantially outperforming prior knowledge enhancement models on the challenge data. It further applies its inferences successfully at test time to previously unobserved entities. InferBert is computationally more efficient than most prior methods, in terms of number of parameters, memory consumption and training time."},{"id":"48f5dee23c8f0c76c59e6914411c14da.html","title":"Proceedings of the 1st Workshop on Natural Language Processing for Programming (NLP4Prog 2021)","url":"https://aclanthology.org/2021.nlp4prog-1.0.pdf","authors":["Royi Lachmy","Ziyu Yao","Greg Durrett","Milos Gligoric","Junyi Jessy Li","Ray Mooney","Graham Neubig","Yu Su","Huan Sun","Reut Tsarfaty"],"date":"2021/08","abstract":"The proliferation of programming-related platforms such as GitHub and Stack Overflow has led to large amounts of rich, open-source data consisting of programs associated with natural language, such as natural language questions and answers with code snippets, open-source repositories with natural language comments, and communications between software developers. At the same time, deep learning based techniques have shown promising performance for modeling both natural language and computer programs. Driven by these revolutions on data and models, recent years have witnessed a major resurgence of using NLP techniques to assist programming (NLP4Prog)."},{"id":"50129dee9aadb1f75379e5032e2324a6.html","title":"Proceedings of the 1st Workshop on Understanding Implicit and Underspecified Language","url":"https://aclanthology.org/2021.unimplicit-1.0.pdf","authors":["Michael Roth","Reut Tsarfaty","Yoav Goldberg"],"date":"2021/08","abstract":"Welcome to UnImplicit: The First Workshop on Understanding Implicit and Underspecified Language. The focus of this workshop is on implicit and underspecified phenomena in language, which pose serious challenges to standard natural language processing models as they often require incorporating greater context, using symbolic inference and common-sense reasoning, or more generally, going beyond strictly lexical and compositional meaning constructs. This challenge spans all phases of the NLP model\\\\xe2\\\\x80\\\\x99s life cycle: from collecting and annotating relevant data, through devising computational methods for modelling such phenomena, to evaluating and designing proper evaluation metrics."},{"id":"ac29c9dac3204f92c7b6844c0424cae7.html","title":"Proceedings of the 3rd Workshop on Gender Bias in Natural Language Processing","url":"https://aclanthology.org/2021.gebnlp-1.0.pdf","authors":["Marta Costa-jussa","Hila Gonen","Christian Hardmeier","Kellie Webster"],"date":"2021/08","abstract":"This volume contains the proceedings of the Third Workshop on Gender Bias in Natural Language Processing held in conjunction with the Joint Conference of the 59th Annual Meeting of the Association for Computational Linguistics and the 11th International Joint Conference on Natural Language Processing (ACL-IJCNLP 2021). This year, the organisation committee changed membership: Will Radford made way to Hila Gonen. We thank Will greatly for his valuable and enthusiastic contributions to this workshop, and offer a warm welcome to Hila, whose expertise and insight we are all excited to learn from."},{"id":"f704b5a3aa08a7c8e4c3c9e70d6b32e5.html","title":"On the Power of Saturated Transformers: A View from Circuit Complexity","url":"https://arxiv.org/abs/2106.16213","authors":["William Merrill","Yoav Goldberg","Roy Schwartz","Noah A Smith"],"date":"2021/06/30","journal":"arXiv preprint arXiv:2106.16213","abstract":"<g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 10.50000)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 623 -45 Q 469 -45 350 25 T 166 221 T 102 500 Q 102 723 228 944 T 562 1304 T 995 1444 Q 1112 1444 1209 1402 T 1373 1285 T 1476 1111 T 1513 893 Q 1513 724 1441 556 T 1241 251 T 955 34 T 623 -45 Z M 639 16 Q 788 16 917 110 T 1137 354 T 1276 668 T 1325 975 Q 1325 1086 1287 1178 T 1170 1327 T 981 1384 Q 873 1384 771 1332 T 586 1194 Q 501 1107 435 978 T 335 708 T 301 442 Q 301 268 386 142 T 639 16 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 790.55902, 0.00000)\\" d=\\"M 635 -508 Q 521 -418 438 -302 T 303 -53 T 225 223 T 199 512 Q 199 659 225 803 T 304 1080 T 441 1329 T 635 1532 Q 635 1536 645 1536 H 664 Q 670 1536 675 1530 T 680 1518 Q 680 1509 676 1505 Q 576 1407 509 1295 T 402 1056 T 344 794 T 326 512 Q 326 -139 674 -477 Q 680 -483 680 -494 Q 680 -499 674 -506 T 664 -512 H 645 Q 635 -512 635 -508 Z \\"></path><g transform=\\"translate(1179.44897, 0.00000)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 63 0 V 72 Q 133 72 178 83 T 223 137 V 1212 Q 223 1267 206 1291 T 159 1321 T 63 1327 V 1399 L 367 1421 V 137 Q 367 94 412 83 T 526 72 V 0 H 63 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 277.78000, 0.00000)\\" d=\\"M 512 -23 Q 389 -23 284 39 T 118 207 T 57 436 Q 57 530 90 617 T 186 772 T 332 879 T 512 918 Q 638 918 741 851 T 905 673 T 965 436 Q 965 313 904 207 T 738 39 T 512 -23 Z M 512 37 Q 676 37 731 156 T 786 459 Q 786 562 775 629 T 727 752 Q 704 786 668 811 T 593 850 T 512 864 Q 448 864 390 835 T 295 752 Q 257 694 246 624 T 236 459 Q 236 344 256 252 T 336 99 T 512 37 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 777.78003, 0.00000)\\" d=\\"M 57 -160 Q 57 -87 110 -33 T 236 45 Q 195 76 173 123 T 152 223 Q 152 319 213 393 Q 119 485 119 604 Q 119 668 146 724 T 223 821 T 332 883 T 455 905 Q 577 905 674 834 Q 716 879 773 903 T 893 928 Q 937 928 965 896 T 993 821 Q 993 796 974 777 T 930 758 Q 904 758 885 777 T 866 821 Q 866 859 891 874 Q 785 874 709 801 Q 746 764 768 710 T 791 604 Q 791 517 743 447 T 616 339 T 455 301 Q 343 301 250 362 Q 221 322 221 272 Q 221 218 256 177 T 346 137 H 514 Q 636 137 734 115 T 898 27 T 965 -160 Q 965 -250 889 -310 T 707 -396 T 512 -422 Q 421 -422 315 -396 T 133 -310 T 57 -160 Z M 172 -160 Q 172 -229 228 -276 T 363 -345 T 512 -367 Q 581 -367 660 -345 T 794 -276 T 850 -160 Q 850 -53 752 -22 T 514 10 H 346 Q 299 10 259 -13 T 196 -76 T 172 -160 Z M 455 356 Q 629 356 629 604 Q 629 711 592 780 T 455 850 Q 355 850 318 780 T 281 604 Q 281 536 295 481 T 347 391 T 455 356 Z \\"></path></g><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 2637.78418, 0.00000)\\" d=\\"M 158 35 Q 158 47 160 53 L 313 664 Q 328 721 328 764 Q 328 852 268 852 Q 204 852 173 775 T 113 582 Q 113 576 107 572 T 96 569 H 72 Q 65 569 60 576 T 55 590 Q 77 679 97 741 T 161 854 T 270 905 Q 347 905 406 856 T 465 733 Q 526 813 608 859 T 782 905 Q 855 905 908 880 T 990 804 T 1020 684 Q 1020 600 982 481 T 889 215 Q 860 148 860 92 Q 860 31 907 31 Q 987 31 1040 117 T 1116 301 Q 1120 313 1133 313 H 1157 Q 1165 313 1170 308 T 1176 295 Q 1176 293 1174 289 Q 1146 173 1076 75 T 903 -23 Q 831 -23 780 26 T 729 147 Q 729 185 745 227 Q 771 294 804 387 T 859 565 T 881 715 Q 881 772 857 812 T 778 852 Q 703 852 640 819 T 530 731 T 444 602 L 305 45 Q 298 17 273 -3 T 219 -23 Q 194 -23 176 -7 T 158 35 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 3238.00415, 0.00000)\\" d=\\"M 133 -512 Q 115 -512 115 -494 Q 115 -485 119 -481 Q 469 -139 469 512 Q 469 1163 123 1501 Q 115 1506 115 1518 Q 115 1525 120 1530 T 133 1536 H 152 Q 158 1536 162 1532 Q 309 1416 407 1250 T 550 896 T 596 512 Q 596 367 571 226 T 493 -51 T 358 -303 T 162 -508 Q 158 -512 152 -512 H 133 Z \\"></path></g></svg>, which implies saturated transformers can be simulated by log-depth circuits. Thus, the jump from hard to saturated attention can be understood as increasing the transformer\\\\\'s effective circuit depth by a factor of <svg class=\\"gs_fsvg\\" aria-label=\\"O(\\\\\\\\log n)\\" width=\\"51px\\" height=\\"14px\\" style=\\"vertical-align:-4px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 10.50000)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 623 -45 Q 469 -45 350 25 T 166 221 T 102 500 Q 102 723 228 944 T 562 1304 T 995 1444 Q 1112 1444 1209 1402 T 1373 1285 T 1476 1111 T 1513 893 Q 1513 724 1441 556 T 1241 251 T 955 34 T 623 -45 Z M 639 16 Q 788 16 917 110 T 1137 354 T 1276 668 T 1325 975 Q 1325 1086 1287 1178 T 1170 1327 T 981 1384 Q 873 1384 771 1332 T 586 1194 Q 501 1107 435 978 T 335 708 T 301 442 Q 301 268 386 142 T 639 16 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 790.55902, 0.00000)\\" d=\\"M 635 -508 Q 521 -418 438 -302 T 303 -53 T 225 223 T 199 512 Q 199 659 225 803 T 304 1080 T 441 1329 T 635 1532 Q 635 1536 645 1536 H 664 Q 670 1536 675 1530 T 680 1518 Q 680 1509 676 1505 Q 576 1407 509 1295 T 402 1056 T 344 794 T 326 512 Q 326 -139 674 -477 Q 680 -483 680 -494 Q 680 -499 674 -506 T 664 -512 H 645 Q 635 -512 635 -508 Z \\"></path><g transform=\\"translate(1179.44897, 0.00000)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 63 0 V 72 Q 133 72 178 83 T 223 137 V 1212 Q 223 1267 206 1291 T 159 1321 T 63 1327 V 1399 L 367 1421 V 137 Q 367 94 412 83 T 526 72 V 0 H 63 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 277.78000, 0.00000)\\" d=\\"M 512 -23 Q 389 -23 284 39 T 118 207 T 57 436 Q 57 530 90 617 T 186 772 T 332 879 T 512 918 Q 638 918 741 851 T 905 673 T 965 436 Q 965 313 904 207 T 738 39 T 512 -23 Z M 512 37 Q 676 37 731 156 T 786 459 Q 786 562 775 629 T 727 752 Q 704 786 668 811 T 593 850 T 512 864 Q 448 864 390 835 T 295 752 Q 257 694 246 624 T 236 459 Q 236 344 256 252 T 336 99 T 512 37 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 777.78003, 0.00000)\\" d=\\"M 57 -160 Q 57 -87 110 -33 T 236 45 Q 195 76 173 123 T 152 223 Q 152 319 213 393 Q 119 485 119 604 Q 119 668 146 724 T 223 821 T 332 883 T 455 905 Q 577 905 674 834 Q 716 879 773 903 T 893 928 Q 937 928 965 896 T 993 821 Q 993 796 974 777 T 930 758 Q 904 758 885 777 T 866 821 Q 866 859 891 874 Q 785 874 709 801 Q 746 764 768 710 T 791 604 Q 791 517 743 447 T 616 339 T 455 301 Q 343 301 250 362 Q 221 322 221 272 Q 221 218 256 177 T 346 137 H 514 Q 636 137 734 115 T 898 27 T 965 -160 Q 965 -250 889 -310 T 707 -396 T 512 -422 Q 421 -422 315 -396 T 133 -310 T 57 -160 Z M 172 -160 Q 172 -229 228 -276 T 363 -345 T 512 -367 Q 581 -367 660 -345 T 794 -276 T 850 -160 Q 850 -53 752 -22 T 514 10 H 346 Q 299 10 259 -13 T 196 -76 T 172 -160 Z M 455 356 Q 629 356 629 604 Q 629 711 592 780 T 455 850 Q 355 850 318 780 T 281 604 Q 281 536 295 481 T 347 391 T 455 356 Z \\"></path></g><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 2637.78418, 0.00000)\\" d=\\"M 158 35 Q 158 47 160 53 L 313 664 Q 328 721 328 764 Q 328 852 268 852 Q 204 852 173 775 T 113 582 Q 113 576 107 572 T 96 569 H 72 Q 65 569 60 576 T 55 590 Q 77 679 97 741 T 161 854 T 270 905 Q 347 905 406 856 T 465 733 Q 526 813 608 859 T 782 905 Q 855 905 908 880 T 990 804 T 1020 684 Q 1020 600 982 481 T 889 215 Q 860 148 860 92 Q 860 31 907 31 Q 987 31 1040 117 T 1116 301 Q 1120 313 1133 313 H 1157 Q 1165 313 1170 308 T 1176 295 Q 1176 293 1174 289 Q 1146 173 1076 75 T 903 -23 Q 831 -23 780 26 T 729 147 Q 729 185 745 227 Q 771 294 804 387 T 859 565 T 881 715 Q 881 772 857 812 T 778 852 Q 703 852 640 819 T 530 731 T 444 602 L 305 45 Q 298 17 273 -3 T 219 -23 Q 194 -23 176 -7 T 158 35 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 3238.00415, 0.00000)\\" d=\\"M 133 -512 Q 115 -512 115 -494 Q 115 -485 119 -481 Q 469 -139 469 512 Q 469 1163 123 1501 Q 115 1506 115 1518 Q 115 1525 120 1530 T 133 1536 H 152 Q 158 1536 162 1532 Q 309 1416 407 1250 T 550 896 T 596 512 Q 596 367 571 226 T 493 -51 T 358 -303 T 162 -508 Q 158 -512 152 -512 H 133 Z \\"></path></g></svg>."},{"id":"7c64af89057b7dbfdf7564be51f23c47.html","title":"Draw me a flower: Grounding formal abstract structures stated in informal natural language","url":"https://arxiv.org/abs/2106.14321","authors":["Royi Lachmy","Valentina Pyatkin","Reut Tsarfaty"],"date":"2021/06/27","journal":"arXiv preprint arXiv:2106.14321","abstract":""},{"id":"363866b024b00107a22948adb2c7cf1f.html","title":"The Possible, the Plausible, and the Desirable: Event-Based Modality Detection for Language Processing","url":"https://arxiv.org/abs/2106.08037","authors":["Valentina Pyatkin","Shoval Sadde","Aynat Rubinstein","Paul Portner","Reut Tsarfaty"],"date":"2021/06/15","journal":"arXiv preprint arXiv:2106.08037","abstract":""},{"id":"0d94aa6a4e12227644e9be0ad18ec389.html","title":"Thinking Like Transformers","url":"http://proceedings.mlr.press/v139/weiss21a.html","authors":["Gail Weiss","Yoav Goldberg","Eran Yahav"],"date":"2021/06/13","journal":"arXiv preprint arXiv:2106.06981","abstract":"What is the computational model behind a Transformer? Where recurrent neural networks have direct parallels in finite state machines, allowing clear discussion and thought around architecture variants or trained models, Transformers have no such familiar parallel. In this paper we aim to change that, proposing a computational model for the transformer-encoder in the form of a programming language. We map the basic components of a transformer-encoder\\\\xe2\\\\x80\\\\x94attention and feed-forward computation\\\\xe2\\\\x80\\\\x94into simple primitives, around which we form a programming language: the Restricted Access Sequence Processing Language (RASP). We show how RASP can be used to program solutions to tasks that could conceivably be learned by a Transformer, and how a Transformer can be trained to mimic a RASP solution. In particular, we provide RASP programs for histograms, sorting, and Dyck-languages. We further use our model to relate their difficulty in terms of the number of required layers and attention heads: analyzing a RASP program implies a maximum number of heads and layers necessary to encode a task in a transformer. Finally, we see how insights gained from our abstraction might be used to explain phenomena seen in recent works."},{"id":"9ce1183f30e173e5ae1d293a931aaf20.html","title":"Neural Extractive Search","url":"https://arxiv.org/abs/2106.04612","authors":["Shauli Ravfogel","Hillel Taub-Tabib","Yoav Goldberg"],"date":"2021/06/08","journal":"arXiv preprint arXiv:2106.04612","abstract":""},{"id":"b647f413c9121f00882ad2bad4c0598f.html","title":"Realistic evaluation principles for cross-document coreference resolution","url":"https://arxiv.org/abs/2106.04192","authors":["Arie Cattan","Alon Eirew","Gabriel Stanovsky","Mandar Joshi","Ido Dagan"],"date":"2021/06/08","journal":"arXiv preprint arXiv:2106.04192","abstract":""},{"id":"e06752572bd6369ff3c3bd44e3b93ce9.html","title":"CommonsenseQA 2.0: Exposing the Limits of AI through Gamification","url":"https://arxiv.org/abs/2201.05320","authors":["Alon Talmor","Ori Yoran","Ronan Le Bras","Chandra Bhagavatula","Yoav Goldberg","Yejin Choi","Jonathan Berant"],"date":"2021/06/07","abstract":""},{"id":"0a7b8b079aedc1abd1b4ec3b25c1b386.html","title":"Denoising word embeddings by averaging in a shared space","url":"https://arxiv.org/abs/2106.02954","authors":["Avi Caciularu","Ido Dagan","Jacob Goldberger"],"date":"2021/06/05","journal":"arXiv preprint arXiv:2106.02954","abstract":""},{"id":"a8dcfd514063bca825ea5e630341d9e0.html","title":"Cross-document coreference resolution over predicted mentions","url":"https://arxiv.org/abs/2106.01210","authors":["Arie Cattan","Alon Eirew","Gabriel Stanovsky","Mandar Joshi","Ido Dagan"],"date":"2021/06/02","journal":"arXiv preprint arXiv:2106.01210","abstract":""},{"id":"2b0c8b1eaf4252067f57b709adabc8d7.html","title":"Extending multi-document summarization evaluation to the interactive setting","url":"https://aclanthology.org/2021.naacl-main.54/?utm_campaign=%E6%AF%8E%E9%80%B1%20NLP%20%E8%AB%96%E6%96%87&utm_medium=email&utm_source=Revue%20newsletter","authors":["Ori Shapira","Ramakanth Pasunuru","Hadar Ronen","Mohit Bansal","Yael Amsterdamer","Ido Dagan"],"date":"2021/06","abstract":"Allowing users to interact with multi-document summarizers is a promising direction towards improving and customizing summary results. Different ideas for interactive summarization have been proposed in previous work but these solutions are highly divergent and incomparable. In this paper, we develop an end-to-end evaluation framework for interactive summarization, focusing on expansion-based interaction, which considers the accumulating information along a user session. Our framework includes a procedure of collecting real user sessions, as well as evaluation measures relying on summarization standards, but adapted to reflect interaction. All of our solutions and resources are available publicly as a benchmark, allowing comparison of future developments in interactive summarization, and spurring progress in its methodological evaluation. We demonstrate the use of our framework by evaluating and comparing baseline implementations that we developed for this purpose, which will serve as part of our benchmark. Our extensive experimentation and analysis motivate the proposed evaluation framework design and support its viability."},{"id":"6e725ce480416aca11940f2eb741c882.html","title":"BitFit: Simple Parameter-efficient Fine-tuning for Transformer-based Masked Language-models","url":"https://arxiv.org/abs/2106.10199","authors":["Elad Ben Zaken","Shauli Ravfogel","Yoav Goldberg"],"date":"2021/06","journal":"arXiv e-prints","abstract":""},{"id":"785098357ec34f544e1e9502c83d6c41.html","title":"Hebrew Psychological Lexicons","url":"https://aclanthology.org/2021.clpsych-1.6/","authors":["Natalie Shapira","Dana Atzil-Slonim","Daniel Juravski","Moran Baruch","Dana Stolowicz-Melman","Adar Paz","Tal Alfi-Yogev","Roy Azoulay","Adi Singer","Maayan Revivo","Chen Dahbash","Limor Dayan","Tamar Naim","Lidar Gez","Boaz Yanai","Adva Maman","Adam Nadaf","Elinor Sarfati","Amna Baloum","Tal Naor","Ephraim Mosenkis","Badreya Sarsour","Jany Gelfand Morgenshteyn","Yarden Elias","Liat Braun","Moria Rubin","Matan Kenigsbuch","Noa Bergwerk","Noam Yosef","Sivan Peled","Coral Avigdor","Rahav Obercyger","Rachel Mann","Tomer Alper","Inbal Beka","Ori Shapira","Yoav Goldberg"],"date":"2021/06","abstract":"We introduce a large set of Hebrew lexicons pertaining to psychological aspects. These lexicons are useful for various psychology applications such as detecting emotional state, well being, relationship quality in conversation, identifying topics (eg, family, work) and many more. We discuss the challenges in creating and validating lexicons in a new language, and highlight our methodological considerations in the data-driven lexicon construction process. Most of the lexicons are publicly available, which will facilitate further research on Hebrew clinical psychology text analysis. The lexicons were developed through data driven means, and verified by domain experts, clinical psychologists and psychology students, in a process of reconciliation with three judges. Development and verification relied on a dataset of a total of 872 psychotherapy session transcripts. We describe the construction process of each collection, the final resource and initial results of research studies employing this resource."},{"id":"6d3dfed90fb29dfb47edc38fa73c3f71.html","title":"Cofga: A Dataset for Fine Grained Classification of Objects from Aerial Imagery","url":"https://arxiv.org/abs/2105.12786","authors":["Eran Dahan","Tzvi Diskin","Amit Amram","Amit Moryossef","Omer Koren"],"date":"2021/05/26","journal":"arXiv preprint arXiv:2105.12786","abstract":""},{"id":"0e2afeb4afe5f29ea22f588e5276188a.html","title":"Data Augmentation for Sign Language Gloss Translation","url":"https://arxiv.org/abs/2105.07476","authors":["Amit Moryossef","Kayo Yin","Graham Neubig","Yoav Goldberg"],"date":"2021/05/16","journal":"arXiv preprint arXiv:2105.07476","abstract":""},{"id":"cbbad3071050f42e9a8bf15f12bfad46.html","title":"Counterfactual Interventions Reveal the Causal Effect of Relative Clause Representations on Agreement Prediction","url":"https://arxiv.org/abs/2105.06965","authors":["Shauli Ravfogel","Grusha Prasad","Tal Linzen","Yoav Goldberg"],"date":"2021/05/14","journal":"arXiv preprint arXiv:2105.06965","abstract":""},{"id":"9776b95b42a6943012b1c0b7c30e660e.html","title":"Including Signed Languages in Natural Language Processing","url":"https://arxiv.org/abs/2105.05222","authors":["Kayo Yin","Amit Moryossef","Julie Hochgesang","Yoav Goldberg","Malihe Alikhani"],"date":"2021/05/11","journal":"arXiv preprint arXiv:2105.05222","abstract":""},{"id":"33efd6ff4fe5d274a664b9ac02a131fe.html","title":"Provable Limitations of Acquiring Meaning from Ungrounded Form: What will Future Language Models Understand?","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_a_00412/107385","authors":["William Merrill","Yoav Goldberg","Roy Schwartz","Noah A Smith"],"date":"2021/04/22","journal":"arXiv preprint arXiv:2104.10809","abstract":"Language models trained on billions of tokens have recently led to unprecedented results on many NLP tasks. This success raises the question of whether, in principle, a system can ever \\\\xe2\\\\x80\\\\x9cunderstand\\\\xe2\\\\x80\\\\x9d raw text without access to some form of grounding. We formally investigate the abilities of ungrounded systems to acquire meaning. Our analysis focuses on the role of \\\\xe2\\\\x80\\\\x9cassertions\\\\xe2\\\\x80\\\\x9d: textual contexts that provide indirect clues about the underlying semantics. We study whether assertions enable a system to emulate representations preserving semantic relations like equivalence. We find that assertions enable semantic emulation of languages that satisfy a strong notion of semantic transparency. However, for classes of languages where the same expression can take different values in different contexts, we show that emulation can become uncomputable. Finally, we discuss differences between our formal model and\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"d3f3e4eba4adbed7c2e26d1e1e9a0916.html","title":"Identifying helpful sentences in product reviews","url":"https://arxiv.org/abs/2104.09792","authors":["Iftah Gamzu","Hila Gonen","Gilad Kutiel","Ran Levy","Eugene Agichtein"],"date":"2021/04/20","journal":"arXiv preprint arXiv:2104.09792","abstract":""},{"id":"7b7e03bd4311a50328c104c48ff76a1d.html","title":"Scico: Hierarchical cross-document coreference for scientific concepts","url":"https://arxiv.org/abs/2104.08809","authors":["Arie Cattan","Sophie Johnson","Daniel Weld","Ido Dagan","Iz Beltagy","Doug Downey","Tom Hope"],"date":"2021/04/18","journal":"arXiv preprint arXiv:2104.08809","abstract":""},{"id":"bfa433d1388b8e5fbfe7ab80a88ce245.html","title":"Revisiting Few-shot Relation Classification: Evaluation Data and Classification Schemes","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_a_00392/106791","authors":["Ofer Sabo","Yanai Elazar","Yoav Goldberg","Ido Dagan"],"date":"2021/04/17","journal":"arXiv preprint arXiv:2104.08481","abstract":"We explore few-shot learning (FSL) for relation classification (RC). Focusing on the realistic scenario of FSL, in which a test instance might not belong to any of the target categories (none-of-the-above, [NOTA]), we first revisit the recent popular dataset structure for FSL, pointing out its unrealistic data distribution. To remedy this, we propose a novel methodology for deriving more realistic few-shot test data from available datasets for supervised RC, and apply it to the TACRED dataset. This yields a new challenging benchmark for FSL-RC, on which state of the art models show poor performance. Next, we analyze classification schemes within the popular embedding-based nearest-neighbor approach for FSL, with respect to constraints they impose on the embedding space. Triggered by this analysis, we propose a novel classification scheme in which the NOTA category is represented as learned vectors, shown\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"9e2d3b89b49b6c47ed2913e83d252685.html","title":"Minimal Supervision for Morphological Inflection","url":"https://arxiv.org/abs/2104.08512","authors":["Omer Goldman","Reut Tsarfaty"],"date":"2021/04/17","journal":"arXiv preprint arXiv:2104.08512","abstract":""},{"id":"0b2418527e22a049b8f7e785f51a6750.html","title":"Back to square one: Artifact detection, training and commonsense disentanglement in the winograd schema","url":"https://arxiv.org/abs/2104.08161","authors":["Yanai Elazar","Hongming Zhang","Yoav Goldberg","Dan Roth"],"date":"2021/04/16","journal":"arXiv preprint arXiv:2104.08161","abstract":""},{"id":"932dc4ef13d1f54c7e303124485b8111.html","title":"Does BERT Pretrained on Clinical Notes Reveal Sensitive Data?","url":"https://arxiv.org/abs/2104.07762","authors":["Eric Lehman","Sarthak Jain","Karl Pichotta","Yoav Goldberg","Byron C Wallace"],"date":"2021/04/15","journal":"arXiv preprint arXiv:2104.07762","abstract":""},{"id":"a0caa53d022de1939381b6cb7002d06d.html","title":"WEC: Deriving a large-scale cross-document event coreference dataset from Wikipedia","url":"https://arxiv.org/abs/2104.05022","authors":["Alon Eirew","Arie Cattan","Ido Dagan"],"date":"2021/04/11","journal":"arXiv preprint arXiv:2104.05022","abstract":""},{"id":"e7c2f659b544b8495a55283f8179f234.html","title":"AlephBERT: A Hebrew large pre-trained language model to start-off your Hebrew NLP application with","url":"https://arxiv.org/abs/2104.04052","authors":["Amit Seker","Elron Bandel","Dan Bareket","Idan Brusilovsky","Refael Shaked Greenfeld","Reut Tsarfaty"],"date":"2021/04/08","journal":"arXiv preprint arXiv:2104.04052","abstract":""},{"id":"b1a6865fcb55d610d11692f6f10d6604.html","title":"Proceedings of the 16th Conference of the European Chapter of the Association for Computational Linguistics: Main Volume","url":"https://aclanthology.org/2021.eacl-main.0.pdf","authors":["Paola Merlo","J\\\\xc3\\\\xb6rg Tiedemann","Reut Tsarfaty"],"date":"2021/04","abstract":"Welcome to EACL 2021, the 16th conference of the European Chapter of the Association for Computational Linguistics! This year\\\\xe2\\\\x80\\\\x99s conference is held from the 21st to the 23rd of April, 2021. While we were planning to hold the conference in Kyiv, due to the current COVID situation the conference is held entirely online. EACL 2021 is also an anchor conference to several workshops and tutorials, that are held on April 19th and 20th, also online."},{"id":"45be7452f3099134506a504603c4549a.html","title":"Using topic models to identify clients\\\\xe2\\\\x80\\\\x99 functioning levels and alliance ruptures in psychotherapy.","url":"https://psycnet.apa.org/psycarticles/2021-27454-001.pdf","authors":["Dana Atzil-Slonim","Daniel Juravski","Eran Bar-Kalifa","Eva Gilboa-Schechtman","Rivka Tuval-Mashiach","Natalie Shapira","Yoav Goldberg"],"date":"2021/03/18","journal":"Psychotherapy","abstract":"Computerized natural language processing techniques can analyze psychotherapy sessions as texts, thus generating information about the therapy process and outcome and supporting the scaling-up of psychotherapy research. We used topic modeling to identify topics discussed in psychotherapy sessions and explored (a) which topics best identified clients\\\\xe2\\\\x80\\\\x99 functioning and alliance ruptures and (b) whether changes in these topics were associated with changes in outcome. Transcripts of 873 sessions from 58 clients treated by 52 therapists were analyzed. Before each session, clients self-reported functioning and symptom level. After each session, therapists reported the extent of alliance rupture. Latent Dirichlet allocation was used to extract latent topics from psychotherapy textual data. Then a sparse multinomial logistic regression model was used to predict which topics best identified clients\\\\xe2\\\\x80\\\\x99 functioning levels\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"72e4ff79b23db72f79ba470bfd32b78d.html","title":"Contrastive explanations for model interpretability","url":"https://arxiv.org/abs/2103.01378","authors":["Alon Jacovi","Swabha Swayamdipta","Shauli Ravfogel","Yanai Elazar","Yejin Choi","Yoav Goldberg"],"date":"2021/03/02","journal":"arXiv preprint arXiv:2103.01378","abstract":""},{"id":"746b675e268561d51ea26c624e73f530.html","title":"Bootstrapping Relation Extractors using Syntactic Search by Examples","url":"https://arxiv.org/abs/2102.05007","authors":["Matan Eyal","Asaf Amrami","Hillel Taub-Tabib","Yoav Goldberg"],"date":"2021/02/09","journal":"arXiv preprint arXiv:2102.05007","abstract":""},{"id":"178ffbed70bef3156cfbfab4fcaf2be5.html","title":"Measuring and improving consistency in pretrained language models","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_a_00410/107384","authors":["Yanai Elazar","Nora Kassner","Shauli Ravfogel","Abhilasha Ravichander","Eduard Hovy","Hinrich Sch\\\\xc3\\\\xbctze","Yoav Goldberg"],"date":"2021/02/01","journal":"Transactions of the Association for Computational Linguistics","abstract":" <i>Consistency</i> of a model\\\\xe2\\\\x80\\\\x94that is, the invariance of its behavior under meaning-preserving alternations in its input\\\\xe2\\\\x80\\\\x94is a highly desirable property in natural language processing. In this paper we study the question: Are Pretrained Language Models (PLMs) consistent with respect to factual knowledge? To this end, we create <span class=\\"gs_fscp\\">ParaRel</span>\\\\xf0\\\\x9f\\\\xa4\\\\x98, a high-quality resource of cloze-style query English paraphrases. It contains a total of 328 paraphrases for 38 relations. Using <span class=\\"gs_fscp\\">ParaRel</span>\\\\xf0\\\\x9f\\\\xa4\\\\x98, we show that the consistency of all PLMs we experiment with is poor\\\\xe2\\\\x80\\\\x94 though with high variance between relations. Our analysis of the representational spaces of PLMs suggests that they have a poor structure and are currently not suitable for representing knowledge robustly. Finally, we propose a method for improving model consistency and experimentally demonstrate its effectiveness."},{"id":"201f91fe3499a61ad07cb3a943497d9c.html","title":"Amnesic probing: Behavioral explanation with amnesic counterfactuals","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_a_00359/98091","authors":["Yanai Elazar","Shauli Ravfogel","Alon Jacovi","Yoav Goldberg"],"date":"2021/02/01","journal":"Transactions of the Association for Computational Linguistics","abstract":"A growing body of work makes use of <i>probing</i> in order to investigate the working of neural models, often considered black boxes. Recently, an ongoing debate emerged surrounding the limitations of the probing paradigm. In this work, we point out the inability to infer behavioral conclusions from probing results, and offer an alternative method that focuses on how the information is being used, rather than on what information is encoded. Our method, <i>Amnesic Probing</i>, follows the intuition that the utility of a property for a given task can be assessed by measuring the influence of a causal intervention that removes it from the representation. Equipped with this new analysis tool, we can ask questions that were not possible before, for example, is part-of-speech information important for word prediction? We perform a series of analyses on BERT to answer these types of questions. Our findings demonstrate that\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"ebdddbe36b3556558219dffcd777a23b.html","title":"CD2CR: Co-reference Resolution Across Documents and Domains","url":"https://arxiv.org/abs/2101.12637","authors":["James Ravenscroft","Arie Cattan","Amanda Clare","Ido Dagan","Maria Liakata"],"date":"2021/01/29","journal":"arXiv preprint arXiv:2101.12637","abstract":"<g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 11.58769)\\"><g><path transform=\\"matrix(0.34180, 0.00000, 0.00000, -0.34180, 0.00000, -362.89200)\\" d=\\"M 129 0 V 59 Q 129 68 137 76 L 502 432 Q 523 454 535 466 T 571 502 Q 692 623 759 727 T 827 956 Q 827 1024 804 1083 T 739 1187 T 641 1254 T 516 1278 Q 425 1278 349 1231 T 236 1104 H 242 Q 291 1104 322 1071 T 354 991 Q 354 945 322 912 T 242 879 Q 195 879 162 912 T 129 991 Q 129 1101 190 1185 T 349 1314 T 551 1360 Q 675 1360 786 1313 T 965 1174 T 1034 956 Q 1034 865 993 786 T 892 648 T 726 505 T 588 395 L 338 182 H 526 Q 603 182 687 182 T 836 185 T 905 193 Q 923 212 934 261 T 956 381 H 1034 L 973 0 H 129 Z \\"></path></g></g></svg>CR). The task aims to identify links between entities across heterogeneous document types. We show that in this cross-domain, cross-document setting, existing CDCR models do not perform well and we provide a baseline model that outperforms current state-of-the-art CDCR models on CD<svg class=\\"gs_fsvg\\" aria-label=\\"^2\\" width=\\"6px\\" height=\\"12px\\" style=\\"vertical-align:0px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 11.58769)\\"><g><path transform=\\"matrix(0.34180, 0.00000, 0.00000, -0.34180, 0.00000, -362.89200)\\" d=\\"M 129 0 V 59 Q 129 68 137 76 L 502 432 Q 523 454 535 466 T 571 502 Q 692 623 759 727 T 827 956 Q 827 1024 804 1083 T 739 1187 T 641 1254 T 516 1278 Q 425 1278 349 1231 T 236 1104 H 242 Q 291 1104 322 1071 T 354 991 Q 354 945 322 912 T 242 879 Q 195 879 162 912 T 129 991 Q 129 1101 190 1185 T 349 1314 T 551 1360 Q 675 1360 786 1313 T 965 1174 T 1034 956 Q 1034 865 993 786 T 892 648 T 726 505 T 588 395 L 338 182 H 526 Q 603 182 687 182 T 836 185 T 905 193 Q 923 212 934 261 T 956 381 H 1034 L 973 0 H 129 Z \\"></path></g></g></svg>CR. Our data set, annotation tool and guidelines as well as our model for cross-document cross-domain co-reference are all supplied as open access open source resources."},{"id":"fae2d35b880158058f87ad7c0f722685.html","title":"First align, then predict: Understanding the cross-lingual ability of multilingual BERT","url":"https://arxiv.org/abs/2101.11109","authors":["Benjamin Muller","Yanai Elazar","Beno\\\\xc3\\\\xaet Sagot","Djam\\\\xc3\\\\xa9 Seddah"],"date":"2021/01/26","journal":"arXiv preprint arXiv:2101.11109","abstract":""},{"id":"283d2642fca0a572a0de586578f8a6fd.html","title":"Message from the Organizers","url":"https://cris.bgu.ac.il/en/publications/message-from-the-organizers","authors":["Royi Lachmy","Ziyu Yao","Greg Durrett","Milos Gligoric","Junyi Jessy Li","Ray Mooney","Graham Neubig","Yu Su","Huan Sun","Reut Tsarfaty"],"date":"2021/01/1","journal":"NLP4Prog 2021-1st Workshop on Natural Language Processing for Programming, Proceedings of the Workshop","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_oci_field\\">Scholar articles"},{"id":"2fb9378a0d421d61a6453176e0688652.html","title":"Cross-document language modeling","url":"https://researchain.net/archives/pdf/Cross-Document-Language-Modeling-1914484","authors":["Avi Caciularu","Arman Cohan","Iz Beltagy","Matthew E Peters","Arie Cattan","Ido Dagan"],"date":"2021/01/1","journal":"arXiv preprint arXiv:2101.00406","abstract":"We introduce a new pretraining approach for language models that are geared to support multi-document NLP tasks. Our cross-document language model (CD-LM) improves masked language modeling for these tasks with two key ideas. First, we pretrain with multiple related documents in a single input, via cross-document masking, which encourages the model to learn cross-document and long-range relationships. Second, extending the recent Longformer model, we pretrain with long contexts of several thousand tokens and introduce a new attention pattern that uses sequence-level global attention to predict masked tokens, while retaining the familiar local attention elsewhere. We show that our CD-LM sets new state-of-the-art results for several multi-text tasks, including cross-document event and entity coreference resolution, paper citation recommendation, and documents plagiarism detection, while using a significantly reduced number of training parameters relative to prior works."},{"id":"2dcb02939a37220b93cc2a4413a22261.html","title":"CDLM: Cross-document language modeling","url":"https://arxiv.org/abs/2101.00406","authors":["Avi Caciularu","Arman Cohan","Iz Beltagy","Matthew E Peters","Arie Cattan","Ido Dagan"],"date":"2021/01/02","journal":"arXiv preprint arXiv:2101.00406","abstract":""},{"id":"3243498d1f2a20bd0486dedf38d54d8f.html","title":"Sign language processing","url":"https://scholar.google.com/scholar?cluster=14499252734653308117&hl=en&oi=scholarr","authors":["Amit Moryossef","Yoav Goldberg"],"date":"2021"},{"id":"b37a5995d1ef6b3f70a35c608456b596.html","title":"Evaluating the immediate applicability of pose estimation for sign language recognition","url":"https://openaccess.thecvf.com/content/CVPR2021W/ChaLearn/html/Moryossef_Evaluating_the_Immediate_Applicability_of_Pose_Estimation_for_Sign_Language_CVPRW_2021_paper.html","authors":["Amit Moryossef","Ioannis Tsochantaridis","Joe Dinn","Necati Cihan Camgoz","Richard Bowden","Tao Jiang","Annette Rios","Mathias Muller","Sarah Ebling"],"date":"2021","abstract":"Signed languages are visual languages produced by the movement of the hands, face, and body. In this paper, we evaluate representations based on skeleton poses, as these are explainable, person-independent, privacy-preserving, low-dimensional representations. Basically, skeletal representations generalize over an individual\\\\\'s appearance and background, allowing us to focus on the recognition of motion. But how much information is lost by the skeletal representation? We perform two independent studies using two state-of-the-art pose estimation systems. We analyze the applicability of the pose estimation systems to sign language recognition by evaluating the failure cases of the recognition models. Importantly, this allows us to characterize the current limitations of skeletal pose estimation approaches in sign language recognition."},{"id":"fe447599c5140bd32bd799e3a6d85b15.html","title":"Sign language datasets","url":"https://scholar.google.com/scholar?cluster=16152962152402983930&hl=en&oi=scholarr","authors":["Amit Moryossef"],"date":"2021"},{"id":"ae51f679c646689f0a72f4f382ae911b.html","title":"Facts2Story: Controlling Text Generation by Key Facts","url":"https://arxiv.org/abs/2012.04332","authors":["Eyal Orbach","Yoav Goldberg"],"date":"2020/12/08","journal":"arXiv preprint arXiv:2012.04332","abstract":""},{"id":"04cc422d2348b6e2ada8c4bf388fd8fc.html","title":"QANom: Question-Answer driven SRL for Nominalizations","url":"https://www.aclweb.org/anthology/2020.coling-main.274/","authors":["Ayal Klein","Jonathan Mamou","Valentina Pyatkin","Daniela Stepanov","Hangfeng He","Dan Roth","Luke Zettlemoyer","Ido Dagan"],"date":"2020/12","abstract":"We propose a new semantic scheme for capturing predicate-argument relations for nominalizations, termed QANom. This scheme extends the QA-SRL formalism (He et al., 2015), modeling the relations between nominalizations and their arguments via natural language question-answer pairs. We construct the first QANom dataset using controlled crowdsourcing, analyze its quality and compare it to expertly annotated nominal-SRL annotations, as well as to other QA-driven annotations. In addition, we train a baseline QANom parser for identifying nominalizations and labeling their arguments with question-answer pairs. Finally, we demonstrate the extrinsic utility of our annotations for downstream tasks using both indirect supervision and zero-shot settings."},{"id":"3bca8464c18af9b71026cd27b9169dd2.html","title":"oLMpics-on what language model pre-training captures","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_a_00342/96476","authors":["Alon Talmor","Yanai Elazar","Yoav Goldberg","Jonathan Berant"],"date":"2020/12","journal":"Transactions of the Association for Computational Linguistics","abstract":"Recent success of pre-trained language models (LMs) has spurred widespread interest in the language capabilities that they possess. However, efforts to understand whether LM representations are useful for symbolic reasoning tasks have been limited and scattered. In this work, we propose eight reasoning tasks, which conceptually require operations such as comparison, conjunction, and composition. A fundamental challenge is to understand whether the performance of a LM on a task should be attributed to the pre-trained representations or to the process of fine-tuning on the task data. To address this, we propose an evaluation protocol that includes both zero-shot evaluation (no fine-tuning), as well as comparing the learning curve of a fine-tuned LM to the learning curve of multiple controls, which paints a rich picture of the LM capabilities. Our main findings are that: (a) different LMs exhibit qualitatively\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"5aa70928d6a64b5b6b50f6129740a50c.html","title":"Compressing Pre-trained Language Models by Matrix Decomposition","url":"https://aclanthology.org/2020.aacl-main.88/?ref=https://githubhelp.com","authors":["Matan Ben Noach","Yoav Goldberg"],"date":"2020/12","abstract":"Large pre-trained language models reach state-of-the-art results on many different NLP tasks when fine-tuned individually; They also come with a significant memory and computational requirements, calling for methods to reduce model sizes (green AI). We propose a two-stage model-compression method to reduce a model\\\\xe2\\\\x80\\\\x99s inference time cost. We first decompose the matrices in the model into smaller matrices and then perform feature distillation on the internal representation to recover from the decomposition. This approach has the benefit of reducing the number of parameters while preserving much of the information within the model. We experimented on BERT-base model with the GLUE benchmark dataset and show that we can reduce the number of parameters by a factor of 0.4 x, and increase inference speed by a factor of 1.45 x, while maintaining a minimal loss in metric performance."},{"id":"baa39734569d30938c4ae6393939daf2.html","title":"Proceedings of Knowledgeable NLP: the First Workshop on Integrating Structured Knowledge and Neural Networks for NLP","url":"https://www.aclweb.org/anthology/2020.knlp-1.0.pdf","authors":["Oren Sar Shalom","Alexander Panchenko","Cicero dos Santos","Varvara Logacheva","Alessandro Moschitti","Ido Dagan"],"date":"2020/12","abstract":"Welcome to the First Knowledgeable NLP Workshop\u2014a workshop on the use of structured resources in NLP and on development of such resources."},{"id":"43bfecf1bea02dd552b5184fa834a3f6.html","title":"Within-Between Lexical Relation Classification Using Path-based and Distributional Data","url":"https://www.aclweb.org/anthology/2020.emnlp-main.284.pdf","authors":["Oren Barkan","Avi Caciularu","Ido Dagan"],"date":"2020/11","abstract":"We propose the novel Within-Between Relation model for recognizing lexical-semantic relations between words. Our model integrates relational and distributional signals, forming an effective sub-space representation for each relation. We show that the proposed model is competitive and outperforms other baselines, across various benchmarks."},{"id":"7bb57596abec821b5ea839bbb016f495.html","title":"A Pointer Network Architecture for Joint Morphological Segmentation and Tagging","url":"https://www.aclweb.org/anthology/2020.findings-emnlp.391/","authors":["Amit Seker","Reut Tsarfaty"],"date":"2020/11","abstract":"Morphologically Rich Languages (MRLs) such as Arabic, Hebrew and Turkish often require Morphological Disambiguation (MD), ie, the prediction of morphological decomposition of tokens into morphemes, early in the pipeline. Neural MD may be addressed as a simple pipeline, where segmentation is followed by sequence tagging, or as an end-to-end model, predicting morphemes from raw tokens. Both approaches are sub-optimal; the former is heavily prone to error propagation, and the latter does not enjoy explicit access to the basic processing units called morphemes. This paper offers MD architecture that combines the symbolic knowledge of morphemes with the learning capacity of neural end-to-end modeling. We propose a new, general and easy-to-implement Pointer Network model where the input is a morphological lattice and the output is a sequence of indices pointing at a single disambiguated path of morphemes. We demonstrate the efficacy of the model on segmentation and tagging, for Hebrew and Turkish texts, based on their respective Universal Dependencies (UD) treebanks. Our experiments show that with complete lattices, our model outperforms all shared-task results on segmenting and tagging these languages. On the SPMRL treebank, our model outperforms all previously reported results for Hebrew MD in realistic scenarios."},{"id":"a945bc98cd547309b7286bfb6bd93b06.html","title":"Evaluating models\u2019 local decision boundaries via contrast sets","url":"https://www.aclweb.org/anthology/2020.findings-emnlp.117/","authors":["Matt Gardner","Yoav Artzi","Victoria Basmov","Jonathan Berant","Ben Bogin","Sihao Chen","Pradeep Dasigi","Dheeru Dua","Yanai Elazar","Ananth Gottumukkala","Nitish Gupta","Hannaneh Hajishirzi","Gabriel Ilharco","Daniel Khashabi","Kevin Lin","Jiangming Liu","Nelson F Liu","Phoebe Mulcaire","Qiang Ning","Sameer Singh","Noah A Smith","Sanjay Subramanian","Reut Tsarfaty","Eric Wallace","Ally Zhang","Ben Zhou"],"date":"2020/11","abstract":"Standard test sets for supervised learning evaluate in-distribution generalization. Unfortunately, when a dataset has systematic gaps (eg, annotation artifacts), these evaluations are misleading: a model can learn simple decision rules that perform well on the test set but do not capture the abilities a dataset is intended to test. We propose a more rigorous annotation paradigm for NLP that helps to close systematic gaps in the test data. In particular, after a dataset is constructed, we recommend that the dataset authors manually perturb the test instances in small but meaningful ways that (typically) change the gold label, creating contrast sets. Contrast sets provide a local view of a model\u2019s decision boundary, which can be used to more accurately evaluate a model\u2019s true linguistic capabilities. We demonstrate the efficacy of contrast sets by creating them for 10 diverse NLP datasets (eg, DROP reading comprehension, UD parsing, and IMDb sentiment analysis). Although our contrast sets are not explicitly adversarial, model performance is significantly lower on them than on the original test sets\u2014up to 25% in some cases. We release our contrast sets as new evaluation benchmarks and encourage future dataset construction efforts to follow similar annotation processes."},{"id":"8a74baffbe6a6590985c779149df421f.html","title":"Pick a Fight or Bite your Tongue: Investigation of Gender Differences in Idiomatic Language Usage","url":"https://arxiv.org/abs/2011.00335","authors":["Ella Rabinovich","Hila Gonen","Suzanne Stevenson"],"date":"2020/10/31","journal":"arXiv preprint arXiv:2011.00335","abstract":"A large body of research on gender-linked language has established foundations regarding cross-gender differences in lexical, emotional, and topical preferences, along with their sociological underpinnings. We compile a novel, large and diverse corpus of spontaneous linguistic productions annotated with speakers\' gender, and perform a first large-scale empirical study of distinctions in the usage of\\\\\\\\textit {figurative language} between male and female authors. Our analyses suggest that (1) idiomatic choices reflect gender-specific lexical and semantic preferences in general language,(2) men\'s and women\'s idiomatic usages express higher emotion than their literal language, with detectable, albeit more subtle, differences between male and female authors along the dimension of dominance compared to similar distinctions in their literal utterances, and (3) contextual analysis of idiomatic expressions reveals considerable differences, reflecting subtle divergences in usage environments, shaped by cross-gender communication styles and semantic biases."},{"id":"5d930d821acc2f3e0c2f15b1ddda2560.html","title":"Synthesizing control for a system with black box environment, based on deep learning","url":"https://link.springer.com/chapter/10.1007/978-3-030-61470-6_27","authors":["Simon Iosti","Doron Peled","Khen Aharon","Saddek Bensalem","Yoav Goldberg"],"date":"2020/10/20","abstract":"We study the synthesis of control for a system that interacts with a black-box environment, based on deep learning. The goal is to minimize the number of interaction failures. The current state of the environment is unavailable to the controller, hence its operation depends on a limited view of the history. We suggest a reinforcement learning framework of training a Recurrent Neural Network (RNN) to control such a system. We experiment with various parameters: loss function, exploration/exploitation ratio, and size of lookahead. We designed examples that capture various potential control difficulties. We present experiments performed with the toolkit DyNet."},{"id":"4cc6f5cbe445d170e3d2000a281055c5.html","title":"Parameter Norm Growth During Training of Transformers","url":"https://openreview.net/forum?id=tC0xwrmOKXE","authors":["William Merrill","Vivek Ramanujan","Yoav Goldberg","Roy Schwartz","Noah Smith"],"date":"2020/10/19","journal":"arXiv preprint arXiv:2010.09697","abstract":"The capacity of neural networks like the widely adopted transformer is known to be very high. Evidence is emerging that they learn successfully due to inductive bias in the training routine, typically some variant of gradient descent (GD). To better understand this bias, we study the tendency of transformer parameters to grow in magnitude during training. We find, both theoretically and empirically, that, in certain contexts, GD increases the parameter <svg class=\\"gs_fsvg\\" aria-label=\\" L_2 \\" width=\\"16px\\" height=\\"12px\\" style=\\"vertical-align:-2px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 9.56200)\\"><g><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 96 0 Q 76 0 76 27 Q 77 32 80 44 T 88 64 T 102 72 Q 227 72 276 86 Q 303 95 315 141 L 596 1266 Q 600 1286 600 1294 Q 600 1316 575 1319 Q 537 1327 428 1327 Q 408 1327 408 1354 Q 415 1380 419 1389 T 442 1399 H 1047 Q 1065 1399 1065 1372 Q 1062 1351 1058 1339 T 1038 1327 Q 887 1327 836 1317 Q 786 1308 774 1257 L 494 133 Q 485 108 485 88 Q 485 72 555 72 H 745 Q 906 72 1006 136 T 1154 280 T 1234 447 T 1282 537 H 1300 Q 1321 537 1321 510 L 1139 14 Q 1136 0 1120 0 H 96 Z \\"></path><g transform=\\"translate(680.56000, 150.00000)\\"><path transform=\\"scale(0.34180, -0.34180)\\" d=\\"M 129 0 V 59 Q 129 68 137 76 L 502 432 Q 523 454 535 466 T 571 502 Q 692 623 759 727 T 827 956 Q 827 1024 804 1083 T 739 1187 T 641 1254 T 516 1278 Q 425 1278 349 1231 T 236 1104 H 242 Q 291 1104 322 1071 T 354 991 Q 354 945 322 912 T 242 879 Q 195 879 162 912 T 129 991 Q 129 1101 190 1185 T 349 1314 T 551 1360 Q 675 1360 786 1313 T 965 1174 T 1034 956 Q 1034 865 993 786 T 892 648 T 726 505 T 588 395 L 338 182 H 526 Q 603 182 687 182 T 836 185 T 905 193 Q 923 212 934 261 T 956 381 H 1034 L 973 0 H 129 Z \\"></path></g></g></g></svg> norm up to a threshold that itself increases with training-set accuracy. This means increasing training accuracy over time enables the norm to increase. Empirically, we show that the norm grows continuously over pretraining for T5 (Raffel et al., 2019). We show that pretrained T5 approximates a semi-discretized network with saturated activation functions. Such\\" saturated\\" networks are known to have a reduced capacity compared to the original network family that can be\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"09223d33ce40b8a410e85ecc82357aa5.html","title":"It\\\\\'s not Greek to mBERT: Inducing Word-Level Translations from Multilingual BERT","url":"https://arxiv.org/abs/2010.08275","authors":["Hila Gonen","Shauli Ravfogel","Yanai Elazar","Yoav Goldberg"],"date":"2020/10/16","journal":"arXiv preprint arXiv:2010.08275","abstract":""},{"id":"24057e3f0ce9d6750cfe9e1c9972fa96.html","title":"It\'s not Greek to mBERT: Inducing Word-Level Translations from Multilingual BERT","url":"https://arxiv.org/abs/2010.08275","authors":["Hila Gonen","Shauli Ravfogel","Yanai Elazar","Yoav Goldberg"],"date":"2020/10/16","journal":"arXiv preprint arXiv:2010.08275","abstract":"Recent works have demonstrated that multilingual BERT (mBERT) learns rich cross-lingual representations, that allow for transfer across languages. We study the word-level translation information embedded in mBERT and present two simple methods that expose remarkable translation capabilities with no fine-tuning. The results suggest that most of this information is encoded in a non-linear way, while some of it can also be recovered with purely linear tools. As part of our analysis, we test the hypothesis that mBERT learns representations which contain both a language-encoding component and an abstract, cross-lingual component, and explicitly identify an empirical language-identity subspace within mBERT representations."},{"id":"f7838865887b58e5ad3bdce9bec47041.html","title":"Formalizing trust in artificial intelligence: Prerequisites, causes and goals of human trust in ai","url":"https://dl.acm.org/doi/abs/10.1145/3442188.3445923","authors":["Alon Jacovi","Ana Marasovi\\\\xc4\\\\x87","Tim Miller","Yoav Goldberg"],"date":"2020/10/15","journal":"arXiv preprint arXiv:2010.07487","abstract":"Trust is a central component of the interaction between people and AI, in that\\\\\'incorrect\\\\\'levels of trust may cause misuse, abuse or disuse of the technology. But what, precisely, is the nature of trust in AI? What are the prerequisites and goals of the cognitive mechanism of trust, and how can we promote them, or assess whether they are being satisfied in a given interaction? This work aims to answer these questions. We discuss a model of trust inspired by, but not identical to, interpersonal trust (ie, trust between people) as defined by sociologists. This model rests on two key properties: the vulnerability of the user; and the ability to anticipate the impact of the AI model\\\\\'s decisions. We incorporate a formalization of\\\\\'contractual trust\\\\\', such that trust between a user and an AI model is trust that some implicit or explicit contract will hold, and a formalization of\\\\\'trustworthiness\\\\\'(that detaches from the notion of trustworthiness in\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"2e35c73abcbc16d7b18e37ecf1f05ae5.html","title":"The Extraordinary Failure of Complement Coercion Crowdsourcing","url":"https://arxiv.org/abs/2010.05971","authors":["Yanai Elazar","Victoria Basmov","Shauli Ravfogel","Yoav Goldberg","Reut Tsarfaty"],"date":"2020/10/12","journal":"arXiv preprint arXiv:2010.05971","abstract":""},{"id":"296d6857607d59e36261a63cb19a04a1.html","title":"Do Language Embeddings Capture Scales?","url":"https://arxiv.org/abs/2010.05345","authors":["Xikun Zhang","Deepak Ramachandran","Ian Tenney","Yanai Elazar","Dan Roth"],"date":"2020/10/11","journal":"arXiv preprint arXiv:2010.05345","abstract":"Pretrained Language Models (LMs) have been shown to possess significant linguistic, common sense, and factual knowledge. One form of knowledge that has not been studied yet in this context is information about the scalar magnitudes of objects. We show that pretrained language models capture a significant amount of this information but are short of the capability required for general common-sense reasoning. We identify contextual information in pre-training and numeracy as two key factors affecting their performance and show that a simple method of canonicalizing numbers can have a significant effect on the results."},{"id":"3c6fe40f8dff5eb5938d3be27f38f38d.html","title":"Unsupervised Distillation of Syntactic Information from Contextualized Word Representations","url":"https://arxiv.org/abs/2010.05265","authors":["Shauli Ravfogel","Yanai Elazar","Jacob Goldberger","Yoav Goldberg"],"date":"2020/10/11","journal":"arXiv preprint arXiv:2010.05265","abstract":""},{"id":"b70600ec9ca969016a4d1130dd06f9f4.html","title":"Relation Classification as Two-way Span-Prediction","url":"https://arxiv.org/abs/2010.04829","authors":["Amir DN Cohen","Shachar Rosenman","Yoav Goldberg"],"date":"2020/10/09","journal":"arXiv preprint arXiv:2010.04829","abstract":""},{"id":"bc01c05573b4d670884fea3fa3c8f7b8.html","title":"Relation Extraction as Two-way Span-Prediction","url":"https://scholar.google.com/scholar?cluster=5663042029809355594&hl=en&oi=scholarr","authors":["Amir DN Cohen","Shachar Rosenman","Yoav Goldberg"],"date":"2020/10/09","journal":"arXiv preprint arXiv:2010.04829"},{"id":"29f4ce691e8c93728c2f69abb7fa0032.html","title":"Exposing Shallow Heuristics of Relation Extraction Models with Challenge Data","url":"https://arxiv.org/abs/2010.03656","authors":["Shachar Rosenman","Alon Jacovi","Yoav Goldberg"],"date":"2020/10/07","journal":"arXiv preprint arXiv:2010.03656","abstract":""},{"id":"e5620947b08d5bbc26cdf5e014b90bfa.html","title":"ZEST: Zero-shot Learning from Text Descriptions using Textual Similarity and Visual Summarization","url":"https://arxiv.org/abs/2010.03276","authors":["Tzuf Paz-Argaman","Yuval Atzmon","Gal Chechik","Reut Tsarfaty"],"date":"2020/10/07","journal":"arXiv preprint arXiv:2010.03276","abstract":"We study the problem of recognizing visual entities from the textual descriptions of their classes. Specifically, given birds\' images with free-text descriptions of their species, we learn to classify images of previously-unseen species based on specie descriptions. This setup has been studied in the vision community under the name zero-shot learning from text, focusing on learning to transfer knowledge about visual aspects of birds from seen classes to previously-unseen ones. Here, we suggest focusing on the textual description and distilling from the description the most relevant information to effectively match visual features to the parts of the text that discuss them. Specifically,(1) we propose to leverage the similarity between species, reflected in the similarity between text descriptions of the species.(2) we derive visual summaries of the texts, ie, extractive summaries that focus on the visual features that tend to be reflected in images. We propose a simple attention-based model augmented with the similarity and visual summaries components. Our empirical results consistently and significantly outperform the state-of-the-art on the largest benchmarks for text-based zero-shot learning, illustrating the critical importance of texts for zero-shot image-recognition."},{"id":"0a80c11eac766e0300fbfb6452e4fb29.html","title":"QADiscourse--Discourse Relations as QA Pairs: Representation, Crowdsourcing and Baselines","url":"https://arxiv.org/abs/2010.02815","authors":["Valentina Pyatkin","Ayal Klein","Reut Tsarfaty","Ido Dagan"],"date":"2020/10/06","journal":"arXiv preprint arXiv:2010.02815","abstract":"Discourse relations describe how two propositions relate to one another, and identifying them automatically is an integral part of natural language understanding. However, annotating discourse relations typically requires expert annotators. Recently, different semantic aspects of a sentence have been represented and crowd-sourced via question-and-answer (QA) pairs. This paper proposes a novel representation of discourse relations as QA pairs, which in turn allows us to crowd-source wide-coverage data annotated with discourse relations, via an intuitively appealing interface for composing such questions and answers. Based on our proposed representation, we collect a novel and wide-coverage QADiscourse dataset, and present baseline algorithms for predicting QADiscourse relations."},{"id":"647b497b8b48502dd206e44bbf6df621.html","title":"A Novel Challenge Set for Hebrew Morphological Disambiguation and Diacritics Restoration","url":"https://arxiv.org/abs/2010.02864","authors":["Avi Shmidman","Joshua Guedalia","Shaltiel Shmidman","Moshe Koppel","Reut Tsarfaty"],"date":"2020/10/06","journal":"arXiv preprint arXiv:2010.02864","abstract":"One of the primary tasks of morphological parsers is the disambiguation of homographs. Particularly difficult are cases of unbalanced ambiguity, where one of the possible analyses is far more frequent than the others. In such cases, there may not exist sufficient examples of the minority analyses in order to properly evaluate performance, nor to train effective classifiers. In this paper we address the issue of unbalanced morphological ambiguities in Hebrew. We offer a challenge set for Hebrew homographs--the first of its kind--containing substantial attestation of each analysis of 21 Hebrew homographs. We show that the current SOTA of Hebrew disambiguation performs poorly on cases of unbalanced ambiguity. Leveraging our new dataset, we achieve a new state-of-the-art for all 21 words, improving the overall average F1 score from 0.67 to 0.95. Our resulting annotated datasets are made publicly available for further research."},{"id":"b548ab2f9114e739be9915864000faef.html","title":"CoRefi: A Crowd Sourcing Suite for Coreference Annotation","url":"https://arxiv.org/abs/2010.02588","authors":["Aaron Bornstein","Arie Cattan","Ido Dagan"],"date":"2020/10/06","journal":"arXiv preprint arXiv:2010.02588","abstract":"Coreference annotation is an important, yet expensive and time consuming, task, which often involved expert annotators trained on complex decision guidelines. To enable cheaper and more efficient annotation, we present CoRefi, a web-based coreference annotation suite, oriented for crowdsourcing. Beyond the core coreference annotation tool, CoRefi provides guided onboarding for the task as well as a novel algorithm for a reviewing phase. CoRefi is open source and directly embeds into any website, including popular crowdsourcing platforms."},{"id":"df9b9193f90805ff84cf6810a2309028.html","title":"Streamlining Cross-Document Coreference Resolution: Evaluation and Modeling","url":"https://arxiv.org/abs/2009.11032","authors":["Arie Cattan","Alon Eirew","Gabriel Stanovsky","Mandar Joshi","Ido Dagan"],"date":"2020/09/23","journal":"arXiv preprint arXiv:2009.11032","abstract":"Recent evaluation protocols for Cross-document (CD) coreference resolution have often been inconsistent or lenient, leading to incomparable results across works and overestimation of performance. To facilitate proper future research on this task, our primary contribution is proposing a pragmatic evaluation methodology which assumes access to only raw text--rather than assuming gold mentions, disregards singleton prediction, and addresses typical targeted settings in CD coreference resolution. Aiming to set baseline results for future research that would follow our evaluation methodology, we build the first end-to-end model for this task. Our model adapts and extends recent neural models for within-document coreference resolution to address the CD coreference setting, which outperforms state-of-the-art results by a significant margin."},{"id":"95ba82370273c07dd23f85b17086bfcf.html","title":"Evaluating Interactive Summarization: an Expansion-Based Framework","url":"https://arxiv.org/abs/2009.08380","authors":["Ori Shapira","Ramakanth Pasunuru","Hadar Ronen","Mohit Bansal","Yael Amsterdamer","Ido Dagan"],"date":"2020/09/17","journal":"arXiv preprint arXiv:2009.08380","abstract":"Allowing users to interact with multi-document summarizers is a promising direction towards improving and customizing summary results. Different ideas for interactive summarization have been proposed in previous work but these solutions are highly divergent and incomparable. In this paper, we develop an end-to-end evaluation framework for expansion-based interactive summarization, which considers the accumulating information along an interactive session. Our framework includes a procedure of collecting real user sessions and evaluation measures relying on standards, but adapted to reflect interaction. All of our solutions are intended to be released publicly as a benchmark, allowing comparison of future developments in interactive summarization. We demonstrate the use of our framework by evaluating and comparing baseline implementations that we developed for this purpose, which will serve as part of our benchmark. Our extensive experimentation and analysis of these systems motivate our design choices and support the viability of our framework."},{"id":"5ecec18d709a671785d1bd5d60c3e90a.html","title":"Summary-Source Proposition-level Alignment: Task, Datasets and Supervised Baseline","url":"https://arxiv.org/abs/2009.00590","authors":["Ori Ernst","Ori Shapira","Ramakanth Pasunuru","Michael Lepioshkin","Jacob Goldberger","Mohit Bansal","Ido Dagan"],"date":"2020/09/01","journal":"arXiv preprint arXiv:2009.00590","abstract":""},{"id":"bf9d3edd679f721762eedb5c287ddd27.html","title":"SuperPAL: Supervised Proposition ALignment for Multi-Document Summarization and Derivative Sub-Tasks","url":"https://arxiv.org/abs/2009.00590","authors":["Ori Ernst","Ori Shapira","Ramakanth Pasunuru","Michael Lepioshkin","Jacob Goldberger","Mohit Bansal","Ido Dagan"],"date":"2020/09/01","journal":"arXiv preprint arXiv:2009.00590","abstract":"Multi-document summarization (MDS) is a challenging task, often decomposed to subtasks of salience and redundancy detection, followed by generation. While alignment of spans between reference summaries and source documents has been leveraged for training component tasks, the underlying alignment step was never independently addressed or evaluated. We advocate developing high quality source-reference alignment algorithms, that can be applied to recent large-scale datasets to obtain useful\\" silver\\", ie approximate, training data. As a first step, we present an annotation methodology by which we create gold standard development and test sets for summary-source alignment, and suggest its utility for tuning and evaluating effective alignment algorithms, as well as for properly evaluating MDS subtasks. Second, we introduce a new large-scale alignment dataset for training, with which an automatic alignment model was trained. This aligner achieves higher coherency with the reference summary than previous aligners used for summarization, and gets significantly higher ROUGE results when replacing a simpler aligner in a competitive summarization model. Finally, we release three additional datasets (for salience, clustering and generation), naturally derived from our alignment datasets. Furthermore, these datasets can be derived from any summarization dataset automatically after extracting alignments with our trained aligner. Hence, they can be utilized for training summarization sub-tasks."},{"id":"cf94cb07d6e817ef9d291fab3a6dee9f.html","title":"Real-Time Sign Language Detection using Human Pose Estimation","url":"https://arxiv.org/abs/2008.04637","authors":["Amit Moryossef","Ioannis Tsochantaridis","Roee Aharoni","Sarah Ebling","Srini Narayanan"],"date":"2020/08/11","journal":"arXiv preprint arXiv:2008.04637","abstract":"We propose a lightweight real-time sign language detection model, as we identify the need for such a case in videoconferencing. We extract optical flow features based on human pose estimation and, using a linear classifier, show these features are meaningful with an accuracy of 80%, evaluated on the DGS Corpus. Using a recurrent model directly on the input, we see improvements of up to 91% accuracy, while still working under 4ms. We describe a demo application to sign language detection in the browser in order to demonstrate its usage possibility in videoconferencing applications."},{"id":"8c72dfb64ae830082220fcf2685db851.html","title":"Neural Modeling for Named Entities and Morphology (NEMO^ 2)","url":"https://arxiv.org/abs/2007.15620","authors":["Dan Bareket","Reut Tsarfaty"],"date":"2020/07/30","journal":"arXiv preprint arXiv:2007.15620","abstract":"Named Entity Recognition (NER) is a fundamental NLP task, commonly formulated as classification over a sequence of tokens. Morphologically-Rich Languages (MRLs) pose a challenge to this basic formulation, as the boundaries of Named Entities do not coincide with token boundaries, rather, they respect morphological boundaries. To address NER in MRLs we then need to answer two fundamental modeling questions:(i) What should be the basic units to be identified and labeled, are they token-based or morpheme-based? and (ii) How can morphological units be encoded and accurately obtained in realistic (non-gold) scenarios? We empirically investigate these questions on a novel parallel NER benchmark we deliver, with parallel token-level and morpheme-level NER annotations for Modern Hebrew, a morphologically complex language. Our results show that explicitly modeling morphological boundaries consistently leads to improved NER performance, and that a novel hybrid architecture that we propose, in which NER precedes and prunes the morphological decomposition (MD) space, greatly outperforms the standard pipeline approach, on both Hebrew NER and Hebrew MD in realistic scenarios."},{"id":"2b63509b1e903de9fdcaa95e8717c75f.html","title":"Controlled crowdsourcing for high-quality qa-srl annotation","url":"https://www.aclweb.org/anthology/2020.acl-main.626/","authors":["Paul Roit","Ayal Klein","Daniela Stepanov","Jonathan Mamou","Julian Michael","Gabriel Stanovsky","Luke Zettlemoyer","Ido Dagan"],"date":"2020/07","abstract":"Question-answer driven Semantic Role Labeling (QA-SRL) was proposed as an attractive open and natural flavour of SRL, potentially attainable from laymen. Recently, a large-scale crowdsourced QA-SRL corpus and a trained parser were released. Trying to replicate the QA-SRL annotation for new texts, we found that the resulting annotations were lacking in quality, particularly in coverage, making them insufficient for further research and evaluation. In this paper, we present an improved crowdsourcing protocol for complex semantic annotation, involving worker selection and training, and a data consolidation phase. Applying this protocol to QA-SRL yielded high-quality annotation with drastically higher coverage, producing a new gold evaluation dataset. We believe that our annotation protocol and gold standard will facilitate future replicable research of natural semantic annotations."},{"id":"56a17c934c9913ea211b87c4554c713f.html","title":"Simple, interpretable and stable method for detecting words with usage change across corpora","url":"https://www.aclweb.org/anthology/2020.acl-main.51/","authors":["Hila Gonen","Ganesh Jawahar","Djam\\\\xe9 Seddah","Yoav Goldberg"],"date":"2020/07","abstract":"The problem of comparing two bodies of text and searching for words that differ in their usage between them arises often in digital humanities and computational social science. This is commonly approached by training word embeddings on each corpus, aligning the vector spaces, and looking for words whose cosine distance in the aligned space is large. However, these methods often require extensive filtering of the vocabulary to perform well, and-as we show in this work-result in unstable, and hence less reliable, results. We propose an alternative approach that does not use vector space alignment, and instead considers the neighbors of each word. The method is simple, interpretable and stable. We demonstrate its effectiveness in 9 different setups, considering different corpus splitting criteria (age, gender and profession of tweet authors, time of tweet) and different languages (English, French and Hebrew)."},{"id":"d50379d5a343086a976fe55113b3e813.html","title":"Getting the## life out of living: How Adequate Are Word-Pieces for Modelling Complex Morphology?","url":"https://www.aclweb.org/anthology/2020.sigmorphon-1.24/","authors":["Stav Klein","Reut Tsarfaty"],"date":"2020/07","abstract":"This work investigates the most basic units that underlie contextualized word embeddings, such as BERT\u2014the so-called word pieces. In Morphologically-Rich Languages (MRLs) which exhibit morphological fusion and non-concatenative morphology, the different units of meaning within a word may be fused, intertwined, and cannot be separated linearly. Therefore, when using word-pieces in MRLs, we must consider that:(1) a linear segmentation into sub-word units might not capture the full morphological complexity of words; and (2) representations that leave morphological knowledge on sub-word units inaccessible might negatively affect performance. Here we empirically examine the capacity of word-pieces to capture morphology by investigating the task of multi-tagging in Modern Hebrew, as a proxy to evaluate the underlying segmentation. Our results show that, while models trained to predict multi-tags for complete words outperform models tuned to predict the distinct tags of WPs, we can improve the WPs tag prediction by purposefully constraining the word-pieces to reflect their internal functions. We suggest that linguistically-informed word-pieces schemes, that make the morphological structure explicit, might boost performance for MRLs."},{"id":"dc88c54aeab604100e7559b33f271c40.html","title":"Proceedings of the 16th International Conference on Parsing Technologies and the IWPT 2020 Shared Task on Parsing into Enhanced Universal Dependencies","url":"https://www.aclweb.org/anthology/2020.iwpt-1.0.pdf","authors":["Gosse Bouma","Yuji Matsumoto","Stephan Oepen","Kenji Sagae","Djam\\\\xe9 Seddah","Weiwei Sun","Anders S\\\\xf8gaard","Reut Tsarfaty","Daniel Zeman"],"date":"2020/07","abstract":"Welcome to the 16th International Conference on Parsing Technologies (IWPT 2020), which this year (for the first time since 2007) is co-located with the Annual Meeting of the Association for Computational Linguistics (ACL). The IWPT meeting series, hosted by the ACL Special Interest Group in Natural Language Parsing (SIGPARSE), has been held biennualy since its inaugual meeting in 1989 in Pittsburgh, PA (USA)."},{"id":"924a8e57c665a50f0077592663e2c351.html","title":"Leap-Of-Thought: Teaching Pre-Trained Models to Systematically Reason Over Implicit Knowledge","url":"https://proceedings.neurips.cc/paper/2020/hash/e992111e4ab9985366e806733383bd8c-Abstract.html","authors":["Alon Talmor","Oyvind Tafjord","Peter Clark","Yoav Goldberg","Jonathan Berant"],"date":"2020/06/11","journal":"arXiv preprint arXiv:2006.06609","abstract":"To what extent can a neural network systematically reason over symbolic facts? Evidence suggests that large pre-trained language models (LMs) acquire some reasoning capacity, but this ability is difficult to control. Recently, it has been shown that Transformer-based models succeed in consistent reasoning over explicit symbolic facts, under a\\" closed-world\\" assumption. However, in an open-domain setup, it is desirable to tap into the vast reservoir of implicit knowledge already encoded in the parameters of pre-trained LMs. In this work, we provide a first demonstration that LMs can be trained to reliably perform systematic reasoning combining both implicit, pre-trained knowledge and explicit natural language statements."},{"id":"f4c5b35dd26192e486d3f9564f208dca.html","title":"Teaching Pre-Trained Models to Systematically Reason Over Implicit Knowledge","url":"https://ask.qcloudimg.com/draft/7305468/icu1dcp3g6.pdf","authors":["Alon Talmor","Oyvind Tafjord","Peter Clark","Yoav Goldberg","Jonathan Berant"],"date":"2020/06/11","journal":"arXiv preprint arXiv:2006.06609","abstract":"To what extent can a neural network systematically reason over symbolic facts? Evidence suggests that large pre-trained language models (LMs) acquire some reasoning capacity, but this ability is difficult to control. Recently, it has been shown that Transformer-based models succeed in consistent reasoning over explicit symbolic facts, under a \\\\xe2\\\\x80\\\\x9cclosed-world\\" assumption. However, in an open-domain setup, it is desirable to tap into the vast reservoir of implicit knowledge already encoded in the parameters of pre-trained LMs. In this work, we provide a first demonstration that LMs can be trained to reliably perform systematic reasoning combining both implicit, pre-trained knowledge and explicit natural language statements. To do this, we describe a procedure for automatically generating datasets that teach a model new reasoning skills, and demonstrate that models learn to effectively perform inference which involves implicit taxonomic and world knowledge, chaining and counting. Finally, we show that \\\\xe2\\\\x80\\\\x9cteaching\\\\xe2\\\\x80\\\\x9d the models to reason generalizes beyond the training distribution: they successfully compose the usage of multiple reasoning skills in single examples. Our work paves a path towards open-domain systems that constantly improve by interacting with users who can instantly correct a model by adding simple natural language statements."},{"id":"45cf634f3e54e44da76f934ce4e997a9.html","title":"Interactive Extractive Search over Biomedical Corpora","url":"https://arxiv.org/abs/2006.04148","authors":["Hillel Taub-Tabib","Micah Shlain","Shoval Sadde","Dan Lahav","Matan Eyal","Yaara Cohen","Yoav Goldberg"],"date":"2020/06/07","journal":"arXiv preprint arXiv:2006.04148","abstract":""},{"id":"aa9e042eb5957bd21a033323b9e18f32.html","title":"Aligning Faithful Interpretations with their Social Attribution","url":"https://direct.mit.edu/tacl/article-abstract/doi/10.1162/tacl_a_00367/98620","authors":["Alon Jacovi","Yoav Goldberg"],"date":"2020/06/01","journal":"arXiv preprint arXiv:2006.01067","abstract":"We find that the requirement of model interpretations to be faithful is vague and incomplete. With interpretation by textual highlights as a case study, we present several failure cases. Borrowing concepts from social science, we identify that the problem is a misalignment between the causal chain of decisions (causal attribution) and the attribution of human behavior to the interpretation (social attribution). We reformulate faithfulness as an accurate attribution of causality to the model, and introduce the concept of aligned faithfulness: faithful causal chains that are aligned with their expected social behavior. The two steps of causal attribution and social attribution together complete the process of explaining behavior. With this formalization, we characterize various failures of misaligned faithful highlight interpretations, and propose an alternative causal chain to remedy the issues. Finally, we implement highlight\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"aad146d057684ab1c6bdf12c25e9cb2d.html","title":"When Bert Forgets How To POS: Amnesic Probing of Linguistic Properties and MLM Predictions","url":"https://openreview.net/forum?id=28q3WsfS1M","authors":["Yanai Elazar","Shauli Ravfogel","Alon Jacovi","Yoav Goldberg"],"date":"2020/06/01","journal":"arXiv preprint arXiv:2006.00995","abstract":"A growing body of work makes use of probing to investigate the working of neural models, often considered black boxes. Recently, an ongoing debate emerged surrounding the limitations of the probing paradigm. In this work, we point out the inability to infer behavioral conclusions from probing results and offer an alternative method that focuses on how the information is being used, rather than on what information is encoded. Our method, Amnesic Probing, follows the intuition that the utility of a property for a given task can be assessed by measuring the influence of a causal intervention that removes it from the representation. Equipped with this new analysis tool, we can ask questions that were not possible before, eg is part-of-speech information important for word prediction? We perform a series of analyses on BERT to answer these types of questions. Our findings demonstrate that conventional probing\xa0\\\\xe2\\\\x80\\\\xa6"},{"id":"054e0d1487e040372d182330fcfa888a.html","title":"Nakdan: Professional Hebrew Diacritizer","url":"https://arxiv.org/abs/2005.03312","authors":["Avi Shmidman","Shaltiel Shmidman","Moshe Koppel","Yoav Goldberg"],"date":"2020/05/07","journal":"arXiv preprint arXiv:2005.03312","abstract":"We present a system for automatic diacritization of Hebrew text. The system combines modern neural models with carefully curated declarative linguistic knowledge and comprehensive manually constructed tables and dictionaries. Besides providing state of the art diacritization accuracy, the system also supports an interface for manual editing and correction of the automatic output, and has several features which make it particularly useful for preparation of scientific editions of Hebrew texts. The system supports Modern Hebrew, Rabbinic Hebrew and Poetic Hebrew. The system is freely accessible for all use at this http URL."},{"id":"16bc27f00280565f5a64660d8445cfc4.html","title":"pyBART: Evidence-based Syntactic Transformations for IE","url":"https://arxiv.org/abs/2005.01306","authors":["Aryeh Tiktinsky","Yoav Goldberg","Reut Tsarfaty"],"date":"2020/05/04","journal":"arXiv preprint arXiv:2005.01306","abstract":"Syntactic dependencies can be predicted with high accuracy, and are useful for both machine-learned and pattern-based information extraction tasks. However, their utility can be improved. These syntactic dependencies are designed to accurately reflect syntactic relations, and they do not make semantic relations explicit. Therefore, these representations lack many explicit connections between content words, that would be useful for downstream applications. Proposals like English Enhanced UD improve the situation by extending universal dependency trees with additional explicit arcs. However, they are not available to Python users, and are also limited in coverage. We introduce a broad-coverage, data-driven and linguistically sound set of transformations, that makes event-structure and many lexical relations explicit. We present pyBART, an easy-to-use open-source Python library for converting English UD trees either to Enhanced UD graphs or to our representation. The library can work as a standalone package or be integrated within a spaCy NLP pipeline. When evaluated in a pattern-based relation extraction scenario, our representation results in higher extraction scores than Enhanced UD, while requiring fewer patterns."},{"id":"8e99762e3f8772b3890597c1905240fa.html","title":"From SPMRL to NMRL: What Did We Learn (and Unlearn) in a Decade of Parsing Morphologically-Rich Languages (MRLs)?","url":"https://arxiv.org/abs/2005.01330","authors":["Reut Tsarfaty","Dan Bareket","Stav Klein","Amit Seker"],"date":"2020/05/04","journal":"arXiv preprint arXiv:2005.01330","abstract":"It has been exactly a decade since the first establishment of SPMRL, a research initiative unifying multiple research efforts to address the peculiar challenges of Statistical Parsing for Morphologically-Rich Languages (MRLs). Here we reflect on parsing MRLs in that decade, highlight the solutions and lessons learned for the architectural, modeling and lexical challenges in the pre-neural era, and argue that similar challenges re-emerge in neural architectures for MRLs. We then aim to offer a climax, suggesting that incorporating symbolic ideas proposed in SPMRL terms into nowadays neural architectures has the potential to push NLP for MRLs to a new level. We sketch strategies for designing Neural Models for MRLs (NMRL), and showcase preliminary support for these strategies via investigating the task of multi-tagging in Hebrew, a morphologically-rich, high-fusion, language"},{"id":"42a8fbdc06fe2db6b1152a37e72a2b42.html","title":"A Two-Stage Masked LM Method for Term Set Expansion","url":"https://arxiv.org/abs/2005.01063","authors":["Guy Kushilevitz","Shaul Markovitch","Yoav Goldberg"],"date":"2020/05/03","journal":"arXiv preprint arXiv:2005.01063","abstract":"We tackle the task of Term Set Expansion (TSE): given a small seed set of example terms from a semantic class, finding more members of that class. The task is of great practical utility, and also of theoretical utility as it requires generalization from few examples. Previous approaches to the TSE task can be characterized as either distributional or pattern-based. We harness the power of neural masked language models (MLM) and propose a novel TSE algorithm, which combines the pattern-based and distributional approaches. Due to the small size of the seed set, fine-tuning methods are not effective, calling for more creative use of the MLM. The gist of the idea is to use the MLM to first mine for informative patterns with respect to the seed set, and then to obtain more members of the seed class by generalizing these patterns. Our method outperforms state-of-the-art TSE algorithms. Implementation is available at: this https URL guykush/TermSetExpansion-MPB/"},{"id":"76a64892a4005093844b85277551debe.html","title":"Using Computerized Text Analysis to Examine Associations Between Linguistic Features and Clients\u2019 Distress during Psychotherapy","url":"https://www.researchgate.net/profile/Natalie_Shapira/publication/340595443_Running_head_ASSOCIATIONS_BETWEEN_LINGUISTIC_FEATURES_AND_CLIENTS\'_DISTRESS_Using_Computerized_Text_Analysis_to_Examine_Associations_Between_Linguistic_Features_and_Clients\'_Distress_during_Psychother/links/5e9391ad299bf13079945b1b/Running-head-ASSOCIATIONS-BETWEEN-LINGUISTIC-FEATURES-AND-CLIENTS-DISTRESS-Using-Computerized-Text-Analysis-to-Examine-Associations-Between-Linguistic-Features-and-Clients-Distress-during-Psychotherap.pdf","authors":["Natalie Shapira","Gal Lazarus","Yoav Goldberg","Eva Gilboa-Schechtman","Rivka Tuval-Mashiach","Daniel Juravski","Dana Atzil-Slonim"],"date":"2020/04/30","journal":"Journal of counseling psychology","abstract":"Raw linguistic data within psychotherapy sessions may provide important information about clients\u2019 progress and well-being. In the current study, computerized text analytic techniques were applied to examine whether linguistic features were associated with clients\u2019 experiences of distress within and between clients and whether changes in linguistic features were associated with changes in treatment outcome. Method: Transcripts of 729 psychotherapy sessions from 58 clients treated by 52 therapists were analyzed. Prior to each session, clients reported their distress level. Linguistic features were extracted automatically by employing natural language parser for first-person singular identification and using positive and negative emotion words lexicon. The association between linguistic features and levels of distress was examined using multilevel models. Results: At the within-client level, fewer first-person singular words, fewer negative emotional words and more positive emotional words were associated with lower distress in the same session; and fewer negative emotion words were associated with lower next session distress (rather small f2 effect sizes\u20130.011< f2< 0.022). At the between-client level, only first session use of positive emotion words was associated with first session distress (medium \u03b7 \ud835\udc5d"},{"id":"e0508c6ecb0e6ba4737c1945ea39b6eb.html","title":"Paraphrasing vs Coreferring: Two Sides of the Same Coin","url":"https://arxiv.org/abs/2004.14979","authors":["Yehudit Meged","Avi Caciularu","Vered Shwartz","Ido Dagan"],"date":"2020/04/30","journal":"arXiv preprint arXiv:2004.14979","abstract":"We study the potential synergy between two different NLP tasks, both confronting lexical variability: identifying predicate paraphrases and event coreference resolution. First, we used annotations from an event coreference dataset as distant supervision to re-score heuristically-extracted predicate paraphrases. The new scoring gained more than 18 points in average precision upon their ranking by the original scoring method. Then, we used the same re-ranking features as additional inputs to a state-of-the-art event coreference resolution model, which yielded modest but consistent improvements to the model\'s performance. The results suggest a promising direction to leverage data and models for each of the tasks to the benefit of the other."},{"id":"50d0507519953ad00a0e1b09f6704372.html","title":"Automatically identifying gender issues in machine translation using perturbations","url":"https://arxiv.org/abs/2004.14065","authors":["Hila Gonen","Kellie Webster"],"date":"2020/04/29","journal":"arXiv preprint arXiv:2004.14065","abstract":"The successful application of neural methods to machine translation has realized huge quality advances for the community. With these improvements, many have noted outstanding challenges, including the modeling and treatment of gendered language. Where previous studies have identified concerns using manually-curated synthetic examples, we develop a novel technique to leverage real world data to explore challenges for deployed systems. We use our new method to compile an evaluation benchmark spanning examples relating to four languages from three language families, which we will publicly release to facilitate research. The examples in our benchmark expose the ways in which gender is represented in a model and the unintended consequences these gendered representations can have in downstream applications."},{"id":"2c98f7f8aa544de4350e63137bd25daa.html","title":"A Formal Hierarchy of RNN Architectures","url":"https://arxiv.org/abs/2004.08500","authors":["William Merrill","Gail Weiss","Yoav Goldberg","Roy Schwartz","Noah A Smith","Eran Yahav"],"date":"2020/04/18","journal":"arXiv preprint arXiv:2004.08500","abstract":"We develop a formal hierarchy of the expressive capacity of RNN architectures. The hierarchy is based on two formal properties: space complexity, which measures the RNN\'s memory, and rational recurrence, defined as whether the recurrent update can be described by a weighted finite-state machine. We place several RNN variants within this hierarchy. For example, we prove the LSTM is not rational, which formally separates it from the related QRNN (Bradbury et al., 2016). We also show how these models\' expressive capacity is expanded by stacking multiple layers or composing them with different pooling functions. Our results build on the theory of\\" saturated\\" RNNs (Merrill, 2019). While formally extending these findings to unsaturated RNNs is left to future work, we hypothesize that the practical learnable capacity of unsaturated RNNs obeys a similar hierarchy. Experimental findings from training unsaturated networks on formal languages support this conjecture."},{"id":"fadef3f241d93ffa3f43a829ed6e41dd.html","title":"Null It Out: Guarding Protected Attributes by Iterative Nullspace Projection","url":"https://arxiv.org/abs/2004.07667","authors":["Shauli Ravfogel","Yanai Elazar","Hila Gonen","Michael Twiton","Yoav Goldberg"],"date":"2020/04/16","journal":"arXiv preprint arXiv:2004.07667","abstract":"The ability to control for the kinds of information encoded in neural representation has a variety of use cases, especially in light of the challenge of interpreting these models. We present Iterative Null-space Projection (INLP), a novel method for removing information from neural representations. Our method is based on repeated training of linear classifiers that predict a certain property we aim to remove, followed by projection of the representations on their null-space. By doing so, the classifiers become oblivious to that target property, making it hard to linearly separate the data according to it. While applicable for general scenarios, we evaluate our method on bias and fairness use-cases, and show that our method is able to mitigate bias in word embeddings, as well as to increase fairness in a setting of multi-class classification."},{"id":"4e77a783843bb5b3bc66278713ebf353.html","title":"Towards Faithfully Interpretable NLP Systems: How should we define and evaluate faithfulness?","url":"https://arxiv.org/abs/2004.03685","authors":["Alon Jacovi","Yoav Goldberg"],"date":"2020/04/07","journal":"arXiv preprint arXiv:2004.03685","abstract":"With the growing popularity of deep-learning based NLP models, comes a need for interpretable systems. But what is interpretability, and what constitutes a high-quality interpretation? In this opinion piece we reflect on the current state of interpretability evaluation research. We call for more clearly differentiating between different desired criteria an interpretation should satisfy, and focus on the faithfulness criteria. We survey the literature with respect to faithfulness evaluation, and arrange the current approaches around three assumptions, providing an explicit form to how faithfulness is\\" defined\\" by the community. We provide concrete guidelines on how evaluation of interpretation methods should and should not be conducted. Finally, we claim that the current binary definition for faithfulness sets a potentially unrealistic bar for being considered faithful. We call for discarding the binary notion of faithfulness in favor of a more graded one, which we believe will be of greater practical utility."},{"id":"0bb9e8b4b855e9f78cee11d8cde41f16.html","title":"Evaluating nlp models via contrast sets","url":"https://arxiv.org/abs/2004.02709","authors":["Matt Gardner","Yoav Artzi","Victoria Basmova","Jonathan Berant","Ben Bogin","Sihao Chen","Pradeep Dasigi","Dheeru Dua","Yanai Elazar","Ananth Gottumukkala","Nitish Gupta","Hanna Hajishirzi","Gabriel Ilharco","Daniel Khashabi","Kevin Lin","Jiangming Liu","Nelson F Liu","Phoebe Mulcaire","Qiang Ning","Sameer Singh","Noah A Smith","Sanjay Subramanian","Reut Tsarfaty","Eric Wallace","Ally Zhang","Ben Zhou"],"date":"2020/04/06","journal":"arXiv preprint arXiv:2004.02709","abstract":"Standard test sets for supervised learning evaluate in-distribution generalization. Unfortunately, when a dataset has systematic gaps (eg, annotation artifacts), these evaluations are misleading: a model can learn simple decision rules that perform well on the test set but do not capture a dataset\'s intended capabilities. We propose a new annotation paradigm for NLP that helps to close systematic gaps in the test data. In particular, after a dataset is constructed, we recommend that the dataset authors manually perturb the test instances in small but meaningful ways that (typically) change the gold label, creating contrast sets. Contrast sets provide a local view of a model\'s decision boundary, which can be used to more accurately evaluate a model\'s true linguistic capabilities. We demonstrate the efficacy of contrast sets by creating them for 10 diverse NLP datasets (eg, DROP reading comprehension, UD parsing, IMDb sentiment analysis). Although our contrast sets are not explicitly adversarial, model performance is significantly lower on them than on the original test sets---up to 25\\\\\\\\% in some cases. We release our contrast sets as new evaluation benchmarks and encourage future dataset construction efforts to follow similar annotation processes."},{"id":"58d850863bebd8065e4845e69d73dde0.html","title":"Unsupervised Domain Clusters in Pretrained Language Models","url":"https://arxiv.org/abs/2004.02105","authors":["Roee Aharoni","Yoav Goldberg"],"date":"2020/04/05","journal":"arXiv preprint arXiv:2004.02105","abstract":"The notion of\\" in-domain data\\" in NLP is often over-simplistic and vague, as textual data varies in many nuanced linguistic aspects such as topic, style or level of formality. In addition, domain labels are many times unavailable, making it challenging to build domain-specific systems. We show that massive pre-trained language models implicitly learn sentence representations that cluster by domains without supervision--suggesting a simple data-driven definition of domains in textual data. We harness this property and propose domain data selection methods based on such models, which require only a small set of in-domain monolingual data. We evaluate our data selection methods for neural machine translation across five diverse domains, where they outperform an established approach as measured by both BLEU and by precision and recall of sentence selection with respect to an oracle."},{"id":"da0f74b9a22cffb207103c24ea3e52c4.html","title":"Ecological semantics: Programming environments for situated language understanding","url":"https://arxiv.org/abs/2003.04567","authors":["Ronen Tamari","Gabriel Stanovsky","Dafna Shahaf","Reut Tsarfaty"],"date":"2020/03/10","journal":"arXiv preprint arXiv:2003.04567","abstract":"Large-scale natural language understanding (NLU) systems have made impressive progress: they can be applied flexibly across a variety of tasks, and employ minimal structural assumptions. However, extensive empirical research has shown this to be a double-edged sword, coming at the cost of shallow understanding: inferior generalization, grounding and explainability. Grounded language learning approaches offer the promise of deeper understanding by situating learning in richer, more structured training environments, but are limited in scale to relatively narrow, predefined domains. How might we enjoy the best of both worlds: grounded, general NLU? Following extensive contemporary cognitive science, we propose treating environments as``first-class citizens\'\'in semantic representations, worthy of research and development in their own right. Importantly, models should also be partners in the creation and configuration of environments, rather than just actors within them, as in existing approaches. To do so, we argue that models must begin to understand and program in the language of affordances (which define possible actions in a given situation) both for online, situated discourse comprehension, as well as large-scale, offline common-sense knowledge mining. To this end we propose an environment-oriented ecological semantics, outlining theoretical and practical approaches towards implementation. We further provide actual demonstrations building upon interactive fiction programming languages."},{"id":"04b91de6664f1f296c8f05fa8f302f8d.html","title":"Break It Down: A Question Understanding Benchmark","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00309","authors":["Tomer Wolfson","Mor Geva","Ankit Gupta","Matt Gardner","Yoav Goldberg","Daniel Deutch","Jonathan Berant"],"date":"2020/01/31","journal":"arXiv preprint arXiv:2001.11770","abstract":"Understanding natural language questions entails the ability to break down a question into the requisite steps for computing its answer. In this work, we introduce a Question Decomposition Meaning Representation (QDMR) for questions. QDMR constitutes the ordered list of steps, expressed through natural language, that are necessary for answering a question. We develop a crowdsourcing pipeline, showing that quality QDMRs can be annotated at scale, and release the B<span class=\\"gs_fscp\\">reak</span> dataset, containing over 83K pairs of questions and their QDMRs. We demonstrate the utility of QDMR by showing that (a) it can be used to improve open-domain question answering on the H<span class=\\"gs_fscp\\">otpot</span>QA dataset, (b) it can be deterministically converted to a pseudo-SQL formal language, which can alleviate annotation in semantic parsing applications. Last, we use B<span class=\\"gs_fscp\\">reak</span> to train a sequence-to-sequence model with copying that parses questions\\\\xa0\u2026"},{"id":"43eee1744919b42a55fbe144aced91e1.html","title":"Football Coreference Corpus","url":"https://tudatalib.ulb.tu-darmstadt.de/handle/tudatalib/2305","authors":["Michael Bugert","Nils Reimers","Shany Barhom","Ido Dagan","Iryna Gurevych"],"date":"2020","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"8481db4744fb1cd07fab447138ae6500.html","title":"Breaking the Subtopic Barrier in Cross-Document Event Coreference Resolution.","url":"https://public.ukp.informatik.tu-darmstadt.de/UKP_Webpage/publications/2020/2020_Text2Story_MB_cross-doc-event-coref-corpus.pdf","authors":["Michael Bugert","Nils Reimers","Shany Barhom","Ido Dagan","Iryna Gurevych"],"date":"2020","abstract":"Cross-document event coreference resolution (CDCR) is the task of detecting and clustering mentions of events across a set of documents. A major bottleneck in CDCR is a lack of appropriate datasets, which stems from the difficulty of annotating data for this task. We present the first scalable approach for annotating cross-subtopic event coreference links, a highly valuable but rarely occurring type of cross-document link. The annotation of these links requires combing through hundreds of documents\u2013an endeavor for which conventional token-level annotation schemes with trained expert annotators are too expensive. We instead propose crowdsourcing annotation on sentence level to achieve scalability. We apply our approach to create the Football Coreference Corpus (FCC), a corpus of 451 sports news reports, while reaching high agreement between NLP experts and crowd annotators in the process. 1"},{"id":"c3c1bbc6432c3376ce1b6fc142dccf39.html","title":"Automatically Identifying Gender Bias in Machine Translation using Perturbations","url":"https://research.google/pubs/pub50758/","authors":["Kellie Webster","Hila Gonen"],"date":"2020","abstract":"Gender bias has been shown to affect many tasks applications in NLU. In the setting of machine translation (MT), research has primarily focused on measuring bias via synthetic datasets. We present an automatic method for identifying gender biases in MT using a novel-application of BERT-generated sentence perturbations. Using this method, we compile a dataset to serve as a benchmark for evaluating gender bias in MT across a diverse range of languages. Our dataset further serves to highlight the limitations of the current task definition which requires a single translation be produced, even in the presence of underspecified input."},{"id":"d828d94f31730df2d1897a07d61ad383.html","title":"oLMpics--On what Language Model Pre-training Captures","url":"https://arxiv.org/abs/1912.13283","authors":["Alon Talmor","Yanai Elazar","Yoav Goldberg","Jonathan Berant"],"date":"2019/12/31","journal":"arXiv preprint arXiv:1912.13283","abstract":"Recent success of pre-trained language models (LMs) has spurred widespread interest in the language capabilities that they possess. However, efforts to understand whether LM representations are useful for symbolic reasoning tasks have been limited and scattered. In this work, we propose eight reasoning tasks, which conceptually require operations such as comparison, conjunction, and composition. A fundamental challenge is to understand whether the performance of a LM on a task should be attributed to the pre-trained representations or to the process of fine-tuning on the task data. To address this, we propose an evaluation protocol that includes both zero-shot evaluation (no fine-tuning), as well as comparing the learning curve of a fine-tuned LM to the learning curve of multiple controls, which paints a rich picture of the LM capabilities. Our main findings are that:(a) different LMs exhibit qualitatively different reasoning abilities, eg, RoBERTa succeeds in reasoning tasks where BERT fails completely;(b) LMs do not reason in an abstract manner and are context-dependent, eg, while RoBERTa can compare ages, it can do so only when the ages are in the typical range of human ages;(c) On half of our reasoning tasks all models fail completely. Our findings and infrastructure can help future work on designing new datasets, models and objective functions for pre-training."},{"id":"4da6c6af35892e52ef86367f268c3152.html","title":"A \u2018wind of change\u2019\u2014shaping public opinion of the Arab Spring using metaphors","url":"https://academic.oup.com/dsh/article-abstract/34/Supplement_1/i142/5151186","authors":["Alexandra N\\\\xfa\\\\xf1ez","Malte Gerloff","Erik-L\\\\xe2n Do Dinh","Andrea Rapp","Petra Gehring","Iryna Gurevych"],"date":"2019/12/01","journal":"Digital Scholarship in the Humanities","abstract":"Newspapers create publicity, draw attention to topics, and try to gain thematic acceptance from the reader. To achieve this, they use linguistic strategies and select culturally and historically evolved encyclopedic knowledge sources. In our pilot study we explore the presentation of the events in the Middle East\u2013North African region between December 2010 and November 2011 that were soon metaphorically framed as the Arab Spring. To this end, we use a text corpus consisting of 300 opinion pieces from five national German newspapers. To get access to the conceptual knowledge structure and the linguistic strategies, we combine text mining methods and cognitive linguistics. We focus on conceptual metaphors (Lakoff and Johnson, ) and their binary source\u2013target structure, where the source domain reveals the underlying conceptual knowledge structures of the speaker. This research focus is justified by the\\\\xa0\u2026"},{"id":"6a045d0c1a0eae7c992683b5a08f3264.html","title":"Crowdsourcing a High-Quality Gold Standard for QA-SRL","url":"https://arxiv.org/abs/1911.03243","authors":["Paul Roit","Ayal Klein","Daniela Stepanov","Jonathan Mamou","Julian Michael","Gabriel Stanovsky","Luke Zettlemoyer","Ido Dagan"],"date":"2019/11/08","journal":"arXiv preprint arXiv:1911.03243","abstract":"Question-answer driven Semantic Role Labeling (QA-SRL) has been proposed as an attractive open and natural form of SRL, easily crowdsourceable for new corpora. Recently, a large-scale QA-SRL corpus and a trained parser were released, accompanied by a densely annotated dataset for evaluation. Trying to replicate the QA-SRL annotation and evaluation scheme for new texts, we observed that the resulting annotations were lacking in quality and coverage, particularly insufficient for creating gold standards for evaluation. In this paper, we present an improved QA-SRL annotation protocol, involving crowd-worker selection and training, followed by data consolidation. Applying this process, we release a new gold evaluation dataset for QA-SRL, yielding more consistent annotations and greater coverage. We believe that our new annotation protocol and gold standard will facilitate future replicable research of natural semantic annotations."},{"id":"784e78a0d59c9e671d19aec600f2ee31.html","title":"Adversarial removal of demographic attributes revisited","url":"https://www.aclweb.org/anthology/D19-1662/","authors":["Maria Barrett","Yova Kementchedjhieva","Yanai Elazar","Desmond Elliott","Anders S\\\\xf8gaard"],"date":"2019/11","abstract":"Elazar and Goldberg (2018) showed that protected attributes can be extracted from the representations of a debiased neural network for mention detection at above-chance levels, by evaluating a diagnostic classifier on a held-out subsample of the data it was trained on. We revisit their experiments and conduct a series of follow-up experiments showing that, in fact, the diagnostic classifier generalizes poorly to both new in-domain samples and new domains, indicating that it relies on correlations specific to their particular data sample. We further show that a diagnostic classifier trained on the biased baseline neural network also does not generalize to new samples. In other words, the biases detected in Elazar and Goldberg (2018) seem restricted to their particular data sample, and would therefore not bias the decisions of the model on new samples, whether in-domain or out-of-domain. In light of this, we discuss better methodologies for detecting bias in our models."},{"id":"263037f69d75071945e89d9b52f82b10.html","title":"How does Grammatical Gender Affect Noun Representations in Gender-Marking Languages?","url":"https://arxiv.org/abs/1910.14161","authors":["Hila Gonen","Yova Kementchedjhieva","Yoav Goldberg"],"date":"2019/10/30","journal":"arXiv preprint arXiv:1910.14161","abstract":"Many natural languages assign grammatical gender also to inanimate nouns in the language. In such languages, words that relate to the gender-marked nouns are inflected to agree with the noun\'s gender. We show that this affects the word representations of inanimate nouns, resulting in nouns with the same gender being closer to each other than nouns with different gender. While\\" embedding debiasing\\" methods fail to remove the effect, we demonstrate that a careful application of methods that neutralize grammatical gender signals from the words\' context when training word embeddings is effective in removing it. Fixing the grammatical gender bias yields a positive effect on the quality of the resulting word embeddings, both in monolingual and cross-lingual settings. We note that successfully removing gender signals, while achievable, is not trivial to do and that a language-specific morphological analyzer, together with careful usage of it, are essential for achieving good results."},{"id":"fb5f4fa95da6b8f18626f152b1fc4f9c.html","title":"Scalable Evaluation and Improvement of Document Set Expansion via Neural Positive-Unlabeled Learning","url":"https://arxiv.org/abs/1910.13339","authors":["Alon Jacovi","Gang Niu","Yoav Goldberg","Masashi Sugiyama"],"date":"2019/10/29","journal":"arXiv preprint arXiv:1910.13339","abstract":"We consider the situation in which a user has collected a small set of documents on a cohesive topic, and they want to retrieve additional documents on this topic from a large collection. Information Retrieval (IR) solutions treat the document set as a query, and look for similar documents in the collection. We propose to extend the IR approach by treating the problem as an instance of positive-unlabeled (PU) learning---ie, learning binary classifiers from only positive and unlabeled data, where the positive data corresponds to the query documents, and the unlabeled data is the results returned by the IR engine. Utilizing PU learning for text with big neural networks is a largely unexplored field. We discuss various challenges in applying PU learning to the setting, including an unknown class prior, extremely imbalanced data and large-scale accurate evaluation of models, and we propose solutions and empirically validate them. We demonstrate the effectiveness of the method using a series of experiments of retrieving PubMed abstracts adhering to fine-grained topics. We demonstrate improvements over the base IR solution and other baselines. Implementation is available at this https URL."},{"id":"03f9cb53e42324e6874234c6b69cbe8d.html","title":"Diversify your datasets: Analyzing generalization via controlled variance in adversarial datasets","url":"https://arxiv.org/abs/1910.09302","authors":["Ohad Rozen","Vered Shwartz","Roee Aharoni","Ido Dagan"],"date":"2019/10/21","journal":"arXiv preprint arXiv:1910.09302","abstract":"Phenomenon-specific\\" adversarial\\" datasets have been recently designed to perform targeted stress-tests for particular inference types. Recent work (Liu et al., 2019a) proposed that such datasets can be utilized for training NLI and other types of models, often allowing to learn the phenomenon in focus and improve on the challenge dataset, indicating a\\" blind spot\\" in the original training data. Yet, although a model can improve in such a training process, it might still be vulnerable to other challenge datasets targeting the same phenomenon but drawn from a different distribution, such as having a different syntactic complexity level. In this work, we extend this method to drive conclusions about a model\'s ability to learn and generalize a target phenomenon rather than to\\" learn\\" a dataset, by controlling additional aspects in the adversarial datasets. We demonstrate our approach on two inference phenomena-dative alternation and numerical reasoning, elaborating, and in some cases contradicting, the results of Liu et al.. Our methodology enables building better challenge datasets for creating more robust models, and may yield better model understanding and subsequent overarching improvements."},{"id":"64c5c06ccc0e49fd24c945545e4c96a2.html","title":"At Your Fingertips: Automatic Piano Fingering Detection","url":"https://openreview.net/forum?id=H1MOqeHYvB","authors":["Amit Moryossef","Yanai Elazar","Yoav Goldberg"],"date":"2019/09/25","abstract":"Automatic Piano Fingering is a hard task which computers can learn using data. As data collection is hard and expensive, we propose to automate this process by automatically extracting fingerings from public videos and MIDI files, using computer-vision techniques. Running this process on 90 videos results in the largest dataset for piano fingering with more than 150K notes. We show that when running a previously proposed model for automatic piano fingering on our dataset and then fine-tuning it on manually labeled piano fingering data, we achieve state-of-the-art results. In addition to the fingering extraction method, we also introduce a novel method for transferring deep-learning computer-vision models to work on out-of-domain data, by fine-tuning it on out-of-domain augmentation proposed by a Generative Adversarial Network (GAN). For demonstration, we anonymously release a visualization of the output of our process for a single video on https://youtu. be/Gfs1UWQhr5Q"},{"id":"a3392624bc8c74db00cd94100720ff31.html","title":"A Simple Geometric Proof for the Benefit of Depth in ReLU Networks","url":"https://arxiv.org/abs/2101.07126","authors":["Asaf Amrami","Yoav Goldberg"],"date":"2019/09/25","abstract":"<g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 6.18800)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 158 35 Q 158 47 160 53 L 313 664 Q 328 721 328 764 Q 328 852 268 852 Q 204 852 173 775 T 113 582 Q 113 576 107 572 T 96 569 H 72 Q 65 569 60 576 T 55 590 Q 77 679 97 741 T 161 854 T 270 905 Q 347 905 406 856 T 465 733 Q 526 813 608 859 T 782 905 Q 879 905 949 855 T 1020 715 Q 1083 804 1167 854 T 1352 905 Q 1458 905 1522 847 T 1587 684 Q 1587 600 1549 481 T 1456 215 Q 1427 144 1427 92 Q 1427 31 1475 31 Q 1555 31 1608 117 T 1683 301 Q 1689 313 1700 313 H 1724 Q 1732 313 1737 307 T 1743 295 Q 1743 293 1741 289 Q 1713 173 1643 75 T 1470 -23 Q 1398 -23 1347 26 T 1296 147 Q 1296 183 1313 227 Q 1371 381 1409 502 T 1448 715 Q 1448 772 1425 812 T 1348 852 Q 1236 852 1154 783 T 1012 602 Q 1008 582 1006 571 L 874 45 Q 867 17 842 -3 T 788 -23 Q 764 -23 745 -7 T 727 35 Q 727 47 729 53 L 860 575 Q 881 659 881 715 Q 881 772 857 812 T 778 852 Q 703 852 640 819 T 530 731 T 444 602 L 305 45 Q 298 17 273 -3 T 219 -23 Q 194 -23 176 -7 T 158 35 Z \\"></path></g></svg> such that (a) for any fixed depth rectified network there exist an <svg class=\\"gs_fsvg\\" aria-label=\\"m\\" width=\\"12px\\" height=\\"6px\\" style=\\"vertical-align:0px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 6.18800)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 158 35 Q 158 47 160 53 L 313 664 Q 328 721 328 764 Q 328 852 268 852 Q 204 852 173 775 T 113 582 Q 113 576 107 572 T 96 569 H 72 Q 65 569 60 576 T 55 590 Q 77 679 97 741 T 161 854 T 270 905 Q 347 905 406 856 T 465 733 Q 526 813 608 859 T 782 905 Q 879 905 949 855 T 1020 715 Q 1083 804 1167 854 T 1352 905 Q 1458 905 1522 847 T 1587 684 Q 1587 600 1549 481 T 1456 215 Q 1427 144 1427 92 Q 1427 31 1475 31 Q 1555 31 1608 117 T 1683 301 Q 1689 313 1700 313 H 1724 Q 1732 313 1737 307 T 1743 295 Q 1743 293 1741 289 Q 1713 173 1643 75 T 1470 -23 Q 1398 -23 1347 26 T 1296 147 Q 1296 183 1313 227 Q 1371 381 1409 502 T 1448 715 Q 1448 772 1425 812 T 1348 852 Q 1236 852 1154 783 T 1012 602 Q 1008 582 1006 571 L 874 45 Q 867 17 842 -3 T 788 -23 Q 764 -23 745 -7 T 727 35 Q 727 47 729 53 L 860 575 Q 881 659 881 715 Q 881 772 857 812 T 778 852 Q 703 852 640 819 T 530 731 T 444 602 L 305 45 Q 298 17 273 -3 T 219 -23 Q 194 -23 176 -7 T 158 35 Z \\"></path></g></svg> above which classifying problem <svg class=\\"gs_fsvg\\" aria-label=\\"m\\" width=\\"12px\\" height=\\"6px\\" style=\\"vertical-align:0px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 6.18800)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 158 35 Q 158 47 160 53 L 313 664 Q 328 721 328 764 Q 328 852 268 852 Q 204 852 173 775 T 113 582 Q 113 576 107 572 T 96 569 H 72 Q 65 569 60 576 T 55 590 Q 77 679 97 741 T 161 854 T 270 905 Q 347 905 406 856 T 465 733 Q 526 813 608 859 T 782 905 Q 879 905 949 855 T 1020 715 Q 1083 804 1167 854 T 1352 905 Q 1458 905 1522 847 T 1587 684 Q 1587 600 1549 481 T 1456 215 Q 1427 144 1427 92 Q 1427 31 1475 31 Q 1555 31 1608 117 T 1683 301 Q 1689 313 1700 313 H 1724 Q 1732 313 1737 307 T 1743 295 Q 1743 293 1741 289 Q 1713 173 1643 75 T 1470 -23 Q 1398 -23 1347 26 T 1296 147 Q 1296 183 1313 227 Q 1371 381 1409 502 T 1448 715 Q 1448 772 1425 812 T 1348 852 Q 1236 852 1154 783 T 1012 602 Q 1008 582 1006 571 L 874 45 Q 867 17 842 -3 T 788 -23 Q 764 -23 745 -7 T 727 35 Q 727 47 729 53 L 860 575 Q 881 659 881 715 Q 881 772 857 812 T 778 852 Q 703 852 640 819 T 530 731 T 444 602 L 305 45 Q 298 17 273 -3 T 219 -23 Q 194 -23 176 -7 T 158 35 Z \\"></path></g></svg> correctly requires exponential number of parameters (in <svg class=\\"gs_fsvg\\" aria-label=\\"m\\" width=\\"12px\\" height=\\"6px\\" style=\\"vertical-align:0px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 6.18800)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 158 35 Q 158 47 160 53 L 313 664 Q 328 721 328 764 Q 328 852 268 852 Q 204 852 173 775 T 113 582 Q 113 576 107 572 T 96 569 H 72 Q 65 569 60 576 T 55 590 Q 77 679 97 741 T 161 854 T 270 905 Q 347 905 406 856 T 465 733 Q 526 813 608 859 T 782 905 Q 879 905 949 855 T 1020 715 Q 1083 804 1167 854 T 1352 905 Q 1458 905 1522 847 T 1587 684 Q 1587 600 1549 481 T 1456 215 Q 1427 144 1427 92 Q 1427 31 1475 31 Q 1555 31 1608 117 T 1683 301 Q 1689 313 1700 313 H 1724 Q 1732 313 1737 307 T 1743 295 Q 1743 293 1741 289 Q 1713 173 1643 75 T 1470 -23 Q 1398 -23 1347 26 T 1296 147 Q 1296 183 1313 227 Q 1371 381 1409 502 T 1448 715 Q 1448 772 1425 812 T 1348 852 Q 1236 852 1154 783 T 1012 602 Q 1008 582 1006 571 L 874 45 Q 867 17 842 -3 T 788 -23 Q 764 -23 745 -7 T 727 35 Q 727 47 729 53 L 860 575 Q 881 659 881 715 Q 881 772 857 812 T 778 852 Q 703 852 640 819 T 530 731 T 444 602 L 305 45 Q 298 17 273 -3 T 219 -23 Q 194 -23 176 -7 T 158 35 Z \\"></path></g></svg>); and (b) for any problem in the sequence, we present a concrete neural network with linear depth (in <svg class=\\"gs_fsvg\\" aria-label=\\"m\\" width=\\"12px\\" height=\\"6px\\" style=\\"vertical-align:0px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 6.18800)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 158 35 Q 158 47 160 53 L 313 664 Q 328 721 328 764 Q 328 852 268 852 Q 204 852 173 775 T 113 582 Q 113 576 107 572 T 96 569 H 72 Q 65 569 60 576 T 55 590 Q 77 679 97 741 T 161 854 T 270 905 Q 347 905 406 856 T 465 733 Q 526 813 608 859 T 782 905 Q 879 905 949 855 T 1020 715 Q 1083 804 1167 854 T 1352 905 Q 1458 905 1522 847 T 1587 684 Q 1587 600 1549 481 T 1456 215 Q 1427 144 1427 92 Q 1427 31 1475 31 Q 1555 31 1608 117 T 1683 301 Q 1689 313 1700 313 H 1724 Q 1732 313 1737 307 T 1743 295 Q 1743 293 1741 289 Q 1713 173 1643 75 T 1470 -23 Q 1398 -23 1347 26 T 1296 147 Q 1296 183 1313 227 Q 1371 381 1409 502 T 1448 715 Q 1448 772 1425 812 T 1348 852 Q 1236 852 1154 783 T 1012 602 Q 1008 582 1006 571 L 874 45 Q 867 17 842 -3 T 788 -23 Q 764 -23 745 -7 T 727 35 Q 727 47 729 53 L 860 575 Q 881 659 881 715 Q 881 772 857 812 T 778 852 Q 703 852 640 819 T 530 731 T 444 602 L 305 45 Q 298 17 273 -3 T 219 -23 Q 194 -23 176 -7 T 158 35 Z \\"></path></g></svg>) and small constant width (<svg class=\\"gs_fsvg\\" aria-label=\\"\\\\\\\\leq 4\\" width=\\"22px\\" height=\\"11px\\" style=\\"vertical-align:-2px;\\"><g transform=\\"matrix(0.01400, 0.00000, 0.00000, 0.01400, 0.00000, 9.32400)\\"><path transform=\\"scale(0.48828, -0.48828)\\" d=\\"M 209 -281 Q 192 -281 181 -268 T 170 -240 Q 170 -223 181 -211 T 209 -199 H 1384 Q 1400 -199 1410 -211 T 1421 -240 Q 1421 -255 1410 -268 T 1384 -281 H 209 Z M 190 676 Q 170 682 170 711 Q 170 737 197 748 L 1366 1300 Q 1370 1303 1380 1303 Q 1397 1303 1409 1291 T 1421 1262 Q 1421 1235 1397 1225 L 307 711 L 1403 193 Q 1421 183 1421 158 Q 1421 140 1409 128 T 1380 117 Q 1370 117 1366 121 L 190 676 Z \\"></path><path transform=\\"matrix(0.48828, 0.00000, 0.00000, -0.48828, 1055.55859, 0.00000)\\" d=\\"M 57 338 V 410 L 690 1354 Q 697 1364 711 1364 H 741 Q 764 1364 764 1341 V 410 H 965 V 338 H 764 V 137 Q 764 95 824 83 T 963 72 V 0 H 399 V 72 Q 478 72 538 83 T 598 137 V 338 H 57 Z M 125 410 H 610 V 1135 L 125 410 Z \\"></path></g></svg>) that classifies the problem with zero error. The constructive proof is based on geometric arguments and a space folding construction. While stronger bounds and results exist, our proof uses substantially simpler tools and techniques, and should be accessible to undergraduate students in computer science and people with similar backgrounds."},{"id":"896651d38fd730ffe6d0414f27c6941f.html","title":"Improving Quality and Efficiency in Plan-based Neural Data-to-Text Generation","url":"https://arxiv.org/abs/1909.09986","authors":["Amit Moryossef","Ido Dagan","Yoav Goldberg"],"date":"2019/09/22","journal":"arXiv preprint arXiv:1909.09986","abstract":"We follow the step-by-step approach to neural data-to-text generation we proposed in Moryossef et al (2019), in which the generation process is divided into a text-planning stage followed by a plan-realization stage. We suggest four extensions to that framework:(1) we introduce a trainable neural planning component that can generate effective plans several orders of magnitude faster than the original planner;(2) we incorporate typing hints that improve the model\'s ability to deal with unseen relations and entities;(3) we introduce a verification-by-reranking stage that substantially improves the faithfulness of the resulting texts;(4) we incorporate a simple but effective referring expression generation module. These extensions result in a generation process that is faster, more fluent, and more accurate."},{"id":"4ef4be07b008dea6b3fc7d7cb6ae7e9f.html","title":"RUN through the Streets: A New Dataset and Baseline Models for Realistic Urban Navigation","url":"https://arxiv.org/abs/1909.08970","authors":["Tzuf Paz-Argaman","Reut Tsarfaty"],"date":"2019/09/19","journal":"arXiv preprint arXiv:1909.08970","abstract":"Following navigation instructions in natural language requires a composition of language, action, and knowledge of the environment. Knowledge of the environment may be provided via visual sensors or as a symbolic world representation referred to as a map. Here we introduce the Realistic Urban Navigation (RUN) task, aimed at interpreting navigation instructions based on a real, dense, urban map. Using Amazon Mechanical Turk, we collected a dataset of 2515 instructions aligned with actual routes over three regions of Manhattan. We propose a strong baseline for the task and empirically investigate which aspects of the neural architecture are important for the RUN success. Our results empirically show that entity abstraction, attention over words and worlds, and a constantly updating world-state, significantly contribute to task accuracy."},{"id":"bf21b5720767961287bb8b67ad3301ee.html","title":"ABSApp: A Portable Weakly-Supervised Aspect-Based Sentiment Extraction System","url":"https://arxiv.org/abs/1909.05608","authors":["Oren Pereg","Daniel Korat","Moshe Wasserblat","Jonathan Mamou","Ido Dagan"],"date":"2019/09/12","journal":"arXiv preprint arXiv:1909.05608","abstract":"We present ABSApp, a portable system for weakly-supervised aspect-based sentiment extraction. The system is interpretable and user friendly and does not require labeled training data, hence can be rapidly and cost-effectively used across different domains in applied setups. The system flow includes three stages: First, it generates domain-specific aspect and opinion lexicons based on an unlabeled dataset; second, it enables the user to view and edit those lexicons (weak supervision); and finally, it enables the user to select an unlabeled target dataset from the same domain, classify it, and generate an aspect-based sentiment report. ABSApp has been successfully used in a number of real-life use cases, among them movie review analysis and convention impact analysis."},{"id":"4b4181671ce83398a7f55a4680e0b73d.html","title":"Better rewards yield better summaries: Learning to summarise without references","url":"https://arxiv.org/abs/1909.01214","authors":["Florian B\\\\xf6hm","Yang Gao","Christian M Meyer","Ori Shapira","Ido Dagan","Iryna Gurevych"],"date":"2019/09/03","journal":"arXiv preprint arXiv:1909.01214","abstract":"Reinforcement Learning (RL) based document summarisation systems yield state-of-the-art performance in terms of ROUGE scores, because they directly use ROUGE as the rewards during training. However, summaries with high ROUGE scores often receive low human judgement. To find a better reward function that can guide RL to generate human-appealing summaries, we learn a reward function from human ratings on 2,500 summaries. Our reward function only takes the document and system summary as input. Hence, once trained, it can be used to train RL-based summarisation systems without using any reference summaries. We show that our learned rewards have significantly higher correlation with human ratings than previous approaches. Human evaluation experiments show that, compared to the state-of-the-art supervised-learning systems and ROUGE-as-rewards RL summarisation systems, the RL systems using our learned rewards during training generate summarieswith higher human ratings. The learned reward function and our source code are available at this https URL."},{"id":"0f67078a7fa90dab89060b3f9a142e1a.html","title":"It\'s All in the Name: Mitigating Gender Bias with Name-Based Counterfactual Data Substitution","url":"https://arxiv.org/abs/1909.00871","authors":["Rowan Hall Maudslay","Hila Gonen","Ryan Cotterell","Simone Teufel"],"date":"2019/09/02","journal":"arXiv preprint arXiv:1909.00871","abstract":"This paper treats gender bias latent in word embeddings. Previous mitigation attempts rely on the operationalisation of gender bias as a projection over a linear subspace. An alternative approach is Counterfactual Data Augmentation (CDA), in which a corpus is duplicated and augmented to remove bias, eg by swapping all inherently-gendered words in the copy. We perform an empirical comparison of these approaches on the English Gigaword and Wikipedia, and find that whilst both successfully reduce direct bias and perform well in tasks which quantify embedding quality, CDA variants outperform projection-based methods at the task of drawing non-biased gender analogies by an average of 19% across both corpora. We propose two improvements to CDA: Counterfactual Data Substitution (CDS), a variant of CDA in which potentially biased text is randomly substituted to avoid duplication, and the Names Intervention, a novel name-pairing technique that vastly increases the number of words being treated. CDA/S with the Names Intervention is the only approach which is able to mitigate indirect gender bias: following debiasing, previously biased words are significantly less clustered according to gender (cluster purity is reduced by 49%), thus improving on the state-of-the-art for bias mitigation."},{"id":"b386ece2b32d5beeed6398418315c4aa.html","title":"Transfer Learning Between Related Tasks Using Expected Label Proportions","url":"https://arxiv.org/abs/1909.00430","authors":["Matan Ben Noach","Yoav Goldberg"],"date":"2019/09/01","journal":"arXiv preprint arXiv:1909.00430","abstract":"Deep learning systems thrive on abundance of labeled training data but such data is not always available, calling for alternative methods of supervision. One such method is expectation regularization (XR)(Mann and McCallum, 2007), where models are trained based on expected label proportions. We propose a novel application of the XR framework for transfer learning between related tasks, where knowing the labels of task A provides an estimation of the label proportion of task B. We then use a model trained for A to label a large corpus, and use this corpus with an XR loss to train a model for task B. To make the XR framework applicable to large-scale deep-learning setups, we propose a stochastic batched approximation procedure. We demonstrate the approach on the task of Aspect-based Sentiment classification, where we effectively use a sentence-level sentiment predictor to train accurate aspect-based predictor. The method improves upon fully supervised neural system trained on aspect-level data, and is also cumulative with LM-based pretraining, as we demonstrate by improving a BERT-based Aspect-based Sentiment model."},{"id":"4fd6c8ebae72a77724f222df08702d3e.html","title":"Where\u2019s My Head? Definition, Data Set, and Models for Numeric Fused-Head Identification and Resolution","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00280","authors":["Yanai Elazar","Yoav Goldberg"],"date":"2019/09","journal":"Transactions of the Association for Computational Linguistics","abstract":"We provide the first computational treatment of fused-heads constructions (FHs), focusing on the numeric fused-heads (NFHs). FHs constructions are noun phrases in which the head noun is missing and is said to be \u201cfused\u201d with its dependent modifier. This missing information is implicit and is important for sentence understanding. The missing references are easily filled in by humans but pose a challenge for computational models. We formulate the handling of FHs as a two stages process: <b>Identification</b> of the FH construction and <b>resolution</b> of the missing head. We explore the NFH phenomena in large corpora of English text and create (1) a data set and a highly accurate method for NFH identification; (2) a 10k examples (1 M tokens) crowd-sourced data set of NFH resolution; and (3) a neural baseline for the NFH resolution task. We release our code and data set, to foster further research into this challenging problem."},{"id":"d68114a3942accb301199ffb621d81f7.html","title":"Are we modeling the task or the annotator? an investigation of annotator bias in natural language understanding datasets","url":"https://arxiv.org/abs/1908.07898","authors":["Mor Geva","Yoav Goldberg","Jonathan Berant"],"date":"2019/08/21","journal":"arXiv preprint arXiv:1908.07898","abstract":"Crowdsourcing has been the prevalent paradigm for creating natural language understanding datasets in recent years. A common crowdsourcing practice is to recruit a small number of high-quality workers, and have them massively generate examples. Having only a few workers generate the majority of examples raises concerns about data diversity, especially when workers freely generate sentences. In this paper, we perform a series of experiments showing these concerns are evident in three recent NLP datasets. We show that model performance improves when training with annotator identifiers as features, and that models are able to recognize the most productive annotators. Moreover, we show that often models do not generalize well to examples from annotators that did not contribute to the training set. Our findings suggest that annotator bias should be monitored during dataset creation, and that test set annotators should be disjoint from training set annotators."},{"id":"0d9e0c3a4009ad25415a00aaf86c9bc3.html","title":"What\'s Wrong with Hebrew NLP? And How to Make it Right","url":"https://arxiv.org/abs/1908.05453","authors":["Reut Tsarfaty","Amit Seker","Shoval Sadde","Stav Klein"],"date":"2019/08/15","journal":"arXiv preprint arXiv:1908.05453","abstract":"For languages with simple morphology, such as English, automatic annotation pipelines such as spaCy or Stanford\'s CoreNLP successfully serve projects in academia and the industry. For many morphologically-rich languages (MRLs), similar pipelines show sub-optimal performance that limits their applicability for text analysis in research and the industry. The sub-optimal performance is mainly due to errors in early morphological disambiguation decisions, which cannot be recovered later in the pipeline, yielding incoherent annotations on the whole. In this paper we describe the design and use of the Onlp suite, a joint morpho-syntactic parsing framework for processing Modern Hebrew texts. The joint inference over morphology and syntax substantially limits error propagation, and leads to high accuracy. Onlp provides rich and expressive output which already serves diverse academic and commercial needs. Its accompanying online demo further serves educational activities, introducing Hebrew NLP intricacies to researchers and non-researchers alike."},{"id":"c858c3fddfb64f2188393d19833f6a7f.html","title":"Ab Antiquo: Proto-language Reconstruction with RNNs","url":"https://arxiv.org/abs/1908.02477","authors":["Carlo Meloni","Shauli Ravfogel","Yoav Goldberg"],"date":"2019/08/07","journal":"arXiv preprint arXiv:1908.02477","abstract":"Historical linguists have identified regularities in the process of historic sound change. The comparative method utilizes those regularities to reconstruct proto-words based on observed forms in daughter languages. Can this process be efficiently automated? We address the task of proto-word reconstruction, in which the model is exposed to cognates in contemporary daughter languages, and has to predict the proto word in the ancestor language. We provide a novel dataset for this task, encompassing over 8,000 comparative entries, and show that neural sequence models outperform conventional methods applied to this task so far. Error analysis reveals a variability in the ability of neural model to capture different phonological changes, correlating with the complexity of the changes. Analysis of learned embeddings reveals the models learn phonologically meaningful generalizations, corresponding to well-attested phonological shifts documented by historical linguistics."},{"id":"f200125df0d5a46f2f1c3d7c0e96a5fa.html","title":"What does BERT learn about the structure of language?","url":"https://hal.inria.fr/hal-02131630/","authors":["Ganesh Jawahar","Beno\\\\xeet Sagot","Djam\\\\xe9 Seddah"],"date":"2019/07/28","abstract":""},{"id":"84a65845f14b2a202ff72265c59174ce.html","title":"Ranking generated summaries by correctness: An interesting but challenging application for natural language inference","url":"https://www.aclweb.org/anthology/P19-1213.pdf","authors":["Tobias Falke","Leonardo FR Ribeiro","Prasetya Ajie Utama","Ido Dagan","Iryna Gurevych"],"date":"2019/07","abstract":"While recent progress on abstractive summarization has led to remarkably fluent summaries, factual errors in generated summaries still severely limit their use in practice. In this paper, we evaluate summaries produced by state-of-the-art models via crowdsourcing and show that such errors occur frequently, in particular with more abstractive models. We study whether textual entailment predictions can be used to detect such errors and if they can be reduced by reranking alternative predicted summaries. That leads to an interesting downstream application for entailment models. In our experiments, we find that out-of-the-box entailment models trained on NLI datasets do not yet offer the desired performance for the downstream task and we therefore release our annotations as additional test data for future extrinsic evaluations of NLI."},{"id":"d34aabfcb9890451cda4c042b75065d6.html","title":"Still a pain in the neck: Evaluating text representations on lexical composition","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00277","authors":["Vered Shwartz","Ido Dagan"],"date":"2019/07","journal":"Transactions of the Association for Computational Linguistics","abstract":"Building meaningful phrase representations is challenging because phrase meanings are not simply the sum of their constituent meanings. Lexical composition can shift the meanings of the constituent words and introduce implicit information. We tested a broad range of textual representations for their capacity to address these issues. We found that, as expected, contextualized word representations perform better than static word embeddings, more so on detecting meaning shift than in recovering implicit information, in which their performance is still far from that of humans. Our evaluation suite, consisting of six tasks related to lexical composition effects, can serve future research aiming to improve representations."},{"id":"4573b1bb55f722c509ebdddd68f84e83.html","title":"The Third Workshop on Evaluating Vector Space Representations for NLP","url":"http://scholar.google.com/scholar?cluster=1412601863258781221&hl=en&oi=scholarr","authors":["Anna Rogers","Aleksandr Drozd","Anna Rumshisky","Yoav Goldberg"],"date":"2019/06/6"},{"id":"226911a28e76772b06c8dee5272f0e4c.html","title":"Correctness of Generated Summaries","url":"https://tudatalib.ulb.tu-darmstadt.de/bitstream/handle/tudatalib/2002/summary-correctness-v1.0.zip?sequence=3","authors":["Tobias Falke","Leonardo Ribeiro","Prasetya Utama","Ido Dagan","Iryna Gurevych"],"date":"2019/06/04","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"41d697ece5f80944681d464b0ec384ff.html","title":"How large are lions? inducing distributions over quantitative attributes","url":"https://arxiv.org/abs/1906.01327","authors":["Yanai Elazar","Abhijit Mahabal","Deepak Ramachandran","Tania Bedrax-Weiss","Dan Roth"],"date":"2019/06/04","journal":"arXiv preprint arXiv:1906.01327","abstract":""},{"id":"ee7286d8aa413f845f44a085df34a041.html","title":"Revisiting joint modeling of cross-document entity and event coreference resolution","url":"https://arxiv.org/abs/1906.01753","authors":["Shany Barhom","Vered Shwartz","Alon Eirew","Michael Bugert","Nils Reimers","Ido Dagan"],"date":"2019/06/04","journal":"arXiv preprint arXiv:1906.01753","abstract":"Recognizing coreferring events and entities across multiple texts is crucial for many NLP applications. Despite the task\'s importance, research focus was given mostly to within-document entity coreference, with rather little attention to the other variants. We propose a neural architecture for cross-document coreference resolution. Inspired by Lee et al (2012), we jointly model entity and event coreference. We represent an event (entity) mention using its lexical span, surrounding context, and relation to entity (event) mentions via predicate-arguments structures. Our model outperforms the previous state-of-the-art event coreference model on ECB+, while providing the first entity coreference results on this corpus. Our analysis confirms that all our representation elements, including the mention span itself, its context, and the relation to other mentions contribute to the model\'s success."},{"id":"14e6329bb8df6dae4c048e8bf218008c.html","title":"How to Compare Summarizers without Target Length? Pitfalls, Solutions and Re-Examination of the Neural Summarization Literature","url":"https://www.aclweb.org/anthology/W19-2303.pdf","authors":["Simeng Sun","Ori Shapira","Ido Dagan","Ani Nenkova"],"date":"2019/06","abstract":"We show that plain ROUGE F1 scores are not ideal for comparing current neural systems which on average produce different lengths. This is due to a non-linear pattern between ROUGE F1 and summary length. To alleviate the effect of length during evaluation, we have proposed a new method which normalizes the ROUGE F1 scores of a system by that of a random system with same average output length. A pilot human evaluation has shown that humans prefer short summaries in terms of the verbosity of a summary but overall consider longer summaries to be of higher quality. While human evaluations are more expensive in time and resources, it is clear that normalization, such as the one we proposed for automatic evaluation, will make human evaluations more meaningful."},{"id":"f48990b837664226748e76b8ee8fd43d.html","title":"Proceedings of the 3rd Workshop on Evaluating Vector Space Representations for NLP","url":"https://www.aclweb.org/anthology/W19-2000.pdf","authors":["Anna Rogers","Aleksandr Drozd","Anna Rumshisky","Yoav Goldberg"],"date":"2019/06","abstract":"The RepEval series of workshops started in the midst of a boom of word embeddings with the goals of promoting new benchmarks for vector space meaning representations, highlighting the issues with existing benchmarks and improving on them. In addition to proposals for new evaluation tasks, it has played an important role by providing an outlet for critical analysis, negative results, and methodological caveats (reproducibility, parameters impact, the issue of attribution of results to the representation or the whole system, dataset structure/balance/representativeness)."},{"id":"23502dbfa5756b8e2fa4a8893e5a167d.html","title":"Towards better substitution-based word sense induction","url":"https://arxiv.org/abs/1905.12598","authors":["Asaf Amrami","Yoav Goldberg"],"date":"2019/05/29","journal":"arXiv preprint arXiv:1905.12598","abstract":"Word sense induction (WSI) is the task of unsupervised clustering of word usages within a sentence to distinguish senses. Recent work obtain strong results by clustering lexical substitutes derived from pre-trained RNN language models (ELMo). Adapting the method to BERT improves the scores even further. We extend the previous method to support a dynamic rather than a fixed number of clusters as supported by other prominent methods, and propose a method for interpreting the resulting clusters by associating them with their most informative substitutes. We then perform extensive error analysis revealing the remaining sources of errors in the WSI task."},{"id":"96d4e11bd406cd57634d5bb4902af4e1.html","title":"Towards Neural Decompilation","url":"https://arxiv.org/abs/1905.08325","authors":["Omer Katz","Yuval Olshaker","Yoav Goldberg","Eran Yahav"],"date":"2019/05/20","journal":"arXiv preprint arXiv:1905.08325","abstract":"We address the problem of automatic decompilation, converting a program in low-level representation back to a higher-level human-readable programming language. The problem of decompilation is extremely important for security researchers. Finding vulnerabilities and understanding how malware operates is much easier when done over source code."},{"id":"db68a6d5b6f35d4b3a018682a454cbcc.html","title":"An Algorithmic Scheme for Statistical Thesaurus Construction in a Morphologically Rich Language","url":"https://www.tandfonline.com/doi/abs/10.1080/08839514.2019.1583447","authors":["Chaya Liebeskind","Ido Dagan","Jonathan Schler"],"date":"2019/05/12","journal":"Applied Artificial Intelligence","abstract":"Corpus-based automatic thesaurus construction uses linguistic methods, such as Part-of-Speech taggers and parsers, which often perform poorly on MRLs. Therefore, in this paper, we focused on the complex task of adapting corpus-based thesaurus construction methods for MRLs. We investigated two statistical approaches for thesaurus construction; a) a first-order co-occurrence-based approach and b) a second-order distributional-based approach. We explored alternative levels of morphological term representations complemented by grouping the morphological variants. We then introduced and adopted a generic algorithmic scheme for thesaurus construction in MRLs for both first-order and second-order approaches. Our scheme investigated alternative representation levels and offered alternative configurations. We demonstrated the empirical benefits of our methodology for a diachronic Hebrew thesaurus\\\\xa0\u2026"},{"id":"f866f5c1e22bf4bd50535b47c393809a.html","title":"Multi-Context Term Embeddings: the Use Case of Corpus-based Term Set Expansion","url":"https://arxiv.org/abs/1904.02496","authors":["Jonathan Mamou","Oren Pereg","Moshe Wasserblat","Ido Dagan"],"date":"2019/04/4","journal":"arXiv preprint arXiv:1904.02496","abstract":"In this paper, we present a novel algorithm that combines multi-context term embeddings using a neural classifier and we test this approach on the use case of corpus-based term set expansion. In addition, we present a novel and unique dataset for intrinsic evaluation of corpus-based term set expansion algorithms. We show that, over this dataset, our algorithm provides up to 5 mean average precision points over the best baseline."},{"id":"43b946ed6bf2282cd14efa6e71306c63.html","title":"Crowdsourcing lightweight pyramids for manual summary evaluation","url":"https://arxiv.org/abs/1904.05929","authors":["Ori Shapira","David Gabay","Yang Gao","Hadar Ronen","Ramakanth Pasunuru","Mohit Bansal","Yael Amsterdamer","Ido Dagan"],"date":"2019/04/11","journal":"arXiv preprint arXiv:1904.05929","abstract":"Conducting a manual evaluation is considered an essential part of summary evaluation methodology. Traditionally, the Pyramid protocol, which exhaustively compares system summaries to references, has been perceived as very reliable, providing objective scores. Yet, due to the high cost of the Pyramid method and the required expertise, researchers resorted to cheaper and less thorough manual evaluation methods, such as Responsiveness and pairwise comparison, attainable via crowdsourcing. We revisit the Pyramid approach, proposing a lightweight sampling-based version that is crowdsourcable. We analyze the performance of our method in comparison to original expert-based Pyramid evaluations, showing higher correlation relative to the common Responsiveness method. We release our crowdsourced Summary-Content-Units, along with all crowdsourcing scripts, for future evaluations."},{"id":"e2d027023e8f368c15d1af98fc6a2914.html","title":"Step-by-Step: Separating Planning from Realization in Neural Data-to-Text Generation","url":"https://arxiv.org/abs/1904.03396","authors":["Amit Moryossef","Yoav Goldberg","Ido Dagan"],"date":"2019/04/06","journal":"arXiv preprint arXiv:1904.03396","abstract":"Data-to-text generation can be conceptually divided into two parts: ordering and structuring the information (planning), and generating fluent language describing the information (realization). Modern neural generation systems conflate these two steps into a single end-to-end differentiable system. We propose to split the generation process into a symbolic text-planning stage that is faithful to the input, followed by a neural generation stage that focuses only on realization. For training a plan-to-text generator, we present a method for matching reference texts to their corresponding text plans. For inference time, we describe a method for selecting high-quality text plans for new inputs. We implement and evaluate our approach on the WebNLG benchmark. Our results demonstrate that decoupling text planning from neural realization indeed improves the system\'s reliability and adequacy while maintaining fluent output. We observe improvements both in BLEU scores and in manual evaluations. Another benefit of our approach is the ability to output diverse realizations of the same input, paving the way to explicit control over the generated text structure."},{"id":"bd364e33367bfcd004f3b50c935009c6.html","title":"Studying the Inductive Biases of RNNs with Synthetic Variations of Natural Languages","url":"https://arxiv.org/abs/1903.06400","authors":["Shauli Ravfogel","Yoav Goldberg","Tal Linzen"],"date":"2019/03/15","journal":"arXiv preprint arXiv:1903.06400","abstract":"How do typological properties such as word order and morphological case marking affect the ability of neural sequence models to acquire the syntax of a language? Cross-linguistic comparisons of RNNs\' syntactic performance (eg, on subject-verb agreement prediction) are complicated by the fact that any two languages differ in multiple typological properties, as well as by differences in training corpus. We propose a paradigm that addresses these issues: we create synthetic versions of English, which differ from English in one or more typological parameters, and generate corpora for those languages based on a parsed English corpus. We report a series of experiments in which RNNs were trained to predict agreement features for verbs in each of those synthetic languages. Among other findings,(1) performance was higher in subject-verb-object order (as in English) than in subject-object-verb order (as in Japanese), suggesting that RNNs have a recency bias;(2) predicting agreement with both subject and object (polypersonal agreement) improves over predicting each separately, suggesting that underlying syntactic knowledge transfers across the two tasks; and (3) overt morphological case makes agreement prediction significantly easier, regardless of word order."},{"id":"74aa80c1682049171796211bfe7fbe99.html","title":"Lipstick on a Pig: Debiasing Methods Cover up Systematic Gender Biases in Word Embeddings But do not Remove Them","url":"https://arxiv.org/abs/1903.03862","authors":["Hila Gonen","Yoav Goldberg"],"date":"2019/03/09","journal":"arXiv preprint arXiv:1903.03862","abstract":"Word embeddings are widely used in NLP for a vast range of tasks. It was shown that word embeddings derived from text corpora reflect gender biases in society. This phenomenon is pervasive and consistent across different word embedding models, causing serious concern. Several recent works tackle this problem, and propose methods for significantly reducing this gender bias in word embeddings, demonstrating convincing results. However, we argue that this removal is superficial. While the bias is indeed substantially reduced according to the provided bias definition, the actual effect is mostly hiding the bias, not removing it. The gender bias information is still reflected in the distances between\\" gender-neutralized\\" words in the debiased embeddings, and can be recovered from them. We present a series of experiments to support this claim, for two debiasing methods. We conclude that existing bias removal techniques are insufficient, and should not be trusted for providing gender-neutral modeling."},{"id":"7bf79175af1d91fa9fbf5f1fc8319727.html","title":"Filling Gender & Number Gaps in Neural Machine Translation with Black-box Context Injection","url":"https://arxiv.org/abs/1903.03467","authors":["Amit Moryossef","Roee Aharoni","Yoav Goldberg"],"date":"2019/03/08","journal":"arXiv preprint arXiv:1903.03467","abstract":"When translating from a language that does not morphologically mark information such as gender and number into a language that does, translation systems must\\" guess\\" this missing information, often leading to incorrect translations in the given context. We propose a black-box approach for injecting the missing information to a pre-trained neural machine translation system, allowing to control the morphological variations in the generated translations without changing the underlying model or training data. We evaluate our method on an English to Hebrew translation task, and show that it is effective in injecting the gender and number information and that supplying the correct information improves the translation accuracy in up to 2.3 BLEU on a female-speaker test set for a state-of-the-art online black-box system. Finally, we perform a fine-grained syntactic analysis of the generated translations that shows the effectiveness of our method."},{"id":"278a876e8b0d9d6723ea8649eeb15ac5.html","title":"Aligning Vector-spaces with Noisy Supervised Lexicons","url":"https://ui.adsabs.harvard.edu/abs/2019arXiv190310238Y/abstract","authors":["Noa Yehezkel Lubin","Jacob Goldberger","Yoav Goldberg"],"date":"2019/03","journal":"arXiv preprint arXiv:1903.10238","abstract":"The problem of learning to translate between two vector spaces given a set of aligned points arises in several application areas of NLP. Current solutions assume that the lexicon which defines the alignment pairs is noise-free. We consider the case where the set of aligned points is allowed to contain an amount of noise, in the form of incorrect lexicon pairs and show that this arises in practice by analyzing the edited dictionaries after the cleaning process. We demonstrate that such noise substantially degrades the accuracy of the learned translation when using current methods. We propose a model that accounts for noisy pairs. This is achieved by introducing a generative model with a compatible iterative EM algorithm. The algorithm jointly learns the noise level in the lexicon, finds the set of noisy pairs, and learns the mapping between the spaces. We demonstrate the effectiveness of our proposed algorithm on two\\\\xa0\u2026"},{"id":"317b41cbe0cb126aa0df1625eec201b5.html","title":"Joint Transition-Based Models for Morpho-Syntactic Parsing: Parsing Strategies for MRLs and a Case Study from Modern Hebrew","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00253","authors":["Amir More","Amit Seker","Victoria Basmova","Reut Tsarfaty"],"date":"2019/03","journal":"Transactions of the Association for Computational Linguistics","abstract":"In standard NLP pipelines, <i>morphological analysis and disambiguation</i> (MA&D) precedes syntactic and semantic downstream tasks. However, for languages with complex and ambiguous word-internal structure, known as <i>morphologically rich languages</i> (MRLs), it has been hypothesized that syntactic context may be crucial for accurate MA&D, and vice versa. In this work we empirically confirm this hypothesis for Modern Hebrew, an MRL with complex morphology and severe word-level ambiguity, in a novel transition-based framework. Specifically, we propose a joint morphosyntactic transition-based framework which formally unifies two distinct transition systems, morphological and syntactic, into a single transition-based system with joint training and joint inference. We empirically show that MA&D results obtained in the joint settings outperform MA&D results obtained by the respective standalone components, and\\\\xa0\u2026"},{"id":"56d1abcb5505668aed5c19ad4b6c641e.html","title":"ABI Neural Ensemble Model for Gender Prediction Adapt Bar-Ilan Submission for the CLIN29 Shared Task on Gender Prediction","url":"https://arxiv.org/abs/1902.08856","authors":["Eva Vanmassenhove","Amit Moryossef","Alberto Poncelas","Andy Way","Dimitar Shterionov"],"date":"2019/02/23","journal":"arXiv preprint arXiv:1902.08856","abstract":"We present our system for the CLIN29 shared task on cross-genre gender detection for Dutch. We experimented with a multitude of neural models (CNN, RNN, LSTM, etc.), more\\" traditional\\" models (SVM, RF, LogReg, etc.), different feature sets as well as data pre-processing. The final results suggested that using tokenized, non-lowercased data works best for most of the neural models, while a combination of word clusters, character trigrams and word lists showed to be most beneficial for the majority of the more\\" traditional\\"(that is, non-neural) models, beating features used in previous tasks such as n-grams, character n-grams, part-of-speech tags and combinations thereof. In contradiction with the results described in previous comparable shared tasks, our neural models performed better than our best traditional approaches with our best feature set-up. Our final model consisted of a weighted ensemble model combining the top 25 models. Our final model won both the in-domain gender prediction task and the cross-genre challenge, achieving an average accuracy of 64.93% on the in-domain gender prediction task, and 56.26% on cross-genre gender prediction."},{"id":"ceff2a8eeb94f245d531abfad9d17307.html","title":"Mining fall-related information in clinical notes: Comparison of rule-based and novel word embedding-based machine learning approaches","url":"https://www.sciencedirect.com/science/article/pii/S1532046419300218","authors":["Maxim Topaz","Ludmila Murga","Katherine M Gaddis","Margaret V McDonald","Ofrit Bar-Bachar","Yoav Goldberg","Kathryn H Bowles"],"date":"2019/02/01","journal":"Journal of biomedical informatics","abstract":"<div><h3 class=\\"gsh_h3\\">Background</h3><div class=\\"gsh_csp\\">Natural language processing (NLP) of health-related data is still an expertise demanding, and resource expensive process. We created a novel, open source rapid clinical text mining system called NimbleMiner. NimbleMiner combines several machine learning techniques (word embedding models and positive only labels learning) to facilitate the process in which a human rapidly performs text mining of clinical narratives, while being aided by the machine learning components."},{"id":"3058c018f635f683f547cb086e5f4fbe.html","title":"Assessing BERT\'s Syntactic Abilities","url":"https://arxiv.org/abs/1901.05287","authors":["Yoav Goldberg"],"date":"2019/01/16","journal":"arXiv preprint arXiv:1901.05287","abstract":"I assess the extent to which the recently introduced BERT model captures English syntactic phenomena, using (1) naturally-occurring subject-verb agreement stimuli;(2)\\" coloreless green ideas\\" subject-verb agreement stimuli, in which content words in natural sentences are randomly replaced with words sharing the same part-of-speech and inflection; and (3) manually crafted stimuli for subject-verb agreement and reflexive anaphora phenomena. The BERT model performs remarkably well on all cases."},{"id":"25180d5fb1f2927e5d9e08240924e48b.html","title":"A little is enough: Circumventing defenses for distributed learning","url":"http://papers.nips.cc/paper/9069-a-little-is-enough-circumventing-defenses-for-distributed-learning","authors":["Gilad Baruch","Moran Baruch","Yoav Goldberg"],"date":"2019","abstract":"Distributed learning is central for large-scale training of deep-learning models. However, it is exposed to a security threat in which Byzantine participants can interrupt or control the learning process. Previous attack models assume that the rogue participants (a) are omniscient (know the data of all other participants), and (b) introduce large changes to the parameters. Accordingly, most defense mechanisms make a similar assumption and attempt to use statistically robust methods to identify and discard values whose reported gradients are far from the population mean. We observe that if the empirical variance between the gradients of workers is high enough, an attacker could take advantage of this and launch a non-omniscient attack that operates within the population variance. We show that the variance is indeed high enough even for simple datasets such as MNIST, allowing an attack that is not only undetected by existing defenses, but also uses their power against them, causing those defense mechanisms to consistently select the byzantine workers while discarding legitimate ones. We demonstrate our attack method works not only for preventing convergence but also for repurposing of the model behavior (``backdooring\'\'). We show that less than 25\\\\\\\\% of colluding workers are sufficient to degrade the accuracy of models trained on MNIST, CIFAR10 and CIFAR100 by 50\\\\\\\\%, as well as to introduce backdoors without hurting the accuracy for MNIST and CIFAR10 datasets, but with a degradation for CIFAR100."},{"id":"3c6e8ef4cca51a2dd2cad1aa3220a590.html","title":"Revisiting the Binary Linearization Technique for Surface Realization","url":"https://www.aclweb.org/anthology/W19-8635/","authors":["Yevgeniy Puzikov","Claire Gardent","Ido Dagan","Iryna Gurevych"],"date":"2019","abstract":"End-to-end neural approaches have achieved state-of-the-art performance in many natural language processing (NLP) tasks. Yet, they often lack transparency of the underlying decision-making process, hindering error analysis and certain model improvements. In this work, we revisit the binary linearization approach to surface realization, which exhibits more interpretable behavior, but was falling short in terms of prediction accuracy. We show how enriching the training data to better capture word order constraints almost doubles the performance of the system. We further demonstrate that encoding both local and global prediction contexts yields another considerable performance boost. With the proposed modifications, the system which ranked low in the latest shared task on multilingual surface realization now achieves best results in five out of ten languages, while being on par with the state-of-the-art approaches in others."},{"id":"44b5d9f49183cc1779dfabe38bdfc32c.html","title":"Lipstick on a pig: Debiasing methods cover up systematic gender biases in word embeddings but do not remove them. arXiv 2019","url":"https://scholar.google.com/scholar?cluster=14750699376859225063&hl=en&oi=scholarr","authors":["Hila Gonen","Yoav Goldberg"],"date":"2019","journal":"arXiv preprint arXiv:1903.03862"},{"id":"81bbb1dd394f1acc04c3b582e917c0a6.html","title":"Learning Deterministic Weighted Automata with Queries and Counterexamples","url":"http://papers.nips.cc/paper/9062-learning-deterministic-weighted-automata-with-queries-and-counterexamples","authors":["Gail Weiss","Yoav Goldberg","Eran Yahav"],"date":"2019","abstract":"We present an algorithm for reconstruction of a probabilistic deterministic finite automaton (PDFA) from a given black-box language model, such as a recurrent neural network (RNN). The algorithm is a variant of the exact-learning algorithm L*, adapted to work in a probabilistic setting under noise. The key insight of the adaptation is the use of conditional probabilities when making observations on the model, and the introduction of a variation tolerance when comparing observations. When applied to RNNs, our algorithm returns models with better or equal word error rate (WER) and normalised distributed cumulative gain (NDCG) than achieved by n-gram or weighted finite automata (WFA) approximations of the same networks. The PDFAs capture a richer class of languages than n-grams, and are guaranteed to be stochastic and deterministic--unlike the WFAs."},{"id":"1907d804fe50c7d2f11c6e988d247513.html","title":"The Hebrew Universal Dependency Treebank: Past Present and Future","url":"https://www.aclweb.org/anthology/W18-6016.pdf","authors":["Shoval Sade","Amit Seker","Reut Tsarfaty"],"date":"2018/11","abstract":"The Hebrew treebank (HTB), consisting of 6221 morpho-syntactically annotated newspaper sentences, has been the only resource for training and validating Hebrew statistical parsers for almost two decades now. During these decades, the HTB has gone through a trajectory of automatic and semi-automatic conversions, until arriving at its current UDv2 form. In this work we set out to manually validate the UDv2 version and, accordingly, we apply scheme changes to bring the UD HTB into the same theoretical ground as the rest of UD. Our experimental results show that improving the linguistic coherence and internal consistency of the UD HTB has indeed led to improved syntactic parsing performance. At the same time, there is more to be done at the points of intersection with other linguistic processing layers, in particular, at the interface of UD with external morphological and lexical resources."},{"id":"31c02ce282cb3ec2b7076642c3f6726f.html","title":"Language Modeling for Code-Switching: Evaluation, Integration of Monolingual Data, and Discriminative Training","url":"https://arxiv.org/abs/1810.11895","authors":["Hila Gonen","Yoav Goldberg"],"date":"2018/10/28","journal":"arXiv preprint arXiv:1810.11895","abstract":"We focus on the problem of language modeling for code-switched language, in the context of automatic speech recognition (ASR). Language modeling for code-switched language is challenging for (at least) three reasons:(1) lack of available large-scale code-switched data for training;(2) lack of a replicable evaluation setup that is ASR directed yet isolates language modeling performance from the other intricacies of the ASR system; and (3) the reliance on generative modeling. We tackle these three issues: we propose an ASR-motivated evaluation setup which is decoupled from an ASR system and the choice of vocabulary, and provide an evaluation dataset for English-Spanish code-switching. This setup lends itself to a discriminative training approach, which we demonstrate to work better than generative language modeling. Finally, we explore a variety of training protocols and verify the effectiveness of training with large amounts of monolingual data followed by fine-tuning with small amounts of code-switched data, for both the generative and discriminative cases."},{"id":"ffaa011ac86911750b469598abb105f2.html","title":"Universal Morpho-syntactic Parsing and the Contribution of Lexica: Analyzing the ONLP Lab Submission to the CoNLL 2018 Shared Task","url":"https://www.aclweb.org/anthology/K18-2021.pdf","authors":["Amit Seker","Amir More","Reut Tsarfaty"],"date":"2018/10","abstract":"We present the contribution of the ONLP lab at the Open University of Israel to the UD shared task on multilingual parsing from raw text to Universal Dependencies. Our contribution is based on a transition-based parser called \u2018yap\u2013yet another parser\u2019, which includes a standalone morphological model, a standalone dependency model, and a joint morphosyntactic model. In the task we used yap\u2018s standalone dependency parser to parse input morphologically disambiguated by UDPipe, and obtained the official score of 58.35 LAS. In our follow up investigation we use yap to show how the incorporation of morphological and lexical resources may improve the performance of end-to-end raw-to-dependencies parsing in the case of a morphologically-rich and low-resource language, Modern Hebrew. Our results on Hebrew underscore the importance of CoNLL-UL, a UD-compatible standard for accessing external lexical resources, for enhancing end-to-end UD parsing, in particular for morphologically rich and low-resource languages. We thus encourage the community to create, convert, or make available more such lexica in future tasks."},{"id":"98768bc2d9680b9a2eda708a61cd1836.html","title":"Understanding Convolutional Neural Networks for Text Classification","url":"https://arxiv.org/abs/1809.08037","authors":["Alon Jacovi","Oren Sar Shalom","Yoav Goldberg"],"date":"2018/09/21","journal":"arXiv preprint arXiv:1809.08037","abstract":"We present an analysis into the inner workings of Convolutional Neural Networks (CNNs) for processing text. CNNs used for computer vision can be interpreted by projecting filters into image space, but for discrete sequence inputs CNNs remain a mystery. We aim to understand the method by which the networks process and classify text. We examine common hypotheses to this problem: that filters, accompanied by global max-pooling, serve as ngram detectors. We show that filters may capture several different semantic classes of ngrams by using different activation patterns, and that global max-pooling induces behavior which separates important ngrams from the rest. Finally, we show practical use cases derived from our findings in the form of model interpretability (explaining a trained model by deriving a concrete identity for each filter, bridging the gap between visualization tools in vision tasks and NLP) and prediction interpretability (explaining predictions). Code implementation is available online at this http URL."},{"id":"d4b2f4dd816732023c5204ba61be1589.html","title":"Can LSTM Learn to Capture Agreement? The Case of Basque","url":"https://arxiv.org/abs/1809.04022","authors":["Shauli Ravfogel","Francis M Tyers","Yoav Goldberg"],"date":"2018/09/11","journal":"arXiv preprint arXiv:1809.04022","abstract":"Sequential neural networks models are powerful tools in a variety of Natural Language Processing (NLP) tasks. The sequential nature of these models raises the questions: to what extent can these models implicitly learn hierarchical structures typical to human language, and what kind of grammatical phenomena can they acquire?"},{"id":"36cb5b73a18551d63bd9b14578539cd5.html","title":"Word Sense Induction with Neural biLM and Symmetric Patterns","url":"https://arxiv.org/abs/1808.08518","authors":["Asaf Amrami","Yoav Goldberg"],"date":"2018/08/26","journal":"arXiv preprint arXiv:1808.08518","abstract":"An established method for Word Sense Induction (WSI) uses a language model to predict probable substitutes for target words, and induces senses by clustering these resulting substitute vectors."},{"id":"41ed0b3746a53e81f3263f99b6fffd20.html","title":"Adversarial Removal of Demographic Attributes from Text Data","url":"https://arxiv.org/abs/1808.06640","authors":["Yanai Elazar","Yoav Goldberg"],"date":"2018/08/20","journal":"arXiv preprint arXiv:1808.06640","abstract":"Recent advances in Representation Learning and Adversarial Training seem to succeed in removing unwanted features from the learned representation. We show that demographic information of authors is encoded in--and can be recovered from--the intermediate representations learned by text-based neural classifiers. The implication is that decisions of classifiers trained on textual data are not agnostic to--and likely condition on--demographic attributes. When attempting to remove such demographic information using adversarial training, we find that while the adversarial component achieves chance-level development-set accuracy during training, a post-hoc classifier, trained on the encoded sentences from the first part, still manages to reach substantially higher classification accuracies on the same data. This behavior is consistent across several tasks, demographic properties and datasets. We explore several techniques to improve the effectiveness of the adversarial component. Our main conclusion is a cautionary one: do not rely on the adversarial training to achieve invariant representation to sensitive features."},{"id":"b022d633a9ee3747ac96b8142fe4cbdc.html","title":"Clustering small-sized collections of short texts","url":"https://link.springer.com/article/10.1007/s10791-017-9324-8","authors":["Lili Kotlerman","Ido Dagan","Oren Kurland"],"date":"2018/08/01","journal":"Information Retrieval Journal","abstract":"The need to cluster small text corpora composed of a few hundreds of short texts rises in various applications; e.g., clustering top-retrieved documents based on their snippets. This clustering task is challenging due to the vocabulary mismatch between short texts and the insufficient corpus-based statistics (e.g., term co-occurrence statistics) due to the corpus size. We address this clustering challenge using a framework that utilizes a set of external knowledge resources that provide information about term relations. Specifically, we use information induced from the resources to estimate similarity between terms and produce term clusters. We also utilize the resources to expand the vocabulary used in the given corpus and thus enhance term clustering. We then project the texts in the corpus onto the term clusters to cluster the texts. We evaluate various instantiations of the proposed framework by varying the\\\\xa0\u2026"},{"id":"624e2f3a32ddcdfe602eb00e1b35c540.html","title":"Setexpander: End-to-end term set expansion based on multi-context term embeddings","url":"https://www.aclweb.org/anthology/C18-2013.pdf","authors":["Jonathan Mamou","Oren Pereg","Moshe Wasserblat","Ido Dagan","Yoav Goldberg","Alon Eirew","Yael Green","Shira Guskin","Peter Izsak","Daniel Korat"],"date":"2018/08","abstract":"We present SetExpander, a corpus-based system for expanding a seed set of terms into a more complete set of terms that belong to the same semantic class. SetExpander implements an iterative end-to end workflow for term set expansion. It enables users to easily select a seed set of terms, expand it, view the expanded set, validate it, re-expand the validated set and store it, thus simplifying the extraction of domain-specific fine-grained semantic classes. SetExpander has been used for solving real-life use cases including integration in an automated recruitment system and an issues and defects resolution system. A video demo of SetExpander is available at https://drive. google. com/open? id= 1e545bB87Autsch36DjnJHmq3HWfSd1Rv."},{"id":"81e4c1f1a9ec1ccb25f338b6a6d94de1.html","title":"Representations and Architectures in Neural Sentiment Analysis for Morphologically Rich Languages: A Case Study from Modern Hebrew","url":"https://www.aclweb.org/anthology/C18-1190.pdf","authors":["Adam Amram","Anat Ben David","Reut Tsarfaty"],"date":"2018/08","abstract":"This paper empirically studies the effects of representation choices on neural sentiment analysis for Modern Hebrew, a morphologically rich language (MRL) for which no sentiment analyzer currently exists. We study two dimensions of representational choices:(i) the granularity of the input signal (token-based vs. morpheme-based), and (ii) the level of encoding of vocabulary items (string-based vs. character-based). We hypothesise that for MRLs, languages where multiple meaning-bearing elements may be carried by a single space-delimited token, these choices will have measurable effects on task perfromance, and that these effects may vary for different architectural designs\u2014fully-connected, convolutional or recurrent. Specifically, we hypothesize that morpheme-based representations will have advantages in terms of their generalization capacity and task accuracy, due to their better OOV coverage. To empirically study these effects, we develop a new sentiment analysis benchmark for Hebrew, based on 12K social media comments, and provide two instances of these data: in token-based and morpheme-based settings. Our experiments show that representation choices empirical effects vary with architecture type. While fully-connected and convolutional networks slightly prefer token-based settings, RNNs benefit from a morpheme-based representation, in accord with the hypothesis that explicit morphological information may help generalize. Our endeavour also delivers the first state-of-the-art broad-coverage sentiment analyzer for Hebrew, with over 89% accuracy, alongside an established benchmark to further study the effects of linguistic\\\\xa0\u2026"},{"id":"50545196f0f97f2ea27dffa53230817e.html","title":"Term Set Expansion based on Multi-Context Term Embeddings: an End-to-end Workflow","url":"https://arxiv.org/abs/1807.10104","authors":["Jonathan Mamou","Oren Pereg","Moshe Wasserblat","Ido Dagan","Yoav Goldberg","Alon Eirew","Yael Green","Shira Guskin","Peter Izsak","Daniel Korat"],"date":"2018/07/26","journal":"arXiv preprint arXiv:1807.10104","abstract":"We present SetExpander, a corpus-based system for expanding a seed set of terms into a more complete set of terms that belong to the same semantic class. SetExpander implements an iterative end-to end workflow for term set expansion. It enables users to easily select a seed set of terms, expand it, view the expanded set, validate it, re-expand the validated set and store it, thus simplifying the extraction of domain-specific fine-grained semantic classes. SetExpander has been used for solving real-life use cases including integration in an automated recruitment system and an issues and defects resolution system. A video demo of SetExpander is available at this https URL (some images were blurred for privacy reasons)."},{"id":"9d78d4d30f816c6d7dd0cbb93455ea60.html","title":"Breaking NLI Systems","url":"http://scholar.google.com/scholar?cluster=17876126004664715882&hl=en&oi=scholarr","authors":["Max Glockner","Vered Shwartz","Yoav Goldberg"],"date":"2018/07/18"},{"id":"4cbc18692e9df8f1cae028bc49b175f6.html","title":"Privacy and Fairness in Recommender Systems via Adversarial Training of User Representations","url":"https://arxiv.org/abs/1807.03521","authors":["Yehezkel S Resheff","Yanai Elazar","Moni Shahar","Oren Sar Shalom"],"date":"2018/07/10","journal":"arXiv preprint arXiv:1807.03521","abstract":"Latent factor models for recommender systems represent users and items as low dimensional vectors. Privacy risks of such systems have previously been studied mostly in the context of recovery of personal information in the form of usage records from the training data. However, the user representations themselves may be used together with external data to recover private user information such as gender and age. In this paper we show that user vectors calculated by a common recommender system can be exploited in this way. We propose the privacy-adversarial framework to eliminate such leakage of private information, and study the trade-off between recommender performance and leakage both theoretically and empirically using a benchmark dataset. An advantage of the proposed method is that it also helps guarantee fairness of results, since all implicit knowledge of a set of attributes is scrubbed from the representations used by the model, and thus can\'t enter into the decision making. We discuss further applications of this method towards the generation of deeper and more insightful recommendations."},{"id":"bb8ba07d5e9c3dd706117b67b8d52824.html","title":"Privacy-adversarial user representations in recommender systems","url":"https://www.researchgate.net/profile/Yehezkel_Resheff/publication/326315675_Privacy-Adversarial_User_Representations_in_Recommender_Systems/links/5b8d13b7a6fdcc5f8b7af1e7/Privacy-Adversarial-User-Representations-in-Recommender-Systems.pdf","authors":["Yehezkel S Resheff","Yanai Elazar","Moni Shahar","Oren Sar Shalom"],"date":"2018/07","journal":"arXiv preprint arXiv:1807.03521","abstract":"Latent factor models for recommender systems represent users and items as low dimensional vectors. Privacy risks have been previously studied mostly in the context of recovery of personal information in the form of usage records from the training data. However, the user representations themselves may be used together with external data to recover private user information such as gender and age. In this paper we show that user vectors calculated by a common recommender system can be exploited in this way. We propose the privacy-adversarial framework to eliminate such leakage, and study the trade-off between recommender performance and leakage both theoretically and empirically using a benchmark dataset. We briefly discuss further applications of this method towards the generation of deeper and more insightful recommendations."},{"id":"eef6fab77da3b7b9d613d2484f416a35.html","title":"Proceedings of the Workshop on the Relevance of Linguistic Structure in Neural Architectures for NLP","url":"https://www.aclweb.org/anthology/W18-2900.pdf","authors":["Georgiana Dinu","Miguel Ballesteros","Avirup Sil","Samuel Bowman","Wael Hamza","Anders S\\\\xf8gaard","Tahira Naseem","Yoav Goldberg"],"date":"2018/07","abstract":"Welcome to the ACL Workshop on the Relevance of Linguistic Structure in Neural Architectures for NLP (RELNLP). The workshop took place on July 19th 2018, collocated with the 56th Annual Meeting of the Association for Computational Linguistics in Melbourne, Australia."},{"id":"0f8b776f0b2c15dc2c419b53399843f0.html","title":"Supervised open information extraction","url":"https://www.aclweb.org/anthology/N18-1081.pdf","authors":["Gabriel Stanovsky","Julian Michael","Luke Zettlemoyer","Ido Dagan"],"date":"2018/06","abstract":"We present data and methods that enable a supervised learning approach to Open Information Extraction (Open IE). Central to the approach is a novel formulation of Open IE as a sequence tagging problem, addressing challenges such as encoding multiple extractions for a predicate. We also develop a bi-LSTM transducer, extending recent deep Semantic Role Labeling models to extract Open IE tuples and provide confidence scores for tuning their precision-recall tradeoff. Furthermore, we show that the recently released Question-Answer Meaning Representation dataset can be automatically converted into an Open IE corpus which significantly increases the amount of available training data. Our supervised model outperforms the existing state-of-the-art Open IE systems on benchmark datasets."},{"id":"de7a8198227d55df0a188ecff45b62d4.html","title":"Transfer Learning for Related Reinforcement Learning Tasks via Image-to-Image Translation","url":"http://proceedings.mlr.press/v97/gamrian19a.html","authors":["Shani Gamrian","Yoav Goldberg"],"date":"2018/05/31","journal":"arXiv preprint arXiv:1806.07377","abstract":"Despite the remarkable success of Deep RL in learning control policies from raw pixels, the resulting models do not generalize. We demonstrate that a trained agent fails completely when facing small visual changes, and that fine-tuning\u2014the common transfer learning paradigm\u2014fails to adapt to these changes, to the extent that it is faster to re-train the model from scratch. We show that by separating the visual transfer task from the control policy we achieve substantially better sample efficiency and transfer behavior, allowing an agent trained on the source task to transfer well to the target tasks. The visual mapping from the target to the source domain is performed using unaligned GANs, resulting in a control policy that can be further improved using imitation learning from imperfect demonstrations. We demonstrate the approach on synthetic visual variants of the Breakout game, as well as on transfer between subsequent levels of Road Fighter, a Nintendo car-driving game. A visualization of our approach can be seen in\\\\\\\\url {https://youtu. be/4mnkzYyXMn4} and\\\\\\\\url {https://youtu. be/KCGTrQi6Ogo}."},{"id":"f3eb4c0d91148172df9bb6d55a19e008.html","title":"On the Practical Computational Power of Finite Precision RNNs for Language Recognition","url":"https://arxiv.org/abs/1805.04908","authors":["Gail Weiss","Yoav Goldberg","Eran Yahav"],"date":"2018/05/13","journal":"arXiv preprint arXiv:1805.04908","abstract":"While Recurrent Neural Networks (RNNs) are famously known to be Turing complete, this relies on infinite precision in the states and unbounded computation time. We consider the case of RNNs with finite precision whose computation time is linear in the input length. Under these limitations, we show that different RNN variants have different computational power. In particular, we show that the LSTM and the Elman-RNN with ReLU activation are strictly stronger than the RNN with a squashing activation and the GRU. This is achieved because LSTMs and ReLU-RNNs can easily implement counting behavior. We show empirically that the LSTM does indeed learn to effectively use the counting mechanism."},{"id":"5356c97145931b980794128c6c314719.html","title":"Paraphrase to explicate: Revealing implicit noun-compound relations","url":"https://arxiv.org/abs/1805.02442","authors":["Vered Shwartz","Ido Dagan"],"date":"2018/05/07","journal":"arXiv preprint arXiv:1805.02442","abstract":"Revealing the implicit semantic relation between the constituents of a noun-compound is important for many NLP applications. It has been addressed in the literature either as a classification task to a set of pre-defined relations or by producing free text paraphrases explicating the relations. Most existing paraphrasing methods lack the ability to generalize, and have a hard time interpreting infrequent or new noun-compounds. We propose a neural model that generalizes better by representing paraphrases in a continuous space, generalizing for both unseen noun-compounds and rare paraphrases. Our model helps improving performance on both the noun-compound paraphrasing and classification tasks."},{"id":"9e25d66dc6cced8645f66336cbd2ecf8.html","title":"Conll-ul: Universal morphological lattices for universal dependency parsing","url":"https://hal.inria.fr/hal-01786125/","authors":["Amir More","\\\\xd6zlem \\\\xc7etino\u011flu","\\\\xc7a\u011fri \\\\xc7\\\\xf6ltekin","Nizar Habash","Beno\\\\xeet Sagot","Djam\\\\xe9 Seddah","Dima Taji","Reut Tsarfaty"],"date":"2018/05/07","abstract":""},{"id":"940fbc16cff71712ce2f5ad3dd109548.html","title":"Breaking NLI Systems with Sentences that Require Simple Lexical Inferences","url":"https://arxiv.org/abs/1805.02266","authors":["Max Glockner","Vered Shwartz","Yoav Goldberg"],"date":"2018/05/06","journal":"arXiv preprint arXiv:1805.02266","abstract":"We create a new NLI test set that shows the deficiency of state-of-the-art models in inferences that require lexical and world knowledge. The new examples are simpler than the SNLI test set, containing sentences that differ by at most one word from sentences in the training set. Yet, the performance on the new test set is substantially worse across systems trained on SNLI, demonstrating that these systems are limited in their generalization ability, failing to capture many simple inferences."},{"id":"321f7e40fd8dac2b87a7e12d4e9f70a7.html","title":"Split and Rephrase: Better Evaluation and a Stronger Baseline","url":"https://arxiv.org/abs/1805.01035","authors":["Roee Aharoni","Yoav Goldberg"],"date":"2018/05/02","journal":"arXiv preprint arXiv:1805.01035","abstract":"Splitting and rephrasing a complex sentence into several shorter sentences that convey the same meaning is a challenging problem in NLP. We show that while vanilla seq2seq models can reach high scores on the proposed benchmark (Narayan et al., 2017), they suffer from memorization of the training set which contains more than 89% of the unique simple sentences from the validation and test sets. To aid this, we present a new train-development-test data split and neural models augmented with a copy-mechanism, outperforming the best reported baseline by 8.68 BLEU and fostering further progress on the task."},{"id":"fc3de3bce8c5e81cf71945c2af2735e5.html","title":"Automatic thesaurus construction for modern Hebrew","url":"https://www.aclweb.org/anthology/L18-1229.pdf","authors":["Chaya Liebeskind","Ido Dagan","Jonathan Schler"],"date":"2018/05","abstract":"Automatic thesaurus construction for Modern Hebrew is a complicated task, due to its high degree of inflectional ambiguity. Linguistics tools, including morphological analyzers, part-of-speech taggers and parsers often have limited in performance on Morphologically Rich Languages (MRLs) such as Hebrew. In this paper, we adopted a schematic methodology for generating a cooccurrence based thesaurus in a MRL and extended the methodology to create distributional similarity thesaurus. We explored three alternative levels of morphological term representations, surface form, lemma, and multiple lemmas, all complemented by the clustering of morphological variants. First, we evaluated both the co-occurrence based method and the distributional similarity method using Hebrew WordNet as our gold standard. However, due to Hebrew WordNet\'s low coverage, we completed our analysis with a manual evaluation. The results showed that for Modern Hebrew corpus-based thesaurus construction, the most directly applied statistical collection, using linguistics tools at the lemma level, is not optimal."},{"id":"3e2a1f54b708ff4dc99b16063a0ae632.html","title":"LaVAN: Localized and Visible Adversarial Noise","url":"https://arxiv.org/abs/1801.02608","authors":["Danny Karmon","Daniel Zoran","Yoav Goldberg"],"date":"2018/01/08","journal":"arXiv preprint arXiv:1801.02608","abstract":"Most works on adversarial examples for deep-learning based image classifiers use noise that, while small, covers the entire image. We explore the case where the noise is allowed to be visible but confined to a small, localized patch of the image, without covering any of the main object (s) in the image. We show that it is possible to generate localized adversarial noises that cover only 2% of the pixels in the image, none of them over the main object, and that are transferable across images and locations, and successfully fool a state-of-the-art Inception v3 model with very high success rates."},{"id":"66b84a1efd8eb787d5298664e8695b65.html","title":"Semantics as a foreign language","url":"https://www.aclweb.org/anthology/D18-1263.pdf","authors":["Gabriel Stanovsky","Ido Dagan"],"date":"2018","abstract":"We propose a novel approach to semantic dependency parsing (SDP) by casting the task as an instance of multi-lingual machine translation, where each semantic representation is a different foreign dialect. To that end, we first generalize syntactic linearization techniques to account for the richer semantic dependency graph structure. Following, we design a neural sequence-to-sequence framework which can effectively recover our graph linearizations, performing almost on-par with previous SDP state-of-the-art while requiring less parallel training annotations. Beyond SDP, our linearization technique opens the door to integration of graph-based semantic representations as features in neural models for downstream applications."},{"id":"90bbbc78edeed9f70532733d19519959.html","title":"Evaluating multiple system summary lengths: A case study","url":"https://www.aclweb.org/anthology/D18-1087.pdf","authors":["Ori Shapira","David Gabay","Hadar Ronen","Judit Bar-Ilan","Yael Amsterdamer","Ani Nenkova","Ido Dagan"],"date":"2018","abstract":"Practical summarization systems are expected to produce summaries of varying lengths, per user needs. While a couple of early summarization benchmarks tested systems across multiple summary lengths, this practice was mostly abandoned due to the assumed cost of producing reference summaries of multiple lengths. In this paper, we raise the research question of whether reference summaries of a single length can be used to reliably evaluate system summaries of multiple lengths. For that, we have analyzed a couple of datasets as a case study, using several variants of the ROUGE metric that are standard in summarization evaluation. Our findings indicate that the evaluation protocol in question is indeed competitive. This result paves the way to practically evaluating varying-length summaries with simple, possibly existing, summarization benchmarks."},{"id":"d2e17254af8ff2877abcc0eb00deb4a2.html","title":"The Natural Language Programming (NLPRO) Project: Turning Text into Executable Code.","url":"http://ceur-ws.org/Vol-2075/NLP4RE_paper10.pdf","authors":["Reut Tsarfaty"],"date":"2018","abstract":"In this paper we present the natural language programming (NLPRO) project (via ERC-StG-2015 grant 677352), where we strive to automatically translate requirements documents directly into the executable code of the systems they describe. To achieve this, we embrace the ambiguity of NL requirements and define a three-fold research agenda wherein we (i) formalize text-to-code translation as a structure prediction task,(ii) propose a formal semantic representation in terms of Live Sequence Charts (LSCs), and (iii) develop and comparatively evaluate novel sentence-based vs. discourse-based models for semantic parsing of requirements documents, and test their accuracy on various case studies. The empirical results of our first research cycle show that the discourse-based models consistently outperform the sentence-based models in constructing a system that reflects the requirements in the document. We conjecture that the formal representation of LSCs, the joint sentencediscourse modeling strategy, and the statistical learning component, are key ingredients for effectively tackling the NLPRO long-standing challenge."},{"id":"d6ed955be0496bc9fe40f314ac6d1cf5.html","title":"Extracting Automata from Recurrent Neural Networks Using Queries and Counterexamples","url":"http://proceedings.mlr.press/v80/weiss18a.html","authors":["Gail Weiss","Yoav Goldberg","Eran Yahav"],"date":"2017/11/27","journal":"arXiv preprint arXiv:1711.09576","abstract":"We present a novel algorithm that uses exact learning and abstraction to extract a deterministic finite automaton describing the state dynamics of a given trained RNN. We do this using Angluin\u2019s\\\\\\\\lstar algorithm as a learner and the trained RNN as an oracle. Our technique efficiently extracts accurate automata from trained RNNs, even when the state vectors are large and require fine differentiation."},{"id":"0597766b979c5e42d744585869c89f7c.html","title":"Crowdsourcing question-answer meaning representations","url":"https://arxiv.org/abs/1711.05885","authors":["Julian Michael","Gabriel Stanovsky","Luheng He","Ido Dagan","Luke Zettlemoyer"],"date":"2017/11/16","journal":"arXiv preprint arXiv:1711.05885","abstract":"We introduce Question-Answer Meaning Representations (QAMRs), which represent the predicate-argument structure of a sentence as a set of question-answer pairs. We also develop a crowdsourcing scheme to show that QAMRs can be labeled with very little training, and gather a dataset with over 5,000 sentences and 100,000 questions. A detailed qualitative analysis demonstrates that the crowd-generated question-answer pairs cover the vast majority of predicate-argument relationships in existing datasets (including PropBank, NomBank, QA-SRL, and AMR) along with many previously under-resourced ones, including implicit arguments and relations. The QAMR data and annotation code is made publicly available to enable future work on how best to model these complex phenomena."},{"id":"1ba3f1f79f9fc16c184cd11b1a4585c3.html","title":"Universal Dependencies 2.1","url":"https://lindat.mff.cuni.cz/repository/xmlui/handle/11234/1-1548?locale-attribute=cs","authors":["Joakim Nivre","\u017deljko Agi\u0107","Lars Ahrenberg","Lene Antonsen","Maria Jesus Aranzabe","Masayuki Asahara","Luma Ateyah","Mohammed Attia","Aitziber Atutxa","Liesbeth Augustinus","Elena Badmaeva","Miguel Ballesteros","Esha Banerjee","Sebastian Bank","Verginica Barbu Mititelu","John Bauer","Kepa Bengoetxea","Riyaz Ahmad Bhat","Eckhard Bick","Victoria Bobicev","Carl B\\\\xf6rstell","Cristina Bosco","Gosse Bouma","Sam Bowman","Aljoscha Burchardt","Marie Candito","Gauthier Caron","G\\\\xfcl\u015fen Cebiro\u011flu Eryi\u011fit","Giuseppe GA Celano","Savas Cetin","Fabricio Chalub","Jinho Choi","Silvie Cinkov\\\\xe1","\\\\xc7a\u011fr\u0131 \\\\xc7\\\\xf6ltekin","Miriam Connor","Elizabeth Davidson","Marie\u2010catherine Marneffe","Valeria Paiva","Arantza Ilarraza","Peter Dirix","Kaja Dobrovoljc","Timothy Dozat","Kira Droganova","Puneet Dwivedi","Marhaba Eli","Ali Elkahky","Toma\u017e Erjavec","Rich\\\\xe1rd Farkas","Hector Fernandez Alcalde","Jennifer Foster","Cl\\\\xe1udia Freitas","Katar\\\\xedna Gajdo\u0161ov\\\\xe1","Daniel Galbraith","Marcos Garcia","Moa G\\\\xe4rdenfors","Kim Gerdes","Filip Ginter","Iakes Goenaga","Koldo Gojenola","Memduh G\\\\xf6k\u0131rmak","Yoav Goldberg","Xavier G\\\\xf3mez Guinovart","Berta Gonz\\\\xe1les Saavedra","Matias Grioni","Normunds Gr\u016bz\u012btis","Bruno Guillaume","Nizar Habash","Jan Haji\u010d","Jan Haji\u010d Jr","Linh H\\\\xe0 M\u1ef9","Kim Harris","Dag Haug","Barbora Hladk\\\\xe1","Jaroslava Hlav\\\\xe1\u010dov\\\\xe1","Florinel Hociung","Petter Hohle","Radu Ion","Elena Irimia","Tom\\\\xe1\u0161 Jel\\\\xednek","Anders Johannsen","Fredrik J\\\\xf8rgensen","H\\\\xfcner Ka\u015f\u0131kara","Hiroshi Kanayama","Jenna Kanerva","Tolga Kayadelen","V\\\\xe1clava Kettnerov\\\\xe1","Jesse Kirchner","Natalia Kotsyba","Simon Krek","Veronika Laippala","Lorenzo Lambertino","Tatiana Lando","John Lee","Ph\u01b0\u01a1ng L\\\\xea H\u1ed3ng","Alessandro Lenci","Saran Lertpradit","Herman Leung","Cheuk Ying Li","Josie Li","Keying Li","Nikola Ljube\u0161i\u0107","Olga Loginova","Olga Lyashevskaya","Teresa Lynn","Vivien Macketanz","Aibek Makazhanov","Michael Mandl","Christopher Manning","C\u0103t\u0103lina M\u0103r\u0103nduc","David Mare\u010dek","Katrin Marheinecke","H\\\\xe9ctor Mart\\\\xednez Alonso","Andr\\\\xe9 Martins","Jan Ma\u0161ek","Yuji Matsumoto","Ryan Mcdonald","Gustavo Mendon\\\\xe7a","Niko Miekka","Anna Missil\\\\xe4","C\u0103t\u0103lin Mititelu","Yusuke Miyao","Simonetta Montemagni","Amir More","Laura Moreno Romero","Shinsuke Mori","Bohdan Moskalevskyi","Kadri Muischnek","Kaili M\\\\xfc\\\\xfcrisep","Pinkey Nainwani","Anna Nedoluzhko","Gunta Ne\u0161pore\u2010b\u0113rzkalne","L\u01b0\u01a1ng Nguy\u1ec5n Th\u1ecb","Huy\u1ec1n Nguy\u1ec5n Th\u1ecb Minh","Vitaly Nikolaev","Hanna Nurmi","Stina Ojala","Petya Osenova","Robert \\\\xd6stling","Lilja \\\\xd8vrelid","Elena Pascual","Marco Passarotti","Cenel\u2010augusto Perez","Guy Perrier","Slav Petrov","Jussi Piitulainen","Emily Pitler","Barbara Plank","Martin Popel","Lauma Pretkalni\u0146a","Prokopis Prokopidis"],"date":"2017/11/15","abstract":"Popis Universal Dependencies is a project that seeks to develop cross-linguistically consistent treebank annotation for many languages, with the goal of facilitating multilingual parser development, cross-lingual learning, and parsing research from a language typology perspective. The annotation scheme is based on (universal) Stanford dependencies (de Marneffe et al., 2006, 2008, 2014), Google universal part-of-speech tags (Petrov et al., 2012), and the Interset interlingua for morphosyntactic tagsets (Zeman, 2008)."},{"id":"d69c90172f6b36c4a5c6bb80397bd797.html","title":"Analysis of sentence embedding models using prediction tasks in natural language processing","url":"https://ieeexplore.ieee.org/abstract/document/8030297/","authors":["Yossi Adi","Einat Kermany","Yonatan Belinkov","Ofer Lavi","Yoav Goldberg"],"date":"2017/09/08","journal":"IBM Journal of Research and Development","abstract":""},{"id":"23a0d2f1e8e985d84e523af8378bc938.html","title":"Capturing Dependency Syntax with \u201cDeep\u201d Sequential Models","url":"https://ep.liu.se/konferensartikel.aspx?series=ecp&issue=139&Article_No=1","authors":["Yoav Goldberg"],"date":"2017/09","abstract":"Neural network (\u201cdeep learning\u201d) models are taking over machine learning approaches for language by storm. In particular, recurrent neural networks (RNNs), which are flexible non-markovian models of sequential data, were shown to be effective for a variety of language processing tasks. Somewhat surprisingly, these seemingly purely sequential models are very capable at modeling syntactic phenomena, and using them result in very strong dependency parsers, for a variety of languages. In this talk, I will briefly describe recurrent-networks, and present empirical evidence for their capabilities of learning the subject-verb agreement relation in naturally occuring text, from relatively indirect supervision. This part is based on my joint work with Tal Linzen and Emmanuel Dupoux. I will then describe bi-directional recurrent networks---a simple extension of recurrent networks---and show how they can be used as the\\\\xa0\u2026"},{"id":"3e59d5a82a25f0727855f1221002d7fe.html","title":"Interactive abstractive summarization for event news tweets","url":"https://www.aclweb.org/anthology/D17-2019.pdf","authors":["Ori Shapira","Hadar Ronen","Meni Adler","Yael Amsterdamer","Judit Bar-Ilan","Ido Dagan"],"date":"2017/09","abstract":"We present a novel interactive summarization system that is based on abstractive summarization, derived from a recent consolidated knowledge representation for multiple texts. We incorporate a couple of interaction mechanisms, providing a bullet-style summary while allowing to attain the most important information first and interactively drill down to more specific details. A usability study of our implementation, for event news tweets, suggests the utility of our approach for text exploration."},{"id":"1bc411ae87a402f0753e6a3a466c2ef6.html","title":"Universal Joint Morph-Syntactic Processing: The Open University of Israel\u2019s Submission to The CoNLL 2017 Shared Task","url":"https://www.aclweb.org/anthology/K17-3027.pdf","authors":["Amir More","Reut Tsarfaty"],"date":"2017/08","abstract":"We present the Open University\u2019s submission to the CoNLL 2017 Shared Task on multilingual parsing from raw text to Universal Dependencies. The core of our system is a joint morphological disambiguator and syntactic parser which accepts morphologically analyzed surface tokens as input and returns morphologically disambiguated dependency trees as output. Our parser requires a lattice as input, so we generate morphological analyses of surface tokens using a data-driven morphological analyzer that derives its lexicon from the UD training corpora, and we rely on UDPipe for sentence segmentation and surface-level tokenization. We report our official macro-average LAS is 56.56. Although our model is not as performant as many others, it does not make use of neural networks, therefore we do not rely on word embeddings or any other data source other than the corpora themselves. In addition, we show the utility of a lexicon-backed morphological analyzer for the MRL Modern Hebrew. We use our results on Modern Hebrew to argue that the UD community should define a UD-compatible standard for access to lexical resources, which we argue is crucial for MRLs and low resource languages in particular."},{"id":"fac68f1835a3cf3d20df4074867f1ae6.html","title":"Acquiring predicate paraphrases from news tweets","url":"https://www.aclweb.org/anthology/S17-1019.pdf","authors":["Vered Shwartz","Gabriel Stanovsky","Ido Dagan"],"date":"2017/08","abstract":"We present a simple method for ever-growing extraction of predicate paraphrases from news headlines in Twitter. Analysis of the output of ten weeks of collection shows that the accuracy of paraphrases with different support levels is estimated between 60-86%. We also demonstrate that our resource is to a large extent complementary to existing resources, providing many novel paraphrases. Our resource is publicly available, continuously expanding based on daily news."},{"id":"9c186de4d20b1fa07dd4fc0f4691c764.html","title":"A simple language model based on pmi matrix approximations","url":"https://arxiv.org/abs/1707.05266","authors":["Oren Melamud","Ido Dagan","Jacob Goldberger"],"date":"2017/07/17","journal":"arXiv preprint arXiv:1707.05266","abstract":"In this study, we introduce a new approach for learning language models by training them to estimate word-context pointwise mutual information (PMI), and then deriving the desired conditional probabilities from PMI at test time. Specifically, we show that with minor modifications to word2vec\'s algorithm, we get principled language models that are closely related to the well-established Noise Contrastive Estimation (NCE) based language models. A compelling aspect of our approach is that our models are trained with the same simple negative sampling objective function that is commonly used in word2vec to learn word embeddings."},{"id":"3e6c159664cb666744f821d46e9703ff.html","title":"Controlling Linguistic Style Aspects in Neural Language Generation","url":"https://arxiv.org/abs/1707.02633","authors":["Jessica Ficler","Yoav Goldberg"],"date":"2017/07/09","journal":"arXiv preprint arXiv:1707.02633","abstract":"Most work on neural natural language generation (NNLG) focus on controlling the content of the generated text. We experiment with controlling several stylistic aspects of the generated text, in addition to its content. The method is based on conditioned RNN language model, where the desired content as well as the stylistic parameters serve as conditioning contexts. We demonstrate the approach on the movie reviews domain and show that it is successful in generating coherent sentences corresponding to the required linguistic style and content."},{"id":"635530fecedb1751200641a5fef8c20f.html","title":"Integrating deep linguistic features in factuality prediction over unified datasets","url":"https://www.aclweb.org/anthology/P17-2056.pdf","authors":["Gabriel Stanovsky","Judith Eckle-Kohler","Yevgeniy Puzikov","Ido Dagan","Iryna Gurevych"],"date":"2017/07","abstract":"Previous models for the assessment of commitment towards a predicate in a sentence (also known as factuality prediction) were trained and tested against a specific annotated dataset, subsequently limiting the generality of their results. In this work we propose an intuitive method for mapping three previously annotated corpora onto a single factuality scale, thereby enabling models to be tested across these corpora. In addition, we design a novel model for factuality prediction by first extending a previous rule-based factuality prediction system and applying it over an abstraction of dependency trees, and then using the output of this system in a supervised classifier. We show that this model outperforms previous methods on all three datasets. We make both the unified factuality corpus and our new model publicly available."},{"id":"7d38b73c1283ebb636cbd613750dad3c.html","title":"Exploring the Syntactic Abilities of RNNs with Multi-task Learning","url":"https://arxiv.org/abs/1706.03542","authors":["Emile Enguehard","Yoav Goldberg","Tal Linzen"],"date":"2017/06/12","journal":"arXiv preprint arXiv:1706.03542","abstract":"Recent work has explored the syntactic abilities of RNNs using the subject-verb agreement task, which diagnoses sensitivity to sentence structure. RNNs performed this task well in common cases, but faltered in complex sentences (Linzen et al., 2016). We test whether these errors are due to inherent limitations of the architecture or to the relatively indirect supervision provided by most agreement dependencies in a corpus. We trained a single RNN to perform both the agreement task and an additional task, either CCG supertagging or language modeling. Multi-task training led to significantly lower error rates, in particular on complex sentences, suggesting that RNNs have the ability to evolve more sophisticated syntactic representations than shown before. We also show that easily available agreement training data can improve performance on other syntactic tasks, in particular when only a limited amount of training data is available for those tasks. The multi-task paradigm can also be leveraged to inject grammatical knowledge into language models."},{"id":"dba4ab898ff36312caec5732dd097d9b.html","title":"Greedy transition-based dependency parsing with stack lstms","url":"https://www.mitpressjournals.org/doi/abs/10.1162/COLI_a_00285","authors":["Miguel Ballesteros","Chris Dyer","Yoav Goldberg","Noah A Smith"],"date":"2017/06","journal":"Computational Linguistics","abstract":"We introduce a greedy transition-based parser that learns to represent parser states using recurrent neural networks. Our primary innovation that enables us to do this efficiently is a new control structure for sequential neural networks\u2014the stack long short-term memory unit (LSTM). Like the conventional stack data structures used in transition-based parsers, elements can be pushed to or popped from the top of the stack in constant time, but, in addition, an LSTM maintains a continuous space embedding of the stack contents. Our model captures three facets of the parser\'s state: (i) unbounded look-ahead into the buffer of incoming words, (ii) the complete history of transition actions taken by the parser, and (iii) the complete contents of the stack of partially built tree fragments, including their internal structures. In addition, we compare two different word representations: (i) standard word vectors based on look-up tables\\\\xa0\u2026"},{"id":"58dbd903aff79525d80cdb2713032350.html","title":"Neural Network Methods for Natural Language Processing","url":"https://www.morganclaypool.com/doi/abs/10.2200/S00762ED1V01Y201703HLT037","authors":["Yoav Goldberg"],"date":"2017/04/17","journal":"Synthesis Lectures on Human Language Technologies","abstract":"Neural networks are a family of powerful machine learning models. This book focuses on the application of neural network models to natural language data. The first half of the book (Parts I and II) covers the basics of supervised machine learning and feed-forward neural networks, the basics of working with machine learning over language data, and the use of vector-based rather than symbolic representations for words. It also covers the computation-graph abstraction, which allows to easily define and train arbitrary neural networks, and is the basis behind the design of contemporary neural network software libraries."},{"id":"f0ddfe2e0edab00b3bc735f028c592a8.html","title":"Towards string-to-tree neural machine translation","url":"https://arxiv.org/abs/1704.04743","authors":["Roee Aharoni","Yoav Goldberg"],"date":"2017/04/16","journal":"arXiv preprint arXiv:1704.04743","abstract":"We present a simple method to incorporate syntactic information about the target language in a neural machine translation system by translating into linearized, lexicalized constituency trees. An experiment on the WMT16 German-English news translation task resulted in an improved BLEU score when compared to a syntax-agnostic NMT baseline trained on the same dataset. An analysis of the translations from the syntax-aware system shows that it performs more reordering during translation in comparison to the baseline. A small-scale human evaluation also showed an advantage to the syntax-aware system."},{"id":"ef0576e7da6d1d8be457e93f4154ee5b.html","title":"The Interplay of Semantics and Morphology in Word Embeddings","url":"https://arxiv.org/abs/1704.01938","authors":["Oded Avraham","Yoav Goldberg"],"date":"2017/04/06","journal":"arXiv preprint arXiv:1704.01938","abstract":"We explore the ability of word embeddings to capture both semantic and morphological similarity, as affected by the different types of linguistic properties (surface form, lemma, morphological tag) used to compose the representation of each word. We train several models, where each uses a different subset of these properties to compose its representations. By evaluating the models on semantic and morphological measures, we reveal some useful insights on the relationship between semantics and morphology."},{"id":"822fd5f88e3ea1a01be041aac96f4434.html","title":"A consolidated open knowledge representation for multiple texts","url":"https://www.aclweb.org/anthology/W17-0902.pdf","authors":["Rachel Wities","Vered Shwartz","Gabriel Stanovsky","Meni Adler","Ori Shapira","Shyam Upadhyay","Dan Roth","Eugenio Mart\\\\xednez-C\\\\xe1mara","Iryna Gurevych","Ido Dagan"],"date":"2017/04","abstract":"We propose to move from Open Information Extraction (OIE) ahead to Open Knowledge Representation (OKR), aiming to represent information conveyed jointly in a set of texts in an open text-based manner. We do so by consolidating OIE extractions using entity and predicate coreference, while modeling information containment between coreferring elements via lexical entailment. We suggest that generating OKR structures can be a useful step in the NLP pipeline, to give semantic applications an easy handle on consolidated information across multiple texts."},{"id":"b08a5db0e8f02c8a16bfed576eedd8b7.html","title":"Discourse Relations and Conjoined VPs: Automated Sense Recognition","url":"https://www.aclweb.org/anthology/E17-4004.pdf","authors":["Valentina Pyatkin","Bonnie Webber"],"date":"2017/04","abstract":"Sense classification of discourse relations is a sub-task of shallow discourse parsing. Discourse relations can occur both across sentences (inter-sentential) and within sentences (intra-sentential), and more than one discourse relation can hold between the same units. Using a newly available corpus of discourse-annotated intra-sentential conjoined verb phrases, we demonstrate a sequential classification pipeline for their multi-label sense classification. We assess the importance of each feature used in the classification, the feature scope, and what is lost in moving from gold standard manual parses to the output of an off-the-shelf parser."},{"id":"2c3af6251160105907ac68faf1da492e.html","title":"Improving a Strong Neural Parser with Conjunction-Specific Features","url":"https://arxiv.org/abs/1702.06733","authors":["Jessica Ficler","Yoav Goldberg"],"date":"2017/02/22","journal":"arXiv preprint arXiv:1702.06733","abstract":"While dependency parsers reach very high overall accuracy, some dependency relations are much harder than others. In particular, dependency parsers perform poorly in coordination construction (ie, correctly attaching the\\" conj\\" relation). We extend a state-of-the-art dependency parser with conjunction-specific features, focusing on the similarity between the conjuncts head words. Training the extended parser yields an improvement in\\" conj\\" attachment as well as in overall dependency parsing accuracy on the Stanford dependency conversion of the Penn TreeBank."},{"id":"7f8db3ae3290c9531048a2a2c4581980.html","title":"DyNet: The Dynamic Neural Network Toolkit","url":"https://arxiv.org/abs/1701.03980","authors":["Graham Neubig","Chris Dyer","Yoav Goldberg","Austin Matthews","Waleed Ammar","Antonios Anastasopoulos","Miguel Ballesteros","David Chiang","Daniel Clothiaux","Trevor Cohn","Kevin Duh","Manaal Faruqui","Cynthia Gan","Dan Garrette","Yangfeng Ji","Lingpeng Kong","Adhiguna Kuncoro","Gaurav Kumar","Chaitanya Malaviya","Paul Michel","Yusuke Oda","Matthew Richardson","Naomi Saphra","Swabha Swayamdipta","Pengcheng Yin"],"date":"2017/01/15","journal":"arXiv preprint arXiv:1701.03980","abstract":"We describe DyNet, a toolkit for implementing neural network models based on dynamic declaration of network structure. In the static declaration strategy that is used in toolkits like Theano, CNTK, and TensorFlow, the user first defines a computation graph (a symbolic representation of the computation), and then examples are fed into an engine that executes this computation and computes its derivatives. In DyNet\'s dynamic declaration strategy, computation graph construction is mostly transparent, being implicitly constructed by executing procedural code that computes the network outputs, and the user is free to use different network structures for each input. Dynamic declaration thus facilitates the implementation of more complicated network architectures, and DyNet is specifically designed to allow users to implement their models in a way that is idiomatic in their preferred programming language (C++ or Python). One challenge with dynamic declaration is that because the symbolic computation graph is defined anew for every training example, its construction must have low overhead. To achieve this, DyNet has an optimized C++ backend and lightweight graph representation. Experiments show that DyNet\'s speeds are faster than or comparable with static declaration toolkits, and significantly faster than Chainer, another dynamic declaration toolkit. DyNet is released open-source under the Apache 2.0 license and available at this http URL."},{"id":"0b252d2e8c3bed7ff58a951f6ffb7321.html","title":"On-the-fly operation batching in dynamic computation graphs","url":"http://papers.nips.cc/paper/6986-on-the-fly-operation-batching-in-dynamic-computation-graphs","authors":["Graham Neubig","Yoav Goldberg","Chris Dyer"],"date":"2017","abstract":"Dynamic neural networks toolkits such as PyTorch, DyNet, and Chainer offer more flexibility for implementing models that cope with data of varying dimensions and structure, relative to toolkits that operate on statically declared computations (eg, TensorFlow, CNTK, and Theano). However, existing toolkits-both static and dynamic-require that the developer organize the computations into the batches necessary for exploiting high-performance data-parallel algorithms and hardware. This batching task is generally difficult, but it becomes a major hurdle as architectures become complex. In this paper, we present an algorithm, and its implementation in the DyNet toolkit, for automatically batching operations. Developers simply write minibatch computations as aggregations of single instance computations, and the batching algorithm seamlessly executes them, on the fly, in computationally efficient batches. On a variety of tasks, we obtain throughput similar to manual batches, as well as comparable speedups over single-instance learning on architectures that are impractical to batch manually."},{"id":"1a08dc42826af15f1c33facc3fcc4626.html","title":"Neural disambiguation of causal lexical markers based on context","url":"https://www.aclweb.org/anthology/W17-6927.pdf","authors":["Eugenio Mart\\\\xednez-C\\\\xe1mara","Vered Shwartz","Iryna Gurevych","Ido Dagan"],"date":"2017","abstract":"Causation is a psychological tool of humans to understand the world and it is projected in natural language. Causation relates two events, so in order to understand the causal relation of those events and the causal reasoning of humans, the study of causality classification is required. We claim that the use of linguistic features may restrict the representation of causality, and dense vector spaces can provide a better encoding of the causal meaning of an utterance. Herein, we propose a neural network architecture only fed with word embeddings for the task of causality classification. Our results show that our claim holds, and we outperform the state-of-the-art on the AltLex corpus. The source code of our experiments is publicly available. 1"},{"id":"561a50f75224d3193420a15e2036511e.html","title":"Lingpeng Kong, Adhiguna Kuncoro, Gaurav Kumar, Chaitanya Malaviya, Paul Michel, Yusuke Oda, Matthew Richardson, Naomi Saphra, Swabha Swayamdipta, and Pengcheng Yin. 2017. Dynet\\\\xa0\u2026","url":"http://scholar.google.com/scholar?cluster=621847681578506086&hl=en&oi=scholarr","authors":["Graham Neubig","Chris Dyer","Yoav Goldberg","Austin Matthews","Waleed Ammar","Antonios Anastasopoulos","Miguel Ballesteros","David Chiang","Daniel Clothiaux","Trevor Cohn","Kevin Duh","Manaal Faruqui","Cynthia Gan","Dan Garrette","Yangfeng Ji"],"date":"2017","journal":"arXiv preprint arXiv:1701.03980"},{"id":"87917c098f7cc906640e2b541f793e93.html","title":"Morphological Inflection Generation with Hard Monotonic Attention","url":"https://arxiv.org/abs/1611.01487","authors":["Roee Aharoni","Yoav Goldberg","Israel Ramat-Gan"],"date":"2017","journal":"Proceedings of ACL. https://arxiv. org/abs/1611.01487","abstract":"We present a neural model for morphological inflection generation which employs a hard attention mechanism, inspired by the nearly-monotonic alignment commonly found between the characters in a word and the characters in its inflection. We evaluate the model on three previously studied morphological inflection generation datasets and show that it provides state of the art results in various setups compared to previous neural and non-neural approaches. Finally we present an analysis of the continuous representations learned by both the hard and soft attention\\\\\\\\cite {bahdanauCB14} models for the task, shedding some light on the features such models extract."},{"id":"abd6de4d9aece33e1820bedfc46b1d21.html","title":"The recognizing textual entailment challenges: Datasets and methodologies","url":"https://link.springer.com/chapter/10.1007/978-94-024-0881-2_42","authors":["Luisa Bentivogli","Ido Dagan","Bernardo Magnini"],"date":"2017","abstract":"While semantic inference has always been a major focus in Computational Linguistics, the topic has benefited of new attention in the field thanks to the Recognizing Textual Entailment (RTE) framework, first launched in 2004, which has provided an operational definition of entailment based on human judgements over portions of text. On top of such definition, a task has been designed, which includes both guidelines for dataset annotation and evaluation metrics for assessing systems\u2019 performance. This chapter presents the successful experience of creating Textual Entailment datasets. We show how, during the years, RTE datasets have been developed in several variants, not only to address complex phenomena underlying entailment, but also to demonstrate the potential application of entailment inference into concrete scenarios, including summarization, knowledge base population, answer validation for\\\\xa0\u2026"},{"id":"af0513286e02ffbdfac8a5502ba91dc2.html","title":"From Raw Text to Universal Dependencies-Look, No Tags!","url":"https://www.aclweb.org/anthology/K17-3022.pdf","authors":["Miryam de Lhoneux","Yan Shao","Ali Basirat","Eliyahu Kiperwasser","Sara Stymne","Yoav Goldberg","Joakim Nivre"],"date":"2017","journal":"Proceedings of the CoNLL 2017 Shared Task: Multilingual Parsing from Raw Text to Universal Dependencies","abstract":"We present the Uppsala submission to the CoNLL 2017 shared task on parsing from raw text to universal dependencies. Our system is a simple pipeline consisting of two components. The first performs joint word and sentence segmentation on raw text; the second predicts dependency trees from raw words. The parser bypasses the need for part-of-speech tagging, but uses word embeddings based on universal tag distributions. We achieved a macro-averaged LAS F1 of 65.11 in the official test run, which improved to 70.49 after bug fixes. We obtained the 2nd best result for sentence segmentation with a score of 89.03."},{"id":"e00570c3cac9997af6201418199dacb9.html","title":"Proceedings of the 2nd Workshop on Evaluating Vector Space Representations for NLP","url":"https://www.aclweb.org/anthology/W17-5300.pdf","authors":["Samuel Bowman","Yoav Goldberg","Felix Hill","Angeliki Lazaridou","Omer Levy","Roi Reichart","Anders S\\\\xf8gaard"],"date":"2017","journal":"Proceedings of the 2nd Workshop on Evaluating Vector Space Representations for NLP","abstract":"This workshop deals with the evaluation of general-purpose vector representations for linguistic units (morphemes, words, phrases, sentences, etc). What distinguishes these representations (or embeddings) is that they are not trained with a specific application in mind, but rather to capture broadly useful features of the represented units. Another way to view their usage is through the lens of transfer learning: The embeddings are trained with one objective, but applied on others."},{"id":"fd25fed5796983cd4473cdb9553fc536.html","title":"Data-driven broad-coverage grammars for opinionated natural language generation (onlg)","url":"https://repository.ubn.ru.nl/bitstream/handle/2066/179462/179462pub.pdf","authors":["Tomer Cagan","Stefan L Frank","Reut Tsarfaty"],"date":"2017","abstract":"Opinionated natural language generation (ONLG) is a new, challenging, NLG task in which we aim to automatically generate human-like, subjective, responses to opinionated articles online. We present a data-driven architecture for ONLG that generates subjective responses triggered by users\u2019 agendas, based on automatically acquired wide-coverage generative grammars. We compare three types of grammatical representations that we design for ONLG. The grammars interleave different layers of linguistic information, and are induced from a new, enriched dataset we developed. Our evaluation shows that generation with Relational-Realizational (Tsarfaty and Sima\u2019an, 2008) inspired grammar gets better language model scores than lexicalized grammarsa la Collins (2003), and that the latter gets better humanevaluation scores. We also show that conditioning the generation on topic models makes generated responses more relevant to the document content."},{"id":"4c8f011e76ec3c29d8e3026c7ca1fb19.html","title":"Semiautomatic construction of cross-period thesaurus","url":"https://dl.acm.org/doi/abs/10.1145/2994151","authors":["Chaya Liebeskind","Ido Dagan","Jonathan Schler"],"date":"2016/12/19","journal":"Journal on Computing and Cultural Heritage (JOCCH)","abstract":"A cross-period (diachronic) thesaurus enables users to search for information using modern terminology and obtain semantically related terms from earlier historical periods. The complex task of supporting the construction of a diachronic thesaurus by a domain expert lexicographer has hardly been addressed computationally until now. In this article, we introduce a semiautomatic iterative Query Expansion (QE) scheme for supporting diachronic thesaurus construction, which identifies candidate related terms based on statistical corpus-based measures. We use ancient-modern period classification to increase the performance of the statistical cooccurrence measures and extend our methods to deal with <i>Multi-Word Expressions</i> (MWEs). We demonstrate the empirical benefit of our scheme for a Jewish cross-period thesaurus and evaluate its impact on recall and on the effectiveness of the lexicographer\u2019s manual efforts."},{"id":"5612ce7247231fcf6009b26236e85546.html","title":"Semi supervised preposition-sense disambiguation using multilingual data","url":"https://www.aclweb.org/anthology/C16-1256.pdf","authors":["Hila Gonen","Yoav Goldberg"],"date":"2016/12","abstract":"Prepositions are very common and very ambiguous, and understanding their sense is critical for understanding the meaning of the sentence. Supervised corpora for the preposition-sense disambiguation task are small, suggesting a semi-supervised approach to the task. We show that signals from unannotated multilingual data can be used to improve supervised preposition-sense disambiguation. Our approach pre-trains an LSTM encoder for predicting the translation of a preposition, and then incorporates the pre-trained encoder as a component in a supervised classification system, and fine-tunes it for the task. The multilingual signals consistently improve results on two preposition-sense datasets."},{"id":"61d02d04db4f7d51ca2cbe0f39005bda.html","title":"Simple and accurate dependency parsing using bidirectional LSTM feature representations","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00101","authors":["Eliyahu Kiperwasser","Yoav Goldberg"],"date":"2016/12","journal":"Transactions of the Association for Computational Linguistics","abstract":"We present a simple and effective scheme for dependency parsing which is based on bidirectional-LSTMs (BiLSTMs). Each sentence token is associated with a BiLSTM vector representing the token in its sentential context, and feature vectors are constructed by concatenating a few BiLSTM vectors. The BiLSTM is trained jointly with the parser objective, resulting in very effective feature extractors for parsing. We demonstrate the effectiveness of the approach by applying it to a greedy transition-based parser as well as to a globally optimized graph-based parser. The resulting parsers have very simple architectures, and match or surpass the state-of-the-art accuracies on English and Chinese."},{"id":"7050c1c99123b8aea8ded93fa66310c9.html","title":"Easy-first dependency parsing with hierarchical tree LSTMs","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00110","authors":["Eliyahu Kiperwasser","Yoav Goldberg"],"date":"2016/12","journal":"Transactions of the Association for Computational Linguistics","abstract":"We suggest a compositional vector representation of parse trees that relies on a recursive combination of recurrent-neural network encoders. To demonstrate its effectiveness, we use the representation as the backbone of a greedy, bottom-up dependency parser, achieving very strong accuracies for English and Chinese, without relying on external word embeddings. The parser\u2019s implementation is available for download at the first author\u2019s webpage."},{"id":"bf8b392308d588cf381497a20da0ac18.html","title":"Modeling extractive sentence intersection via subtree entailment","url":"https://www.aclweb.org/anthology/C16-1272.pdf","authors":["Omer Levy","Ido Dagan","Gabriel Stanovsky","Judith Eckle-Kohler","Iryna Gurevych"],"date":"2016/12","abstract":"Sentence intersection captures the semantic overlap of two texts, generalizing over paradigms such as textual entailment and semantic text similarity. Despite its modeling power, it has received little attention because it is difficult for non-experts to annotate. We analyze 200 pairs of similar sentences and identify several underlying properties of sentence intersection. We leverage these insights to design an algorithm that decomposes the sentence intersection task into several simpler annotation tasks, facilitating the construction of a high quality dataset via crowdsourcing. We implement this approach and provide an annotated dataset of 1,764 sentence intersections."},{"id":"cfac7fee6bf1a683658c4f6b9f8786d9.html","title":"Data-driven morphological analysis and disambiguation for morphologically rich languages and universal dependencies","url":"https://www.aclweb.org/anthology/C16-1033.pdf","authors":["Amir More","Reut Tsarfaty"],"date":"2016/12","abstract":"Parsing texts into universal dependencies (UD) in realistic scenarios requires infrastructure for the morphological analysis and disambiguation (MA&D) of typologically different languages as a first tier. MA&D is particularly challenging in morphologically rich languages (MRLs), where the ambiguous space-delimited tokens ought to be disambiguated with respect to their constituent morphemes, each morpheme carrying its own tag and a rich set features. Here we present a novel, language-agnostic, framework for MA&D, based on a transition system with two variants\u2014word-based and morpheme-based\u2014and a dedicated transition to mitigate the biases of variable-length morpheme sequences. Our experiments on a Modern Hebrew case study show state of the art results, and we show that the morpheme-based MD consistently outperforms our word-based variant. We further illustrate the utility and multilingual coverage of our framework by morphologically analyzing and disambiguating the large set of languages in the UD treebanks."},{"id":"fdb3390c52a3dd222fc883df64322fc0.html","title":"Assessing the ability of LSTMs to learn syntax-sensitive dependencies","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00115","authors":["Tal Linzen","Emmanuel Dupoux","Yoav Goldberg"],"date":"2016/12","journal":"Transactions of the Association for Computational Linguistics","abstract":"The success of long short-term memory (LSTM) neural networks in language processing is typically attributed to their ability to capture long-distance statistical regularities. Linguistic regularities are often sensitive to syntactic structure; can such dependencies be captured by LSTMs, which do not have explicit structural representations? We begin addressing this question using number agreement in English subject-verb dependencies. We probe the architecture\u2019s grammatical competence both using training objectives with an explicit grammatical target (number prediction, grammaticality judgments) and using language models. In the strongly supervised settings, the LSTM achieved very high overall accuracy (less than 1% errors), but errors increased when sequential and structural information conflicted\\\\xa0\u2026"},{"id":"4fddef8b611b40b2ddecf5d38a16579e.html","title":"Improving Reliability of Word Similarity Evaluation by Redesigning Annotation Task and Performance Measure","url":"https://arxiv.org/abs/1611.03641","authors":["Oded Avraham","Yoav Goldberg"],"date":"2016/11/11","journal":"arXiv preprint arXiv:1611.03641","abstract":"We suggest a new method for creating and using gold-standard datasets for word similarity evaluation. Our goal is to improve the reliability of the evaluation, and we do this by redesigning the annotation task to achieve higher inter-rater agreement, and by defining a performance measure which takes the reliability of each annotation decision in the dataset into account."},{"id":"50dd47cebbb2014bda7d43be302a369d.html","title":"Sequence to Sequence Transduction with Hard Monotonic Attention","url":"https://openreview.net/forum?id=HkyYqU9lx","authors":["Roee Aharoni","Yoav Goldberg"],"date":"2016/11/04","journal":"arXiv preprint arXiv:1611.01487","abstract":"We present a supervised sequence to sequence transduction model with a hard attention mechanism which combines the more traditional statistical alignment methods with the power of recurrent neural networks. We evaluate the model on the task of morphological inflection generation and show that it provides state of the art results in various setups compared to the previous neural and non-neural approaches. Eventually we present an analysis of the learned representations for both hard and soft attention models, shedding light on the features such models extract in order to solve the task."},{"id":"56168c4831e2d56bac388ac3728b6420.html","title":"Creating a large benchmark for open information extraction","url":"https://www.aclweb.org/anthology/D16-1252.pdf","authors":["Gabriel Stanovsky","Ido Dagan"],"date":"2016/11","abstract":"Open information extraction (Open IE) was presented as an unrestricted variant of traditional information extraction. It has been gaining substantial attention, manifested by a large number of automatic Open IE extractors and downstream applications. In spite of this broad attention, the Open IE task definition has been lacking\u2013there are no formal guidelines and no large scale gold standard annotation. Subsequently, the various implementations of Open IE resorted to small scale posthoc evaluations, inhibiting an objective and reproducible cross-system comparison. In this work, we develop a methodology that leverages the recent QA-SRL annotation to create a first independent and large scale Open IE annotation, 1 and use it to automatically compare the most prominent Open IE systems."},{"id":"7c03be62f4f86e343924fb5691bf996e.html","title":"Porting an open information extraction system from english to german","url":"https://www.aclweb.org/anthology/D16-1086.pdf","authors":["Tobias Falke","Gabriel Stanovsky","Iryna Gurevych","Ido Dagan"],"date":"2016/11","abstract":"Many downstream NLP tasks can benefit from Open Information Extraction (Open IE) as a semantic representation. While Open IE systems are available for English, many other languages lack such tools. In this paper, we present a straightforward approach for adapting PropS, a rule-based predicate-argument analysis for English, to a new language, German. With this approach, we quickly obtain an Open IE system for German covering 89% of the English rule set. It yields 1.6 n-ary extractions per sentence at 60% precision, making it comparable to systems for English and readily usable in downstream applications. 1"},{"id":"83402dede2e26ad9f97a4e621ef04dcc.html","title":"Practical Neural Networks for NLP: From Theory to Code","url":"https://www.aclweb.org/anthology/papers/D/D16/D16-2001/","authors":["Chris Dyer","Yoav Goldberg","Graham Neubig"],"date":"2016/11","abstract":"This tutorial aims to bring NLP researchers up to speed with the current techniques in deep learning and neural networks, and show them how they can turn their ideas into practical implementations. We will start with simple classification models (logistic regression and multilayer perceptrons) and cover more advanced patterns that come up in NLP such as recurrent networks for sequence tagging and prediction problems, structured networks (eg, compositional architectures based on syntax trees), structured output spaces (sequences and trees), attention for sequence-to-sequence transduction, and feature induction for complex algorithm states. A particular emphasis will be on learning to represent complex objects as recursive compositions of simpler objects. This representation will reflect characterize standard objects in NLP, such as the composition of characters and morphemes into words, and words into sentences and documents. In addition, new opportunities such as learning to embed\\" algorithm states\\" such as those used in transition-based parsing and other sequential structured prediction models (for which effective features may be difficult to engineer by hand) will be covered. Everything in the tutorial will be grounded in code\u2014we will show how to program seemingly complex neural-net models using toolkits based on the computation-graph formalism. Computation graphs decompose complex computations into a DAG, with nodes representing inputs, target outputs, parameters, or (sub) differentiable functions (eg,\\" tanh\\",\\" matrix multiply\\", and\\" softmax\\"), and edges represent data dependencies. These graphs can be run\\" forward\\" to\\\\xa0\u2026"},{"id":"afb3e30acd26c014d7dc3d76d60c0152.html","title":"Cogalex-v shared task: Lexnet-integrated path-based and distributional method for the identification of semantic relations","url":"https://arxiv.org/abs/1610.08694","authors":["Vered Shwartz","Ido Dagan"],"date":"2016/10/27","journal":"arXiv preprint arXiv:1610.08694","abstract":"We present a submission to the CogALex 2016 shared task on the corpus-based identification of semantic relations, using LexNET (Shwartz and Dagan, 2016), an integrated path-based and distributional method for semantic relation classification. The reported results in the shared task bring this submission to the third place on subtask 1 (word relatedness), and the first place on subtask 2 (semantic relation classification), demonstrating the utility of integrating the complementary path-based and distributional information sources in recognizing concrete semantic relations. Combined with a common similarity measure, LexNET performs fairly good on the word relatedness task (subtask 1). The relatively low performance of LexNET and all other systems on subtask 2, however, confirms the difficulty of the semantic relation classification task, and stresses the need to develop additional methods for this task."},{"id":"e4f4c39cfa17e3b92b4598b1541b920f.html","title":"A Neural Network for Coordination Boundary Prediction","url":"https://arxiv.org/abs/1610.03946","authors":["Jessica Ficler","Yoav Goldberg"],"date":"2016/10/13","journal":"arXiv preprint arXiv:1610.03946","abstract":"We propose a neural-network based model for coordination boundary prediction. The network is designed to incorporate two signals: the similarity between conjuncts and the observation that replacing the whole coordination phrase with a conjunct tends to produce a coherent sentences. The modeling makes use of several LSTM networks. The model is trained solely on conjunction annotations in a Treebank, without using external resources. We show improvements on predicting coordination boundaries on the PTB compared to two state-of-the-art parsers; as well as improvement over previous coordination boundary prediction systems on the Genia corpus."},{"id":"5160ec58a9933e6a3bcfc327e3f3b4c2.html","title":"PMI matrix approximations with applications to neural language modeling","url":"https://arxiv.org/abs/1609.01235","authors":["Oren Melamud","Ido Dagan","Jacob Goldberger"],"date":"2016/09/05","journal":"arXiv preprint arXiv:1609.01235","abstract":"The negative sampling (NEG) objective function, used in word2vec, is a simplification of the Noise Contrastive Estimation (NCE) method. NEG was found to be highly effective in learning continuous word representations. However, unlike NCE, it was considered inapplicable for the purpose of learning the parameters of a language model. In this study, we refute this assertion by providing a principled derivation for NEG-based language modeling, founded on a novel analysis of a low-dimensional approximation of the matrix of pointwise mutual information between the contexts and the predicted words. The obtained language modeling is closely related to NCE language models but is based on a simplified objective function. We thus provide a unified formulation for two main language processing tasks, namely word embedding and language modeling, based on the NEG objective function. Experimental results on two popular language modeling benchmarks show comparable perplexity results, with a small advantage to NEG over NCE."},{"id":"083be3210e45be510bc54d472a3719dc.html","title":"Reconsidering Cross-lingual Word Embeddings","url":"http://scholar.google.com/scholar?cluster=14857846587367814311&hl=en&oi=scholarr","authors":["Omer Levy","Anders S\\\\xf8gaard","Yoav Goldberg"],"date":"2016/08/18","journal":"arXiv preprint arXiv:1608.05426","abstract":"While cross-lingual word embeddings have been studied extensively in recent years, the qualitative differences between the different algorithms remains vague. We observe that whether or not an algorithm uses a particular feature set (sentence IDs) accounts for a significant performance gap among these algorithms. This feature set is also used by traditional alignment algorithms, such as IBM Model-1, which demonstrate similar performance to state-of-the-art embedding algorithms on a variety of benchmarks. Overall, we observe that different algorithmic approaches for utilizing the sentence ID feature space result in similar performance. This paper draws both empirical and theoretical parallels between the embedding and alignment literature, and suggests that adding additional sources of information, which go beyond the traditional signal of bilingual sentence-aligned corpora, is an appealing approach for\\\\xa0\u2026"},{"id":"0afaaece9fc41eecccccb7d105d41158.html","title":"Path-based vs. distributional information in recognizing lexical semantic relations","url":"https://arxiv.org/abs/1608.05014","authors":["Vered Shwartz","Ido Dagan"],"date":"2016/08/17","journal":"arXiv preprint arXiv:1608.05014","abstract":"Recognizing various semantic relations between terms is beneficial for many NLP tasks. While path-based and distributional information sources are considered complementary for this task, the superior results the latter showed recently suggested that the former\'s contribution might have become obsolete. We follow the recent success of an integrated neural method for hypernymy detection (Shwartz et al., 2016) and extend it to recognize multiple relations. The empirical results show that this method is effective in the multiclass setting as well. We further show that the path-based information source always contributes to the classification, and analyze the cases in which it mostly complements the distributional information."},{"id":"cd04754ef59f9fb378cb7f86c4ccabd4.html","title":"Fine-grained Analysis of Sentence Embeddings Using Auxiliary Prediction Tasks","url":"https://arxiv.org/abs/1608.04207","authors":["Yossi Adi","Einat Kermany","Yonatan Belinkov","Ofer Lavi","Yoav Goldberg"],"date":"2016/08/15","journal":"arXiv preprint arXiv:1608.04207","abstract":"There is a lot of research interest in encoding variable length sentences into fixed length vectors, in a way that preserves the sentence meanings. Two common methods include representations based on averaging word vectors, and representations based on the hidden states of recurrent neural networks such as LSTMs. The sentence vectors are used as features for subsequent machine learning tasks or for pre-training in the context of deep learning. However, not much is known about the properties that are encoded in these sentence representations and about the language information they capture. We propose a framework that facilitates better understanding of the encoded representations. We define prediction tasks around isolated aspects of sentence structure (namely sentence length, word content, and word order), and score representations by the ability to train a classifier to solve each prediction task when using the representation as input. We demonstrate the potential contribution of the approach by analyzing different sentence representation mechanisms. The analysis sheds light on the relative strengths of different sentence embedding methods with respect to these low level prediction tasks, and on the effect of the encoded vector\'s dimensionality on the resulting representations."},{"id":"1dc97fe8e1e28622e52b11dbf208648c.html","title":"Improving sequence to sequence learning for morphological inflection generation: The BIU-MIT systems for the SIGMORPHON 2016 shared task for morphological reinflection","url":"https://www.aclweb.org/anthology/W16-2007.pdf","authors":["Roee Aharoni","Yoav Goldberg","Yonatan Belinkov"],"date":"2016/08","abstract":"Morphological reinflection is the task of generating a target form given a source form and the morpho-syntactic attributes of the target (and, optionally, of the source). This work presents the submission of Bar Ilan University and the Massachusetts Institute of Technology for the morphological reinflection shared task held at SIGMORPHON 2016. The submission includes two recurrent neural network architectures for learning morphological reinflection from incomplete inflection tables while using several novel ideas for this task: morpho-syntactic attribute embeddings, modeling the concept of templatic morphology, bidirectional input character representations and neural discriminative string transduction. The reported results for the proposed models over the ten languages in the shared task bring this submission to the second/third place (depending on the language) on all three sub-tasks out of eight participating teams, while training only on the Restricted category data."},{"id":"51fcbb29938b1e41d56ae85795d2a468.html","title":"Annotating and predicting non-restrictive noun phrase modifications","url":"https://www.aclweb.org/anthology/P16-1119.pdf","authors":["Gabriel Stanovsky","Ido Dagan"],"date":"2016/08","abstract":"The distinction between restrictive and non-restrictive modification in noun phrases is a well studied subject in linguistics. Automatically identifying non-restrictive modifiers can provide NLP applications with shorter, more salient arguments, which were found beneficial by several recent works. While previous work showed that restrictiveness can be annotated with high agreement, no large scale corpus was created, hindering the development of suitable classification algorithms. In this work we devise a novel crowdsourcing annotation methodology, and an accompanying large scale corpus. Then, we present a robust automated system which identifies non-restrictive modifiers, notably improving over prior methods."},{"id":"55d5ca8a80cf23345d45bdeee0122eae.html","title":"Specifying and annotating reduced argument span via qa-srl","url":"https://www.aclweb.org/anthology/P16-2077.pdf","authors":["Gabriel Stanovsky","Ido Dagan","Meni Adler"],"date":"2016/08","abstract":"Prominent semantic annotations take an inclusive approach to argument span annotation, marking arguments as full constituency subtrees. Some works, however, showed that identifying a reduced argument span can be beneficial for various semantic tasks. While certain practical methods do extract reduced argument spans, such as in Open-IE, these solutions are often ad-hoc and system-dependent, with no commonly accepted standards. In this paper we propose a generic argument reduction criterion, along with an annotation procedure, and show that it can be consistently and intuitively annotated using the recent QA-SRL paradigm."},{"id":"5e0e0f29ec180585ba119b6f101b41e1.html","title":"context2vec: Learning generic context embedding with bidirectional lstm","url":"https://www.aclweb.org/anthology/K16-1006.pdf","authors":["Oren Melamud","Jacob Goldberger","Ido Dagan"],"date":"2016/08","abstract":"Context representations are central to various NLP tasks, such as word sense disambiguation, named entity recognition, coreference resolution, and many more. In this work we present a neural model for efficiently learning a generic context embedding function from large corpora, using bidirectional LSTM. With a very simple application of our context representations, we manage to surpass or nearly reach state-of-the-art results on sentence completion, lexical substitution and word sense disambiguation tasks, while substantially outperforming the popular context representation of averaged word embeddings. We release our code and pretrained models, suggesting they could be useful in a wide variety of NLP tasks."},{"id":"a83698eea977b04862a98b2e3dbb0bf0.html","title":"A Strong Baseline for Learning Cross-Lingual Word Embeddings from Sentence Alignments","url":"https://arxiv.org/abs/1608.05426","authors":["Omer Levy","Anders S\\\\xf8gaard","Yoav Goldberg"],"date":"2016/08","journal":"arXiv preprint arXiv:1608.05426","abstract":"While cross-lingual word embeddings have been studied extensively in recent years, the qualitative differences between the different algorithms remain vague. We observe that whether or not an algorithm uses a particular feature set (sentence IDs) accounts for a significant performance gap among these algorithms. This feature set is also used by traditional alignment algorithms, such as IBM Model-1, which demonstrate similar performance to state-of-the-art embedding algorithms on a variety of benchmarks. Overall, we observe that different algorithmic approaches for utilizing the sentence ID feature space result in similar performance. This paper draws both empirical and theoretical parallels between the embedding and alignment literature, and suggests that adding additional sources of information, which go beyond the traditional signal of bilingual sentence-aligned corpora, may substantially improve cross-lingual word embeddings, and that future baselines should at least take such features into account."},{"id":"aded7b6453938f3ef1195a357f268014.html","title":"Annotating relation inference in context via question answering","url":"https://www.aclweb.org/anthology/P16-2041.pdf","authors":["Omer Levy","Ido Dagan"],"date":"2016/08","abstract":"We present a new annotation method for collecting data on relation inference in context. We convert the inference task to one of simple factoid question answering, allowing us to easily scale up to 16,000 high-quality examples. Our method corrects a major bias in previous evaluations, making our dataset much more realistic."},{"id":"cacee9ce2a9dfb6c3ab9939c313696b6.html","title":"Deep multi-task learning with low level tasks supervised at lower layers","url":"https://www.aclweb.org/anthology/P16-2038.pdf","authors":["Anders S\\\\xf8gaard","Yoav Goldberg"],"date":"2016/08","abstract":"In all previous work on deep multi-task learning we are aware of, all task supervisions are on the same (outermost) layer. We present a multi-task learning architecture with deep bi-directional RNNs, where different tasks supervision can happen at different layers. We present experiments in syntactic chunking and CCG supertagging, coupled with the additional task of POS-tagging. We show that it is consistently better to have POS supervision at the innermost rather than the outermost layer. We argue that this is because \u201clowlevel\u201d tasks are better kept at the lower layers, enabling the higher-level tasks to make use of the shared representation of the lower-level tasks. Finally, we also show how this architecture can be used for domain adaptation."},{"id":"d19cc96c26d29ee2cbac4a87c430a32b.html","title":"Adding context to semantic data-driven paraphrasing","url":"https://www.aclweb.org/anthology/S16-2013.pdf","authors":["Vered Shwartz","Ido Dagan"],"date":"2016/08","abstract":"Recognizing lexical inferences between pairs of terms is a common task in NLP applications, which should typically be performed within a given context. Such context-sensitive inferences have to consider both term meaning in context as well as the fine-grained relation holding between the terms. Hence, to develop suitable lexical inference methods, we need datasets that are annotated with fine-grained semantic relations in-context. Since existing datasets either provide outof-context annotations or refer to coarsegrained relations, we propose a methodology for adding context-sensitive annotations. We demonstrate our methodology by applying it to phrase pairs from PPDB 2.0, creating a novel dataset of finegrained lexical inferences in-context and showing its utility in developing contextsensitive methods."},{"id":"e9d55a18cc7916e84a7452ee80a4b545.html","title":"The roles of pathbased and distributional information in recognizing lexical semantic relations","url":"http://scholar.google.com/scholar?cluster=15843396639655447207&hl=en&oi=scholarr","authors":["Vered Shwartz","Ido Dagan"],"date":"2016/08","journal":"CoRR, abs/1608.05014","abstract":"Recognizing various semantic relations between terms is crucial for many NLP tasks. While path-based and distributional information sources are considered complementary, the strong results the latter showed on recent datasets suggested that the former\u2019s contribution might have become obsolete. We follow the recent success of an integrated neural method for hypernymy detection (Shwartz et al., 2016) and extend it to recognize multiple relations. We demonstrate that these two information sources are indeed complementary, and analyze the contributions of each source."},{"id":"ad80f56895c00a5bcd6ea378c25922d6.html","title":"Coordination Annotation Extension in the Penn Tree Bank","url":"https://arxiv.org/abs/1606.02529","authors":["Jessica Ficler","Yoav Goldberg"],"date":"2016/06/08","journal":"arXiv preprint arXiv:1606.02529","abstract":"Coordination is an important and common syntactic construction which is not handled well by state of the art parsers. Coordinations in the Penn Treebank are missing internal structure in many cases, do not include explicit marking of the conjuncts and contain various errors and inconsistencies. In this work, we initiated manual annotation process for solving these issues. We identify the different elements in a coordination phrase and label each element with its function. We add phrase boundaries when these are missing, unify inconsistencies, and fix errors. The outcome is an extension of the PTB that includes consistent and detailed structures for coordinations. We make the coordination annotation publicly available, in hope that they will facilitate further research into coordination disambiguation."},{"id":"7afeec32c3749f5544f22d221a250c85.html","title":"Improved Parsing for Argument-Clusters Coordination","url":"https://arxiv.org/abs/1606.00294","authors":["Jessica Ficler","Yoav Goldberg"],"date":"2016/06/01","journal":"arXiv preprint arXiv:1606.00294","abstract":"Syntactic parsers perform poorly in prediction of Argument-Cluster Coordination (ACC). We change the PTB representation of ACC to be more suitable for learning by a statistical PCFG parser, affecting 125 trees in the training set. Training on the modified trees yields a slight improvement in EVALB scores on sections 22 and 23. The main evaluation is on a corpus of 4th grade science exams, in which ACC structures are prevalent. On this corpus, we obtain an impressive x2. 7 improvement in recovering ACC structures compared to a parser trained on the original PTB trees."},{"id":"14767cdc9040ff0112915cb824ea1d1e.html","title":"The negochat corpus of human-agent negotiation dialogues","url":"https://www.aclweb.org/anthology/L16-1501.pdf","authors":["Vasily Konovalov","Ron Artstein","Oren Melamud","Ido Dagan"],"date":"2016/05","abstract":"Annotated in-domain corpora are crucial to the successful development of dialogue systems of automated agents, and in particular for developing natural language understanding (NLU) components of such systems. Unfortunately, such important resources are scarce. In this work, we introduce an annotated natural language human-agent dialogue corpus in the negotiation domain. The corpus was collected using Amazon Mechanical Turk following the \u2018Wizard-Of-Oz\u2019approach, where a \u2018wizard\u2019human translates the participants\u2019 natural language utterances in real time into a semantic language. Once dialogue collection was completed, utterances were annotated with intent labels by two independent annotators, achieving high inter-annotator agreement. Our initial experiments with an SVM classifier show that automatically inferring such labels from the utterances is far from trivial. We make our corpus publicly available to serve as an aid in the development of dialogue systems for negotiation agents, and suggest that analogous corpora can be created following our methodology and using our available source code. To the best of our knowledge this is the first publicly available negotiation dialogue corpus."},{"id":"3e2de6f4ba5f4ccdaa91411229ea2948.html","title":"Universal dependencies v1: A multilingual treebank collection","url":"https://www.aclweb.org/anthology/L16-1262.pdf","authors":["Joakim Nivre","Marie-Catherine De Marneffe","Filip Ginter","Yoav Goldberg","Jan Hajic","Christopher D Manning","Ryan McDonald","Slav Petrov","Sampo Pyysalo","Natalia Silveira","Reut Tsarfaty","Daniel Zeman"],"date":"2016/05","abstract":"Cross-linguistically consistent annotation is necessary for sound comparative evaluation and cross-lingual learning experiments. It is also useful for multilingual system development and comparative linguistic studies. Universal Dependencies is an open community effort to create cross-linguistically consistent treebank annotation for many languages within a dependency-based lexicalist framework. In this paper, we describe v1 of the universal guidelines, the underlying design principles, and the currently available treebanks for 33 languages."},{"id":"2c3028a6234639303d14f67121ddfe42.html","title":"Multilingual Part-of-Speech Tagging with Bidirectional Long Short-Term Memory Models and Auxiliary Loss","url":"https://arxiv.org/abs/1604.05529","authors":["Barbara Plank","Anders S\\\\xf8gaard","Yoav Goldberg"],"date":"2016/04/19","journal":"arXiv preprint arXiv:1604.05529","abstract":"Bidirectional long short-term memory (bi-LSTM) networks have recently proven successful for various NLP sequence modeling tasks, but little is known about their reliance to input representations, target languages, data set size, and label noise. We address these issues and evaluate bi-LSTMs with word, character, and unicode byte embeddings for POS tagging. We compare bi-LSTMs to traditional POS taggers across languages and data sizes. We also present a novel bi-LSTM model, which combines the POS tagging loss function with an auxiliary loss function that accounts for rare words. The model obtains state-of-the-art performance across 22 languages, and works especially well for morphologically complex languages. Our analysis suggests that bi-LSTMs are less sensitive to training data size and label corruptions (at small noise levels) than previously assumed."},{"id":"29ad19018791b8b3c422023b98ff620b.html","title":"Improving sentence compression by learning to predict gaze","url":"https://arxiv.org/abs/1604.03357","authors":["Sigrid Klerke","Yoav Goldberg","Anders S\\\\xf8gaard"],"date":"2016/04/12","journal":"arXiv preprint arXiv:1604.03357","abstract":"We show how eye-tracking corpora can be used to improve sentence compression models, presenting a novel multi-task learning algorithm based on multi-layer LSTMs. We obtain performance competitive with or better than state-of-the-art approaches."},{"id":"05e0f20305ec11dab83b5668ba1c55ba.html","title":"Training with Exploration Improves a Greedy Stack-LSTM Parser","url":"https://arxiv.org/abs/1603.03793","authors":["Miguel Ballesteros","Yoav Goldberg","Chris Dyer","Noah A Smith"],"date":"2016/03/11","journal":"arXiv preprint arXiv:1603.03793","abstract":"We adapt the greedy Stack-LSTM dependency parser of Dyer et al.(2015) to support a training-with-exploration procedure using dynamic oracles (Goldberg and Nivre, 2013) instead of cross-entropy minimization. This form of training, which accounts for model predictions at training time rather than assuming an error-free action history, improves parsing accuracies for both English and Chinese, obtaining very strong results for both languages. We discuss some modifications needed in order to get training with exploration to work well for a probabilistic neural-network."},{"id":"be4d55b5379f1c14f62fdf21f2a48b10.html","title":"Getting More Out Of Syntax with PropS","url":"https://arxiv.org/abs/1603.01648","authors":["Gabriel Stanovsky","Jessica Ficler","Ido Dagan","Yoav Goldberg"],"date":"2016/03/04","journal":"arXiv preprint arXiv:1603.01648","abstract":"Semantic NLP applications often rely on dependency trees to recognize major elements of the proposition structure of sentences. Yet, while much semantic structure is indeed expressed by syntax, many phenomena are not easily read out of dependency trees, often leading to further ad-hoc heuristic post-processing or to information loss. To directly address the needs of semantic applications, we present PropS--an output representation designed to explicitly and uniformly express much of the proposition structure which is implied from syntax, and an associated tool for extracting it from dependency trees."},{"id":"ac3d0d767fd767737cbf7bf8fb1a00c0.html","title":"The Reciprocity-Symmetry Generalization: Proto-Roles and the Organization of Lexical Meanings","url":"http://www.phil.uu.nl/~yoad/papers/WinterSymmetry.pdf","authors":["Yoad Winter"],"date":"2016/02/26","journal":"Empirical issues in syntax and semantics","abstract":"This paper systematically analyzes the relations between logical symmetry and lexical reciprocity. A new generalization about these phenomena is uncovered, which is referred to as the Reciprocity-Symmetry Generalization (RSG). To analyze the RSG in full generality, we develop a new formal theory of lexical reciprocity building on Dowty\u2019s notion of proto-roles. Because of its foundational nature and plausibility for other languages besides English, the RSG is conjectured to be a language universal. Some general implications of this conjecture are discussed, especially regarding the organization of lexical meanings in different languages, and their relations with cognitive systems of concepts and categorization. Although the RSG is new with this paper, it appears to have been silently sensed since early transformational works in the 1960s, without any general analysis. By uncovering this generalization and accounting for it, the present work removes considerable confusion surrounding the pertinent semantic questions."},{"id":"069d6cabcde4e83b0eee965c44cab4c5.html","title":"Improving Hypernymy Detection with an Integrated Path-based and Distributional Method","url":"https://arxiv.org/abs/1603.06076","authors":["Vered Shwartz","Yoav Goldberg","Ido Dagan"],"date":"2016","journal":"Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)","abstract":"Detecting hypernymy relations is a key task in NLP, which is addressed in the literature using two complementary approaches. Distributional methods, whose supervised variants are the current best performers, and path-based methods, which received less research attention. We suggest an improved path-based algorithm, in which the dependency paths are encoded using a recurrent neural network, that achieves results comparable to distributional methods. We then extend the approach to integrate both path-based and distributional signals, significantly improving upon the state-of-the-art on this task."},{"id":"0853377f9eb74885dab4eaa77432d884.html","title":"Proceedings of The 20th SIGNLL Conference on Computational Natural Language Learning","url":"https://www.aclweb.org/anthology/K16-1000.pdf","authors":["Stefan Riezler","Yoav Goldberg"],"date":"2016","journal":"Proceedings of The 20th SIGNLL Conference on Computational Natural Language Learning","abstract":"The 2016 Conference on Computational Natural Language Learning is the twentieth in the series of annual meetings organized by SIGNLL, the ACL special interest group on natural language learning. CoNLL 2016 will be held on August 11-12, 2016, and is co-located with the 54th annual meeting of the Association for Computational Linguistics (ACL) in Berlin, Germany."},{"id":"d5c02f54315dd573f1b159e89ba7e3f5.html","title":"Collecting better training data using biased agent policies in negotiation dialogues","url":"http://workshop.colips.org/wochat/@iva2016/documents/RP-270.pdf","authors":["Vasily Konovalov","Oren Melamud","Ron Artstein","Ido Dagan"],"date":"2016","journal":"WOCHAT: Workshop on Chatbots and Conversational Agent Technologies","abstract":"When naturally occurring data is characterized by a highly skewed class distribution, supervised learning often benefits from reducing this skew. Human-agent dialogue data is commonly highly skewed when using standard agent policies. Hence, we suggest that agent policies need to be reconsidered in the context of training data collection. Specifically, in this work we implemented biased agent policies that are optimized for data collection in the negotiation domain. Empirical evaluations show that our method is successful in collecting a reasonably balanced corpus in the highly skewed Job-Candidate domain. Furthermore, using this balanced corpus to train a negotiation intent classifier yields notable performance improvements relative to naturally distributed data."},{"id":"e30d12d4ba24be7f9898551fb3c73002.html","title":"A primer on neural network models for natural language processing","url":"http://www.jair.org/index.php/jair/article/view/11030","authors":["Yoav Goldberg"],"date":"2016","journal":"Journal of Artificial Intelligence Research","abstract":"Over the past few years, neural networks have re-emerged as powerful machine-learning models, yielding state-of-the-art results in fields such as image recognition and speech processing. More recently, neural network models started to be applied also to textual natural language signals, again with very promising results. This tutorial surveys neural network models from the perspective of natural language processing research, in an attempt to bring natural-language researchers up to speed with the neural techniques. The tutorial covers input encoding for natural language tasks, feed-forward networks, convolutional networks, recurrent networks and recursive networks, as well as the computation graph abstraction for automatic gradient computation."},{"id":"2ee87eebe615b34c5cbd707a5774d916.html","title":"Universal Dependencies 1.2","url":"https://lindat.mff.cuni.cz/repository/xmlui/handle/11234/1-1548?locale-attribute=cs","authors":["Joakim Nivre","\u017deljko Agi\u0107","Maria Jesus Aranzabe","Masayuki Asahara","Aitziber Atutxa","Miguel Ballesteros","John Bauer","Kepa Bengoetxea","Riyaz Ahmad Bhat","Cristina Bosco","Sam Bowman","Giuseppe GA Celano","Miriam Connor","Marie-Catherine de Marneffe","Arantza Diaz de Ilarraza","Kaja Dobrovoljc","Timothy Dozat","Toma\u017e Erjavec","Rich\\\\xef\\\\xbf\\\\xbdrd Farkas","Jennifer Foster","Daniel Galbraith","Filip Ginter","Iakes Goenaga","Koldo Gojenola","Yoav Goldberg","Berta Gonzales","Bruno Guillaume","Jan Haji\u010d","Dag Haug","Radu Ion","Elena Irimia","Anders Johannsen","Hiroshi Kanayama","Jenna Kanerva","Simon Krek","Veronika Laippala","Alessandro Lenci","Nikola Ljube\u0161i\u0107","Teresa Lynn","Christopher Manning","C\u0103t\u0103lina M\u0103r\u0103nduc","David Mare\u010dek","H\\\\xef\\\\xbf\\\\xbdctor Mart\\\\xef\\\\xbf\\\\xbdnez Alonso","Jan Ma\u0161ek","Yuji Matsumoto","Ryan McDonald","Anna Missil\\\\xef\\\\xbf\\\\xbd","Verginica Mititelu","Yusuke Miyao","Simonetta Montemagni","Shunsuke Mori","Hanna Nurmi","Petya Osenova","Lilja \\\\xef\\\\xbf\\\\xbdvrelid","Elena Pascual","Marco Passarotti","Cenel-Augusto Perez","Slav Petrov","Jussi Piitulainen","Barbara Plank","Martin Popel","Prokopis Prokopidis","Sampo Pyysalo","Loganathan Ramasamy","Rudolf Rosa","Shadi Saleh","Sebastian Schuster","Wolfgang Seeker","Mojgan Seraji","Natalia Silveira","Maria Simi","Radu Simionescu","Katalin Simk\\\\xef\\\\xbf\\\\xbd","Kiril Simov","Aaron Smith","Jan \u0160t\u011bp\\\\xef\\\\xbf\\\\xbdnek","Alane Suhr","Zsolt Sz\\\\xef\\\\xbf\\\\xbdnt\\\\xef\\\\xbf\\\\xbd","Takaaki Tanaka","Reut Tsarfaty","Sumire Uematsu","Larraitz Uria","Viktor Varga","Veronika Vincze","Zden\u011bk \u017dabokrtsk\\\\xef\\\\xbf\\\\xbd","Daniel Zeman","Hanzhi Zhu"],"date":"2015/11/15","abstract":"Popis Universal Dependencies is a project that seeks to develop cross-linguistically consistent treebank annotation for many languages, with the goal of facilitating multilingual parser development, cross-lingual learning, and parsing research from a language typology perspective. The annotation scheme is based on (universal) Stanford dependencies (de Marneffe et al., 2006, 2008, 2014), Google universal part-of-speech tags (Petrov et al., 2012), and the Interset interlingua for morphosyntactic tagsets (Zeman, 2008)."},{"id":"950835f59e8353976ce63e5c8a36a127.html","title":"Knowledge-based textual inference via parse-tree transformations","url":"https://www.jair.org/index.php/jair/article/view/10957","authors":["Roy Bar-Haim","Ido Dagan","Jonathan Berant"],"date":"2015/09/9","journal":"Journal of Artificial Intelligence Research","abstract":"Textual inference is an important component in many applications for understanding natural language. Classical approaches to textual inference rely on logical representations for meaning, which may be regarded as \\"external\\" to the natural language itself. However, practical applications usually adopt shallower lexical or lexical-syntactic representations, which correspond closely to language structure. In many cases, such approaches lack a principled meaning representation and inference framework. We describe an inference formalism that operates directly on language-based structures, particularly syntactic parse trees. New trees are generated by applying inference rules, which provide a unified representation for varying types of inferences. We use manual and automatic methods to generate these rules, which cover generic linguistic structures as well as specific lexical-based inferences. We also present a novel packed data-structure and a corresponding inference algorithm that allows efficient implementation of this formalism. We proved the correctness of the new algorithm and established its efficiency analytically and empirically. The utility of our approach was illustrated on two tasks: unsupervised relation extraction from a large corpus, and the Recognizing Textual Entailment (RTE) benchmarks."},{"id":"e20ced778879995dca17e93e990c7f15.html","title":"Semi-supervised dependency parsing using bilexical contextual features from auto-parsed data","url":"https://www.aclweb.org/anthology/D15-1158.pdf","authors":["Eliyahu Kiperwasser","Yoav Goldberg"],"date":"2015/09","abstract":"We present a semi-supervised approach to improve dependency parsing accuracy by using bilexical statistics derived from auto-parsed data. The method is based on estimating the attachment potential of head-modifier words, by taking into account not only the head and modifier words themselves, but also the words surrounding the head and the modifier. When integrating the learned statistics as features in a graph-based parsing model, we observe nice improvements in accuracy when parsing various English datasets."},{"id":"00ed59ba58aae590332b6a376c62e35c.html","title":"Open ie as an intermediate structure for semantic tasks","url":"https://www.aclweb.org/anthology/P15-2050.pdf","authors":["Gabriel Stanovsky","Ido Dagan"],"date":"2015/07","abstract":"Semantic applications typically extract information from intermediate structures derived from sentences, such as dependency parse or semantic role labeling. In this paper, we study Open Information Extraction\u2019s (Open IE) output as an additional intermediate structure and find that for tasks such as text comprehension, word similarity and word analogy it can be very effective. Specifically, for word analogy, Open IE-based embeddings surpass the state of the art. We suggest that semantic applications will likely benefit from adding Open IE format to their set of potential sentencelevel structures."},{"id":"861dcfb3b9c2fed268936edd4806ae47.html","title":"Integrating query performance prediction in term scoring for diachronic thesaurus","url":"https://www.aclweb.org/anthology/W15-3714.pdf","authors":["Chaya Liebeskind","Ido Dagan"],"date":"2015/07","abstract":"A diachronic thesaurus is a lexical resource that aims to map between modern terms and their semantically related terms in earlier periods. In this paper, we investigate the task of collecting a list of relevant modern target terms for a domain-specific diachronic thesaurus. We propose a supervised learning scheme, which integrates features from two closely related fields: Terminology Extraction and Query Performance Prediction (QPP). Our method further expands modern candidate terms with ancient related terms, before assessing their corpus relevancy with QPP measures. We evaluate the empirical benefit of our method for a thesaurus for a diachronic Jewish corpus."},{"id":"b3cde280409488ac58a404be7a4ed652.html","title":"Seed-Based Event Trigger Labeling: How far can event descriptions get us?","url":"https://www.aclweb.org/anthology/P15-2061.pdf","authors":["Ofer Bronstein","Ido Dagan","Qi Li","Heng Ji","Anette Frank"],"date":"2015/07","abstract":"The task of event trigger labeling is typically addressed in the standard supervised setting: triggers for each target event type are annotated as training data, based on annotation guidelines. We propose an alternative approach, which takes the example trigger terms mentioned in the guidelines as seeds, and then applies an eventindependent similarity-based classifier for trigger labeling. This way we can skip manual annotation for new event types, while requiring only minimal annotated training data for few example events at system setup. Our method is evaluated on the ACE-2005 dataset, achieving 5.7% F1 improvement over a state-of-the-art supervised system which uses the full training data."},{"id":"0f26221273bae9a162a3ce5870eae01e.html","title":"Text categorization from category name in an industry-motivated scenario","url":"https://link.springer.com/article/10.1007/s10579-015-9298-3","authors":["Chaya Liebeskind","Lili Kotlerman","Ido Dagan"],"date":"2015/06/01","journal":"Language resources and evaluation","abstract":"In this work we suggest a novel Text Categorization (TC) scenario, motivated by an ad-hoc industrial need to assign documents to a set of predefined categories, while labeled training data for the categories is not available. The scenario is applicable in many industrial settings and is interesting from the academic perspective. We present a new dataset geared for the main characteristics of the scenario, and utilize it to investigate the name-based TC approach, which uses the category names as its only input and does not require training data. We evaluate and analyze the performance of state-of-the-art methods for this dataset to identify the shortcomings of these methods for our scenario, and suggest ways for overcoming these shortcomings. We utilize statistical correlation measured over a target corpus for improving the state-of-the-art, and offer a different classification scheme based on the characteristics\\\\xa0\u2026"},{"id":"0cf7b529a7108dcbd94af7efab9eec38.html","title":"Efficient global learning of entailment graphs","url":"https://www.mitpressjournals.org/doi/abs/10.1162/COLI_a_00220","authors":["Jonathan Berant","Noga Alon","Ido Dagan","Jacob Goldberger"],"date":"2015/06","journal":"Computational Linguistics","abstract":"Entailment rules between predicates are fundamental to many semantic-inference applications. Consequently, learning such rules has been an active field of research in recent years. Methods for learning entailment rules between predicates that take into account dependencies between different rules (e.g., entailment is a transitive relation) have been shown to improve rule quality, but suffer from scalability issues, that is, the number of predicates handled is often quite small. In this article, we present methods for learning transitive graphs that contain tens of thousands of nodes, where nodes represent predicates and edges correspond to entailment rules (termed entailment graphs). Our methods are able to scale to a large number of predicates by exploiting structural properties of entailment graphs such as the fact that they exhibit a \u201ctree-like\u201d property. We apply our methods on two data sets and demonstrate that\\\\xa0\u2026"},{"id":"0fd407c133eb13e6b734949a6cdc0555.html","title":"A simple word embedding model for lexical substitution","url":"https://www.aclweb.org/anthology/W15-1501.pdf","authors":["Oren Melamud","Omer Levy","Ido Dagan"],"date":"2015/06","abstract":"The lexical substitution task requires identifying meaning-preserving substitutes for a target word instance in a given sentential context. Since its introduction in SemEval-2007, various models addressed this challenge, mostly in an unsupervised setting. In this work we propose a simple model for lexical substitution, which is based on the popular skip-gram word embedding model. The novelty of our approach is in leveraging explicitly the context embeddings generated within the skip-gram model, which were so far considered only as an internal component of the learning process. Our model is efficient, very simple to implement, and at the same time achieves state-ofthe-art results on lexical substitution tasks in an unsupervised setting."},{"id":"f00f7bba1384e4463189c1ab1eb255c6.html","title":"Multi-level alignments as an extensible representation basis for textual entailment algorithms","url":"https://www.aclweb.org/anthology/S15-1022.pdf","authors":["Tae-Gil Noh","Sebastian Pad\\\\xf3","Vered Shwartz","Ido Dagan","Vivi Nastase","Kathrin Eichler","Lili Kotlerman","Meni Adler"],"date":"2015/06","abstract":"A major problem in research on Textual Entailment (TE) is the high implementation effort for TE systems. Recently, interoperable standards for annotation and preprocessing have been proposed. In contrast, the algorithmic level remains unstandardized, which makes component re-use in this area very difficult in practice. In this paper, we introduce multi-level alignments as a central, powerful representation for TE algorithms that encourages modular, reusable, multilingual algorithm development. We demonstrate that a pilot open-source implementation of multi-level alignment with minimal features competes with state-of-theart open-source TE engines in three languages."},{"id":"c732b05f2c9dfd2518055f6f5ac27ee0.html","title":"Improving distributional similarity with lessons learned from word embeddings","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00134","authors":["Omer Levy","Yoav Goldberg","Ido Dagan"],"date":"2015/05/04","journal":"Transactions of the Association for Computational Linguistics","abstract":"Recent trends suggest that neural-network-inspired word embedding models outperform traditional count-based distributional models on word similarity and analogy detection tasks. We reveal that much of the performance gains of word embeddings are due to certain system design choices and hyperparameter optimizations, rather than the embedding algorithms themselves. Furthermore, we show that these modifications can be transferred to traditional distributional models, yielding similar gains. In contrast to prior reports, we observe mostly local or insignificant performance differences between the methods, with no global advantage to any single approach over the others."},{"id":"fa2bea0b30c05efab2619813a967366d.html","title":"Universal Dependencies 1.0","url":"https://lindat.mff.cuni.cz/repository/xmlui/handle/11234/1-1548?locale-attribute=cs","authors":["Joakim Nivre","Cristina Bosco","Jinho Choi","Marie-Catherine de Marneffe","Timothy Dozat","Rich\\\\xe1rd Farkas","Jennifer Foster","Filip Ginter","Yoav Goldberg","Jan Haji\u010d","Jenna Kanerva","Veronika Laippala","Alessandro Lenci","Teresa Lynn","Christopher Manning","Ryan McDonald","Anna Missil\\\\xe4","Simonetta Montemagni","Slav Petrov","Sampo Pyysalo","Natalia Silveira","Maria Simi","Aaron Smith","Reut Tsarfaty","Veronika Vincze","Daniel Zeman"],"date":"2015/01/15","abstract":"Popis Universal Dependencies is a project that seeks to develop cross-linguistically consistent treebank annotation for many languages, with the goal of facilitating multilingual parser development, cross-lingual learning, and parsing research from a language typology perspective. The annotation scheme is based on (universal) Stanford dependencies (de Marneffe et al., 2006, 2008, 2014), Google universal part-of-speech tags (Petrov et al., 2012), and the Interset interlingua for morphosyntactic tagsets (Zeman, 2008)."},{"id":"c309731f884b6d356582fbe6007d3a19.html","title":"Textual entailment graphs.","url":"http://u.cs.biu.ac.il/~davidol/lilikotlerman/nleGraphs.pdf","authors":["Lili Kotlerman","Ido Dagan","Bernardo Magnini","Luisa Bentivogli"],"date":"2015/01","journal":"Nat. Lang. Eng.","abstract":"In this work we present a novel type of graphs for Natural Language Processing, namely Textual Entailment Graphs. We describe the complete methodology we developed for the construction of such graphs and provide some baselines for this task by evaluating relevant state-of-the-art technology. We situate our research in the context of Text Exploration, since it was motivated by joint work with industrial partners in the text analytics area. Accordingly, we present our motivating scenario and the first gold-standard dataset of textual entailment graphs. However, while our own motivation and dataset focus on the text exploration setting, we suggest that textual entailment graphs can have different usages and suggest that automatic creation of such graphs is an interesting task for the community."},{"id":"1066c85681fb4d49a62ed763caf90b76.html","title":"Do supervised distributional methods really learn lexical inference relations?","url":"https://www.aclweb.org/anthology/N15-1098.pdf","authors":["Omer Levy","Steffen Remus","Chris Biemann","Ido Dagan"],"date":"2015","abstract":"Distributional representations of words have been recently used in supervised settings for recognizing lexical inference relations between word pairs, such as hypernymy and entailment. We investigate a collection of these state-of-the-art methods, and show that they do not actually learn a relation between two words. Instead, they learn an independent property of a single word in the pair: whether that word is a \u201cprototypical hypernym\u201d."},{"id":"378e485590b47d3399745b774557dc4f.html","title":"Unsupervised acquisition of entailment relations from the Web","url":"https://u.cs.biu.ac.il/~nlp/downloads/publications/S1351324913000156a.pdf","authors":["Idan Szpektor","Hristo Tanev","Ido Dagan","Bonaventura Coppola","Milen Kouylekov"],"date":"2015","journal":"Natural Language Engineering","abstract":"Entailment recognition is a primary generic task in natural language inference, whose focus is to detect whether the meaning of one expression can be inferred from the meaning of the other. Accordingly, many NLP applications would benefit from high coverage knowledgebases of paraphrases and entailment rules. To this end, learning such knowledgebases from the Web is especially appealing due to its huge size as well as its highly heterogeneous content, allowing for a more scalable rule extraction of various domains. However, the scalability of state-of-the-art entailment rule acquisition approaches from the Web is still limited. We present a fully unsupervised learning algorithm for Webbased extraction of entailment relations. We focus on increased scalability and generality with respect to prior work, with the potential of a large-scale Web-based knowledgebase. Our algorithm takes as its input a lexical\u2013syntactic template and searches the Web for syntactic templates that participate in an entailment relation with the input template. Experiments show promising results, achieving performance similar to a state-of-the-art unsupervised algorithm, operating over an offline corpus, but with the benefit of learning rules for different domains with no additional effort."},{"id":"389ef4da1d00afe136c1742b71c61af8.html","title":"Template Kernels for Dependency Parsing","url":"https://www.aclweb.org/anthology/N15-1163.pdf","authors":["Hillel Taub-Tabib","Yoav Goldberg","Amir Globerson"],"date":"2015","abstract":"A common approach to dependency parsing is scoring a parse via a linear function of a set of indicator features. These features are typically manually constructed from templates that are applied to parts of the parse tree. The templates define which properties of a part should combine to create features. Existing approaches consider only a small subset of the possible combinations, due to statistical and computational efficiency considerations. In this work we present a novel kernel which facilitates efficient parsing with feature representations corresponding to a much larger set of combinations. We integrate the kernel into a parse reranking system and demonstrate its effectiveness on four languages from the CoNLL-X shared task. 1"},{"id":"58a971e17063d10a9e35af3c4ca9244e.html","title":"Universal dependencies 1.1","url":"http://scholar.google.com/scholar?cluster=1992226429518703120&hl=en&oi=scholarr","authors":["\u017deljko Agic","Maria Jesus Aranzabe","Aitziber Atutxa","Cristina Bosco","Jinho Choi","Marie-Catherine de Marneffe","Timothy Dozat","Rich\\\\xe1rd Farkas","Jennifer Foster","Filip Ginter","Iakes Goenaga","Koldo Gojenola","Yoav Goldberg","Jan Hajic","Anders Tr\\\\xe6rup Johannsen","Jenna Kanerva","Juha Kuokkala","Veronika Laippala","Alessandro Lenci","Krister Lind\\\\xe9n","Nikola Ljube\u0161ic","Teresa Lynn","Christopher Manning","H\\\\xe9ctor Alonso Mart\\\\xednez","Ryan McDonald","Anna Missil\\\\xe4","Simonetta Montemagni","Joakim Nivre","Hanna Nurmi","Petya Osenova","Slav Petrov","Jussi Piitulainen","Barbara Plank","Prokopis Prokopidis","Sampo Pyysalo","Wolfgang Seeker","Mojgan Seraji","Natalia Silveira","Maria Simi","Kiril Simov","Aaron Smith","Reut Tsarfaty","Veronika Vincze","Daniel Zeman"],"date":"2015","journal":"LINDAT/CLARIN digital library at Institute of Formal and Applied Linguistics, Charles University in Prague"},{"id":"77c1301ef4e9418fcbae24fa12c345fb.html","title":"Universal Dependencies Treebanks 1.2 (see http://universaldependencies. org/)","url":"https://arpi.unipi.it/handle/11568/773645","authors":["Joakim Nivre","\u017deljko Agi\u0107","Maria Jesus Aranzabe","Masayuki Asahara","Aitziber Atutxa","Miguel Ballesteros","John Bauer","Kepa Bengoetxea","Riyaz Ahmad Bhat","Cristina Bosco","Sam Bowman","Giuseppe GA Celano","Miriam Connor","Marie-Catherine de Marneffe","Arantza Diaz de Ilarraza","Kaja Dobrovoljc","Timothy Dozat","Toma\u017e Erjavec","Rich\\\\xe1rd Farkas","Jennifer Foster","Daniel Galbraith","Filip Ginter","Iakes Goenaga","Koldo Gojenola","Yoav Goldberg","Berta Gonzales","Bruno Guillaume","Jan Haji\u010d","Dag Haug","Radu Ion","Elena Irimia","Anders Johannsen","Hiroshi Kanayama","Jenna Kanerva","Simon Krek","Veronika Laippala","Alessandro Lenci","Nikola Ljube\u0161i\u0107","Teresa Lynn","Christopher Manning","C\u0103t\u0103lina M\u0103r\u0103nduc","David Mare\u010dek","H\\\\xe9ctor Mart\\\\xednez Alonso","Jan Ma\u0161ek","Yuji Matsumoto","Ryan Mcdonald","Anna Missil\\\\xe4","Verginica Mititelu","Yusuke Miyao","Simonetta Montemagni","Shunsuke Mori","Hanna Nurmi","Petya Osenova","Lilja \\\\xd8vrelid","Elena Pascual","Marco Passarotti","Cenel-Augusto Perez","Slav Petrov","Jussi Piitulainen","Barbara Plank","Martin Popel","Prokopis Prokopidis","Sampo Pyysalo","Loganathan Ramasamy","Rudolf Rosa","Shadi Saleh","Sebastian Schuster","Wolfgang Seeker","Mojgan Seraji","Natalia Silveira","Maria Simi","Radu Simionescu","Katalin Simk\\\\xf3","Kiril Simov","Aaron Smith","Jan \u0160t\u011bp\\\\xe1nek","Alane Suhr","Zsolt Sz\\\\xe1nt\\\\xf3","Takaaki Tanaka","Reut Tsarfaty","Sumire Uematsu","Larraitz Uria","Viktor Varga","Veronika Vincze","Zden\u011bk \u017dabokrtsk\\\\xfd","Daniel Zeman","Hanzhi Zhu"],"date":"2015","abstract":"Universal Dependencies is a project that seeks to develop cross-linguistically consistent treebank annotation for many languages, with the goal of facilitating multilingual parser development, cross-lingual learning, and parsing research from a language typology perspective. The annotation scheme is based on (universal) Stanford dependencies (de Marneffe et al., 2006, 2008, 2014), Google universal part-of-speech tags (Petrov et al., 2012), and the Interset interlingua for morphosyntactic tagsets (Zeman, 2008)."},{"id":"7e1ea697ba71ec4ee37e37e5c84cffad.html","title":"Word embeddings in Hebrew: Initial results","url":"https://www.openu.ac.il/iscol2015/downloads/ISCOL2015_submission_27_c_16.pdf","authors":["Oded Avraham","Yoav Goldberg"],"date":"2015","abstract":"Word embeddings algorithms got considerable attention in the past few years. However, they were all applied to English, a language with very limited morphology. We present our initial results with inferring word embeddings on Hebrew, a language with a much richer inflectional morphology system. The embeddings seem to provide a mix of semantic and morphological properties. Using lemmatization helps direct the resulting similarities away from the morphological similarity and towards semantic similarity. We are currently looking at improving the control over the aspects of the resulting similarities by investigating more refined and taskdirected lemmatization."},{"id":"c407225f2dcb6fbcce9d1a64f32203e4.html","title":"Inherent Vacuity in Lattice Automata","url":"https://link.springer.com/chapter/10.1007/978-3-319-23534-9_10","authors":["Hila Gonen","Orna Kupferman"],"date":"2015","abstract":" <i>Vacuity checking</i> is traditionally performed after model checking has terminated successfully. It ensures that all the elements of the specification have played a role in its satisfaction by the system. The need to check the quality of specifications is even more acute in <i>property-based design</i>, where the specification is the only input, serving as a basis to the development of the system. <i>Inherent vacuity</i> adapts the theory of vacuity in model checking to the setting of property-based design. Essentially, a specification is inherently vacuous if it can be mutated into a simpler equivalent specification, which is known, in the case of specifications in linear temporal logic, to coincide with the fact the specification is satisfied vacuously in all systems."},{"id":"cafc36c193b4860454d16c7b3c59bcd8.html","title":"Modeling word meaning in context with substitute vectors","url":"https://www.aclweb.org/anthology/N15-1050.pdf","authors":["Oren Melamud","Ido Dagan","Jacob Goldberger"],"date":"2015","abstract":"Context representations are a key element in distributional models of word meaning. In contrast to typical representations based on neighboring words, a recently proposed approach suggests to represent a context of a target word by a substitute vector, comprising the potential fillers for the target word slot in that context. In this work we first propose a variant of substitute vectors, which we find particularly suitable for measuring context similarity. Then, we propose a novel model for representing word meaning in context based on this context representation. Our model outperforms state-of-the-art results on lexical substitution tasks in an unsupervised setting."},{"id":"8639200ba787f1de3565bf2af5102458.html","title":"Semantic parsing using content and context: A case study from requirements elicitation","url":"https://www.aclweb.org/anthology/D14-1136.pdf","authors":["Reut Tsarfaty","Ilia Pogrebezky","Guy Weiss","Yaarit Natan","Smadar Szekely","David Harel"],"date":"2014/10","abstract":"We present a model for the automatic semantic analysis of requirements elicitation documents. Our target semantic representation employs live sequence charts, a multi-modal visual language for scenariobased programming, which can be directly translated into executable code. The architecture we propose integrates sentencelevel and discourse-level processing in a generative probabilistic framework for the analysis and disambiguation of individual sentences in context. We show empirically that the discourse-based model consistently outperforms the sentence-based model when constructing a system that reflects all the static (entities, properties) and dynamic (behavioral scenarios) requirements in the document."},{"id":"887abd66d42324f340116c5fbda75b94.html","title":"Entailment graphs for text analytics in the excitement project","url":"https://link.springer.com/chapter/10.1007/978-3-319-10816-2_2","authors":["Bernardo Magnini","Ido Dagan","G\\\\xfcnter Neumann","Sebastian Pado"],"date":"2014/09/08","abstract":"In the last years, a relevant research line in Natural Language Processing has focused on detecting semantic relations among portions of text, including entailment, similarity, temporal relations, and, with a less degree, causality. The attention on such semantic relations has raised the demand to move towards more informative meaning representations, which express properties of concepts and relations among them. This demand triggered research on \u201cstatement entailment graphs\u201d, where nodes are natural language statements (propositions), comprising of predicates with their arguments and modifiers, while edges represent entailment relations between nodes."},{"id":"1ec9cf537cebcf4d293f5997c6a5d65a.html","title":"Introducing the spmrl 2014 shared task on parsing morphologically-rich languages","url":"https://www.aclweb.org/anthology/W14-6111.pdf","authors":["Djam\\\\xe9 Seddah","Sandra K\\\\xfcbler","Reut Tsarfaty"],"date":"2014/08","abstract":"This first joint meeting on Statistical Parsing of Morphologically Rich Languages and Syntactic Analysis of Non-Canonical English (SPMRL-SANCL) featured a shared task on statistical parsing of morphologically rich languages (SPMRL). The goal of the shared task is to allow to train and test different participating systems on comparable data sets, thus providing an objective measure of comparison between state-of-the-art parsing systems on data data sets from a range of different languages. This 2014 SPMRL shared task is a continuation and extension of the SPMRL shared task, which was co-located with the SPMRL meeting at EMNLP 2013 (Seddah et al., 2013). This paper provides a short overview of the 2014 SPMRL shared task goals, data sets, and evaluation setup. Since the SPMRL 2014 largely builds on the infrastructure established for the SPMRL 2013 shared task, we start by reviewing the previous shared task (\\\\xa7 2) and then proceed to the 2014 SPMRL evaluation settings (\\\\xa7 3), data sets (\\\\xa7 4), and a task summary (\\\\xa7 5). Due to organizational constraints, this overview is published prior to the submission of all system test runs, and a more detailed overview including the description of participating systems and the analysis of their results will follow as part of (Seddah et al., 2014), once the shared task is completed."},{"id":"dc10a6507464bbbc2c69c382d6c4b747.html","title":"Proposition Knowledge Graphs","url":"https://www.aclweb.org/anthology/W14-4504.pdf","authors":["Gabriel Stanovsky","Omer Levy","Ido Dagan"],"date":"2014/08","abstract":"Open Information Extraction (Open IE) is a promising approach for unrestricted Information Discovery (ID). While Open IE is a highly scalable approach, allowing unsupervised relation extraction from open domains, it currently has some limitations. First, it lacks the expressiveness needed to properly represent and extract complex assertions that are abundant in text. Second, it does not consolidate the extracted propositions, which causes simple queries above Open IE assertions to return insufficient or redundant information. To address these limitations, we propose in this position paper a novel representation for ID\u2013Propositional Knowledge Graphs (PKG). PKGs extend the Open IE paradigm by representing semantic inter-proposition relations in a traversable graph. We outline an approach for constructing PKGs from single and multiple texts, and highlight a variety of high-level applications that may leverage PKGs as their underlying information discovery and representation framework."},{"id":"22539529cd9476d9bbe408641765baa6.html","title":"Constrained arc-eager dependency parsing","url":"https://www.mitpressjournals.org/doi/abs/10.1162/COLI_a_00184","authors":["Joakim Nivre","Yoav Goldberg","Ryan McDonald"],"date":"2014/06/27","journal":"Computational Linguistics","abstract":"Arc-eager dependency parsers process sentences in a single left-to-right pass over the input and have linear time complexity with greedy decoding or beam search. We show how such parsers can be constrained to respect two different types of conditions on the output dependency graph: span constraints, which require certain spans to correspond to subtrees of the graph, and arc constraints, which require certain arcs to be present in the graph. The constraints are incorporated into the arc-eager transition system as a set of preconditions for each transition and preserve the linear time complexity of the parser."},{"id":"8d80c7c577f601e30f857976a48608f9.html","title":"Linguistic regularities in sparse and explicit word representations","url":"https://www.aclweb.org/anthology/W14-1618.pdf","authors":["Omer Levy","Yoav Goldberg"],"date":"2014/06/26","abstract":"Recent work has shown that neuralembedded word representations capture many relational similarities, which can be recovered by means of vector arithmetic in the embedded space. We show that Mikolov et al.\u2019s method of first adding and subtracting word vectors, and then searching for a word similar to the result, is equivalent to searching for a word that maximizes a linear combination of three pairwise word similarities. Based on this observation, we suggest an improved method of recovering relational similarities, improving the state-of-the-art results on two recent word-analogy datasets. Moreover, we demonstrate that analogy recovery is not restricted to neural word embeddings, and that a similar amount of relational similarities can be recovered from traditional distributional word representations."},{"id":"0a0793e629a3667f15b0758c8e9cbe5c.html","title":"Intermediary semantic representation through proposition structures","url":"https://www.aclweb.org/anthology/W14-2413.pdf","authors":["Gabriel Stanovsky","Jessica Ficler","Ido Dagan","Yoav Goldberg"],"date":"2014/06","abstract":"We propose an intermediary-level semantic representation, providing a higher level of abstraction than syntactic parse trees, while not committing to decisions in cases such as quantification, grounding or verbspecific roles assignments. The proposal is centered around the proposition structure of the text, and includes also implicit propositions which can be inferred from the syntax but are not transparent in parse trees, such as copular relations introduced by appositive constructions. Other benefits over dependency-trees are explicit marking of logical relations between propositions, explicit marking of multiword predicate such as light-verbs, and a consistent representation for syntacticallydifferent but semantically-similar structures. The representation is meant to serve as a useful input layer for semanticoriented applications, as well as to provide a better starting point for further levels of semantic analysis such as semantic-rolelabeling and semantic-parsing."},{"id":"8c15fc8cfd9b72302ddc2e866d415d44.html","title":"Probabilistic modeling of joint-context in distributional similarity","url":"https://www.aclweb.org/anthology/W14-1619.pdf","authors":["Oren Melamud","Ido Dagan","Jacob Goldberger","Idan Szpektor","Deniz Yuret"],"date":"2014/06","abstract":"Most traditional distributional similarity models fail to capture syntagmatic patterns that group together multiple word features within the same joint context. In this work we introduce a novel generic distributional similarity scheme under which the power of probabilistic models can be leveraged to effectively model joint contexts. Based on this scheme, we implement a concrete model which utilizes probabilistic n-gram language models. Our evaluations suggest that this model is particularly wellsuited for measuring similarity for verbs, which are known to exhibit richer syntagmatic patterns, while maintaining comparable or better performance with respect to competitive baselines for nouns. Following this, we propose our scheme as a framework for future semantic similarity models leveraging the substantial body of work that exists in probabilistic language modeling."},{"id":"a0ba330c683711980a17301d23723753.html","title":"Recognizing implied predicate-argument relationships in textual inference","url":"https://www.aclweb.org/anthology/P14-2120.pdf","authors":["Asher Stern","Ido Dagan"],"date":"2014/06","abstract":"We investigate recognizing implied predicate-argument relationships which are not explicitly expressed in syntactic structure. While prior works addressed such relationships as an extension to semantic role labeling, our work investigates them in the context of textual inference scenarios. Such scenarios provide prior information, which substantially eases the task. We provide a large and freely available evaluation dataset for our task setting, and propose methods to cope with it, while obtaining promising results in empirical evaluations."},{"id":"c2cc03c531e53ce43c1409fd4feb50b0.html","title":"Generating subjective responses to opinionated articles in social media: an agenda-driven architecture and a turing-like test","url":"https://www.aclweb.org/anthology/W14-2708.pdf","authors":["Tomer Cagan","Stefan L Frank","Reut Tsarfaty"],"date":"2014/06","abstract":"Natural language traffic in social media (blogs, microblogs, talkbacks) enjoys vast monitoring and analysis efforts. However, the question whether computer systems can generate such content in order to effectively interact with humans has been only sparsely attended to. This paper presents an architecture for generating subjective responses to opinionated articles based on users\u2019 agenda, documents\u2019 topics, sentiments and a knowledge graph. We present an empirical evaluation method for quantifying the humanlikeness and relevance of the generated responses. We show that responses generated using world knowledge in the input are regarded as more human-like than those that rely on topic, sentiment and agenda only, whereas the use of world knowledge does not affect perceived relevance."},{"id":"cc444c665fd0e2ba82dfe99dea07ee10.html","title":"The excitement open platform for textual inferences","url":"https://www.aclweb.org/anthology/P14-5008.pdf","authors":["Bernardo Magnini","Roberto Zanoli","Ido Dagan","Kathrin Eichler","G\\\\xfcnter Neumann","Tae-Gil Noh","Sebastian Pado","Asher Stern","Omer Levy"],"date":"2014/06","abstract":"This paper presents the Excitement Open Platform (EOP), a generic architecture and a comprehensive implementation for textual inference in multiple languages. The platform includes state-of-art algorithms, a large number of knowledge resources, and facilities for experimenting and testing innovative approaches. The EOP is distributed as an open source software."},{"id":"e408caf4796f7c7a7ef176bc6aef7f67.html","title":"Focused entailment graphs for open ie propositions","url":"https://www.aclweb.org/anthology/W14-1610.pdf","authors":["Omer Levy","Ido Dagan","Jacob Goldberger"],"date":"2014/06","abstract":"Open IE methods extract structured propositions from text. However, these propositions are neither consolidated nor generalized, and querying them may lead to insufficient or redundant information. This work suggests an approach to organize open IE propositions using entailment graphs. The entailment relation unifies equivalent propositions and induces a specific-to-general structure. We create a large dataset of gold-standard proposition entailment graphs, and provide a novel algorithm for automatically constructing them. Our analysis shows that predicate entailment is extremely context-sensitive, and that current lexical-semantic resources do not capture many of the lexical inferences induced by proposition entailment."},{"id":"d917d7444d7b44181080500778cda55d.html","title":"A tabular method for dynamic oracles in transition-based parsing","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00170","authors":["Yoav Goldberg","Francesco Sartorio","Giorgio Satta"],"date":"2014/04/30","journal":"Transactions of the Association for Computational Linguistics","abstract":"We develop parsing oracles for two transition-based dependency parsers, including the arc-standard parser, solving a problem that was left open in (Goldberg and Nivre, 2013). We experimentally show that using these oracles during training yields superior parsing accuracies on many languages."},{"id":"aec38569a54dcc719a4d1d70067ef1f2.html","title":"word2vec Explained: deriving Mikolov et al.\'s negative-sampling word-embedding method","url":"https://arxiv.org/abs/1402.3722","authors":["Yoav Goldberg","Omer Levy"],"date":"2014/02/15","journal":"arXiv preprint arXiv:1402.3722","abstract":"The word2vec software of Tomas Mikolov and colleagues (this https URL) has gained a lot of traction lately, and provides state-of-the-art word embeddings. The learning models behind the software are described in two research papers. We found the description of the models in these papers to be somewhat cryptic and hard to follow. While the motivations and presentation may be obvious to the neural-networks language-modeling crowd, we had to struggle quite a bit to figure out the rationale behind the equations."},{"id":"ebb47a91f0bb15246f15e5c6a6c47153.html","title":"The Hebrew Wikipedia Dependency Parsed Corpus Ver. 1.0","url":"http://u.cs.biu.ac.il/~yogo/hebwiki/parsed_hebrew_wiki.pdf","authors":["Yoav Goldberg"],"date":"2014/02/06","journal":"Bar-Ilan University","abstract":"In all these cases, the suffix is not separated from its base word, and instead the complete form is followed by the pseudo-words of its suffix. The benefit of the pseudo-words system is that, after ignoring the pseudo-word tokens, the word sequence has one-to-one correspondence to the raw tokens."},{"id":"90209244ac14aec8ec4f10c2e4b2327a.html","title":"A Note on Latent Semantic Analysis","url":"https://www.cs.bgu.ac.il/~dsp152/wiki.files/lsa.pdf","authors":["Yoav Goldberg"],"date":"2014/01/18","abstract":"We have a corpus of d documents over a vocabulary of v words. We arrange the corpus in a matrix C of dimensions v\\\\xd7 d, where Cij is the amount of association between word i and document j. The amount of association is either the count, or a function based on the count such as PMI, TF-IDF and so on. While choosing the association measure is important for obtaining good performance, it is not important to this explanation. Similarly, the documents can be generalized to any context a word appears in (eg same sentence, k preceding and following words, syntactic relations, and so on). Each row in C is associated with a word and each column is associated with a document. Each word vector reflects the contexts the word appears in, and each document vector reflects the words that appear in it. Based on the intuition that words appearing in similar documents (contexts) are similar, we can measure the similarity between words by measuring the similarity between their corresponding vectors (matrix rows). Similarly, we can measure the similarity between documents using the similarity between their corresponding document vectors (matrix columns). One common way of measuring similarity is the cosine similarity measure: simcos (x, y)=\u2329 x, y\u232a xy"},{"id":"053019288e8838d24a972d9e2e51a4cc.html","title":"Syntax and Parsing of Semitic Languages","url":"https://link.springer.com/chapter/10.1007/978-3-642-45358-8_3","authors":["Reut Tsarfaty"],"date":"2014","abstract":"The grammar of Semitic languages is different from that of English and many other languages. Therefore, general-purpose statistical parsers are not always equally successful when applied to Semitic data. This chapter presents the syntax of Semitic languages and discusses how it challenges existing general-purpose parsing architectures. We then survey the different components of a generative probabilistic parsing system and show how they can be designed and implemented in order to effectively cope with these challenges. We finally present parsing results obtained for Hebrew and Arabic using different technologies in different scenarios. While parsing Semitic languages can already be made quite accurate using the present techniques, remaining challenges leave ample space for future research."},{"id":"24c001fbad34b2c2676e154b9e87cb9c.html","title":"An update and extension of the META-NET Study \u201cEurope\u2019s Languages in the digital age\u201d","url":"http://real.mtak.hu/50245/1/CCURL_2014_META_NET_u.pdf","authors":["Georg Rehm","Hans Uszkoreit","Ido Dagan","Vartkes Goetcherian","Mehmet Ugur Dogan","Tam\\\\xe1s V\\\\xe1radi"],"date":"2014","abstract":"This paper extends and updates the cross-language comparison of LT support for 30 European languages as published in the META-NET Language White Paper Series. The updated comparison confirms the original results and paints an alarming picture: it demonstrates that there are even more dramatic differences in LT support between the European languages."},{"id":"2ef3abae01b7bda89dbbdce17d545da4.html","title":"Neural Word Embedding as Implicit Matrix Factorization","url":"http://papers.nips.cc/paper/5477-neural-word-embedding-as","authors":["Omer Levy","Yoav Goldberg"],"date":"2014","abstract":"We analyze skip-gram with negative-sampling (SGNS), a word embedding method introduced by Mikolov et al., and show that it is implicitly factorizing a word-context matrix, whose cells are the pointwise mutual information (PMI) of the respective word and context pairs, shifted by a global constant. We find that another embedding method, NCE, is implicitly factorizing a similar matrix, where each cell is the (shifted) log conditional probability of a word given its context. We show that using a sparse Shifted Positive PMI word-context matrix to represent words improves results on two word similarity tasks and one of two analogy tasks. When dense low-dimensional vectors are preferred, exact factorization with SVD can achieve solutions that are at least as good as SGNS\'s solutions for word similarity tasks. On analogy questions SGNS remains superior to SVD. We conjecture that this stems from the weighted nature of SGNS\'s factorization."},{"id":"42a87f0868540905eebbd0cd1ee00ec5.html","title":"Israel Ramat","url":"http://scholar.google.com/scholar?cluster=1561064494103251808&hl=en&oi=scholarr","authors":["Omer Levy","Yoav Goldberg","Ido Dagan"],"date":"2014","journal":"Gan"},{"id":"4eb53d36f2cee1f4d18ed1d38d75b313.html","title":"Benchmarking applied semantic inference: the PASCAL recognising textual entailment challenges","url":"https://link.springer.com/chapter/10.1007/978-3-642-45321-2_19","authors":["Roy Bar-Haim","Ido Dagan","Idan Szpektor"],"date":"2014","abstract":"Identifying that the same meaning is expressed by, or can be inferred from, various language expressions is a major challenge for natural language understanding applications such as information extraction, question answering and automatic summarization. Dagan and Glickman [5] proposed <i>Textual Entailment</i>, the task of deciding whether a target text follows from a source text, as a unifying framework for modeling language variability, which has often been addressed in an application-specific manner. In this paper we describe the series of benchmarks developed for the textual entailment recognition task, known as the PASCAL RTE Challenges. As a concrete example, we describe in detail the second RTE challenge, in which our methodology was consolidated, and served as a basis for the subsequent RTE challenges. The impressive success of these challenges established textual entailment as an\\\\xa0\u2026"},{"id":"63d587a3427b0aab2ccb6cd86399c110.html","title":"Dependency-Based Word Embeddings.","url":"https://www.aclweb.org/anthology/P14-2050.pdf","authors":["Omer Levy","Yoav Goldberg"],"date":"2014","abstract":"While continuous word embeddings are gaining popularity, current models are based solely on linear contexts. In this work, we generalize the skip-gram model with negative sampling introduced by Mikolov et al. to include arbitrary contexts. In particular, we perform experiments with dependency-based contexts, and show that they produce markedly different embeddings. The dependencybased embeddings are less topical and exhibit more functional similarity than the original skip-gram embeddings."},{"id":"9cd339ea56cf4c900af2c65300637135.html","title":"The BIUTTE Research Platform for Transformation-based Textual Entailment Recognition","url":"https://www.aclweb.org/anthology/2014.lilt-9.2/","authors":["Asher Stern","Ido Dagan"],"date":"2014","abstract":"Recent progress in research of the Recognizing Textual Entailment (RTE) task shows a constantly-increasing level of complexity in this research field. A way to avoid having this complexity becoming a barrier for researchers, especially for new-comers in the field, is to provide a freely available RTE system with a high level of flexibility and extensibility. In this paper, we introduce our RTE system, BiuTee2, and suggest it as an effective research framework for RTE. In particular, BiuTee follows the prominent transformation-based paradigm for RTE, and offers an accessible platform for research within this approach. We describe each of BiuTee\u2019s components and point out the mechanisms and properties which directly support adaptations and integration of new components. In addition, we describe BiuTee\u2019s visual tracing tool, which provides notable assistance for researchers in refining and \u201cdebugging\u201d their knowledge resources and inference components."},{"id":"e5b365c9c3e05fc8ebd2cf645d202552.html","title":"Proceedings of the First Joint Workshop on Statistical Parsing of Morphologically Rich Languages and Syntactic Analysis of Non-Canonical Languages","url":"https://www.aclweb.org/anthology/W14-6100.pdf","authors":["Yoav Goldberg","Yuval Marton","Ines Rehbein","Yannick Versley","\\\\xd6zlem \\\\xc7etino\u011flu","Joel Tetreault"],"date":"2014","journal":"Proceedings of the First Joint Workshop on Statistical Parsing of Morphologically Rich Languages and Syntactic Analysis of Non-Canonical Languages","abstract":"The papers in these proceedings were presented at the First Joint Workshop on Statistical Parsing of Morphologically Rich Languages and Syntactic Analysis of Non-Canonical Languages (SPMRLSANCL 2014), held in Seattle, USA, on October 18th, 2013, in conjunction with the 25th international Conference on Computational Linguistics (Coling 2014)."},{"id":"c2272c7de6a6649c10f1bb01476c99ae.html","title":"Dynamic-oracle Transition-based Parsing with Calibrated Probabilistic Output","url":"https://www.aclweb.org/anthology/W13-5709.pdf","authors":["Yoav Goldberg"],"date":"2013/11/27","journal":"IWPT-2013","abstract":"We adapt the dynamic-oracle training method of Goldberg and Nivre (2012; 2013) to train classifiers that produce probabilistic output. Evaluation of an Arc-Eager parser on 6 languages shows that the AdaGrad-RDA based training procedure results in models that provide the same high level of accuracy as the averagedperceptron trained models, while being sparser and providing well-calibrated probabilistic output."},{"id":"6c59a493fc3cb9ba9dbd003ed9234e4a.html","title":"Entailment graphs for text exploration.","url":"https://jssp2013.fbk.eu/sites/jssp2013.fbk.eu/files/IdoBernardo.pdf","authors":["Ido Dagan","Bernardo Magnini"],"date":"2013/11/20","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Total citations"},{"id":"1168a4cdf744ea90edeb21c5588a2cd5.html","title":"Overview of the SPMRL 2013 shared task: cross-framework evaluation of parsing morphologically rich languages","url":"http://doras.dcu.ie/19958/","authors":["Djam\\\\xe9 Seddah","Reut Tsarfaty","Sandra K\\\\xfcbler","Marie Candito","Jinho Choi","Rich\\\\xe1rd Farkas","Jennifer Foster","Iakes Goenaga","Koldo Gojenola","Yoav Goldberg","Spence Green","Nizar Habash","Marco Kuhlmann","Wolfgang Maier","Joakim Nivre","Adam Przepi\\\\xf3rkowski","Ryan Roth","Wolfgang Seeker","Yannick Versley","Veronika Vincze","Marcin Wolinski","Alina Wr\\\\xf3blewska","Eric Villemonte de la Cl\\\\xe9rgerie"],"date":"2013/10/18","abstract":""},{"id":"95612b904b7f970195483f7922cca867.html","title":"Consolidating and Exploring Information via Textual Inference","url":"https://link.springer.com/chapter/10.1007/978-3-319-02432-5_1","authors":["Ido Dagan"],"date":"2013/10/07","abstract":"Effectively consuming information from large amounts of texts, which are often largely redundant in their content, is an old but increasingly pressing challenge. It is well illustrated by the perpetual attempts to move away from the flat result lists of search engines towards more structured fact-based presentations. Some recent attempts at this challenge are based on presenting structured information that was formulated according to pre-defined knowledge schemes, such as Freebase and Google\u2019s knowledge graph. We propose an alternative, as well as complementary, approach that attempts to consolidate and structure all textual statements in a document collection based on the inference relations between them. Generic textual inference techniques, formulated under the Textual Entailment paradigm, are used to consolidate redundant information into unique \u201ccore\u201d statements, and then present them in an\\\\xa0\u2026"},{"id":"ae82a54faca3eb25273d8c4b11b3767c.html","title":"Training Deterministic Parsers with Non-Deterministic Oracles","url":"https://www.mitpressjournals.org/doi/abs/10.1162/tacl_a_00237","authors":["Yoav Goldberg","Joakim Nivre"],"date":"2013/10","journal":"Transactions of the Association for Computational Linguistics","abstract":"Greedy transition-based parsers are very fast but tend to suffer from error propagation. This problem is aggravated by the fact that they are normally trained using oracles that are deterministic and incomplete in the sense that they assume a unique canonical path through the transition system and are only valid as long as the parser does not stray from this path. In this paper, we give a general characterization of oracles that are nondeterministic and complete, present a method for deriving such oracles for transition systems that satisfy a property we call arc decomposition, and instantiate this method for three well-known transition systems from the literature. We say that these oracles are dynamic, because they allow us to dynamically explore alternative and nonoptimal paths during training \u2014 in contrast to\\\\xa0\u2026"},{"id":"50cdd02272751f01c2ff1d9be02d3edd.html","title":"PLIS: A probabilistic lexical inference system","url":"https://www.aclweb.org/anthology/P13-4017.pdf","authors":["Eyal Shnarch","Erel Segal-haLevi","Jacob Goldberger","Ido Dagan"],"date":"2013/08","abstract":"This paper presents PLIS, an open source Probabilistic Lexical Inference System which combines two functionalities:(i) a tool for integrating lexical inference knowledge from diverse resources, and (ii) a framework for scoring textual inferences based on the integrated knowledge. We provide PLIS with two probabilistic implementation of this framework. PLIS is available for download and developers of text processing applications can use it as an off-the-shelf component for injecting lexical knowledge into their applications. PLIS is easily configurable, components can be extended or replaced with user generated ones to enable system customization and further research. PLIS includes an online interactive viewer, which is a powerful tool for investigating lexical inference processes."},{"id":"aa6f9d88ad1e42107d7731893b1c107c.html","title":"A two level model for context sensitive inference rules","url":"https://www.aclweb.org/anthology/P13-1131.pdf","authors":["Oren Melamud","Jonathan Berant","Ido Dagan","Jacob Goldberger","Idan Szpektor"],"date":"2013/08","abstract":"Automatic acquisition of inference rules for predicates has been commonly addressed by computing distributional similarity between vectors of argument words, operating at the word space level. A recent line of work, which addresses context sensitivity of rules, represented contexts in a latent topic space and computed similarity over topic vectors. We propose a novel two-level model, which computes similarities between word-level vectors that are biased by topic-level context representations. Evaluations on a naturallydistributed dataset show that our model significantly outperforms prior word-level and topic-level models. We also release a first context-sensitive inference rule set."},{"id":"cc4c96c91e1d47d80b5549c886423ffe.html","title":"A unified morpho-syntactic scheme of Stanford dependencies","url":"https://www.aclweb.org/anthology/P13-2103.pdf","authors":["Reut Tsarfaty"],"date":"2013/08","abstract":"Stanford Dependencies (SD) provide a functional characterization of the grammatical relations in syntactic parse-trees. The SD representation is useful for parser evaluation, for downstream applications, and, ultimately, for natural language understanding, however, the design of SD focuses on structurally-marked relations and under-represents morphosyntactic realization patterns observed in Morphologically Rich Languages (MRLs). We present a novel extension of SD, called Unified-SD (U-SD), which unifies the annotation of structurally-and morphologically-marked relations via an inheritance hierarchy. We create a new resource composed of U-SD-annotated constituency and dependency treebanks for the MRL Modern Hebrew, and present two systems that can automatically predict U-SD annotations, for gold segmented input as well as raw texts, with high baseline accuracy. 1 Introduction"},{"id":"d58b7a3b751ff79f736a7f7838240369.html","title":"Recognizing partial textual entailment","url":"https://www.aclweb.org/anthology/P13-2080.pdf","authors":["Omer Levy","Torsten Zesch","Ido Dagan","Iryna Gurevych"],"date":"2013/08","abstract":"Textual entailment is an asymmetric relation between two text fragments that describes whether one fragment can be inferred from the other. It thus cannot capture the notion that the target fragment is \u201calmost entailed\u201d by the given text. The recently suggested idea of partial textual entailment may remedy this problem. We investigate partial entailment under the faceted entailment model and the possibility of adapting existing textual entailment methods to this setting. Indeed, our results show that these methods are useful for recognizing partial entailment. We also provide a preliminary assessment of how partial entailment may be used for recognizing (complete) textual entailment."},{"id":"da76c31881d4450521437de3847d553b.html","title":"Using lexical expansion to learn inference rules from sparse data","url":"https://www.aclweb.org/anthology/P13-2051.pdf","authors":["Oren Melamud","Ido Dagan","Jacob Goldberger","Idan Szpektor"],"date":"2013/08","abstract":"Automatic acquisition of inference rules for predicates is widely addressed by computing distributional similarity scores between vectors of argument words. In this scheme, prior work typically refrained from learning rules for low frequency predicates associated with very sparse argument vectors due to expected low reliability. To improve the learning of such rules in an unsupervised way, we propose to lexically expand sparse argument word vectors with semantically similar words. Our evaluation shows that lexical expansion significantly improves performance in comparison to state-of-the-art baselines."},{"id":"3d242a0f833e12b14f2ef49efa34292e.html","title":"Recognizing textual entailment: Models and applications","url":"https://www.morganclaypool.com/doi/abs/10.2200/s00509ed1v01y201305hlt023","authors":["Ido Dagan","Dan Roth","Mark Sammons","Fabio Massimo Zanzotto"],"date":"2013/07/19","journal":"Synthesis Lectures on Human Language Technologies","abstract":" <b>Download Free Sample</b> "},{"id":"220cfd787c201c2108c1a409c1b605ff.html","title":"Deliverable 8.1: Open platform evaluation and distribution, I cycle","url":"http://scholar.google.com/scholar?cluster=4013713709989633612&hl=en&oi=scholarr","authors":["Amir H Moin","Gunter Neumann","Bernardo Magnini","Roberto Zanoli","Sebastian Pado","Ido Dagan","Asher Stern","Ofer Bronstein","Omer Levy"],"date":"2013/07/10","abstract":"According to the work plan of the project, the first free open source distribution release of the EXCITEMENT Open Platform (EOP), based on the source code developed in work package 4 (WP4) and the knowledge resources provided by work package 5 (WP5), has been"},{"id":"0720d2b0c33dfc69dd016515ea582b42.html","title":"Truthteller: Annotating predicate truth","url":"https://www.aclweb.org/anthology/N13-1091.pdf","authors":["Amnon Lotan","Asher Stern","Ido Dagan"],"date":"2013/06","abstract":"We propose a novel semantic annotation type of assigning truth values to predicate occurrences, and present TruthTeller, a standalone publiclyavailable tool that produces such annotations. TruthTeller integrates a range of semantic phenomena, such as negation, modality, presupposition, implicativity, and more, which were dealt only partly in previous works. Empirical evaluations against human annotations show satisfactory results and suggest the usefulness of this new type of tool for NLP."},{"id":"2ffe549474aef70bbb84e82d5e9cfdb2.html","title":"SemEval-2013 Task 7: The Joint Student Response Analysis and 8th Recognizing Textual Embodiment Challenge","url":"https://digital.library.unt.edu/ark:/67531/metadc993399/","authors":["Myroslava O Dzikovska","Rodney D Nielsen","Chris Brew","Claudia Leacock","Danilo Giampiccolo","Luisa Bentivogli","Peter Clark","Ido Dagan","Hoa Trang Dang"],"date":"2013/06","journal":"Second Joint Conference on Lexical and Computational Semantics (* SEM): Seventh International Workshop on Semantic Evaluation (SemEval 2013)","abstract":"We present the results of the Joint Student Response Analysis and 8th Recognizing Textual Entailment Challenge, aiming to bring together researchers in educational NLP technology and textual entailment. The task of giving feedback on student answers requires semantic inference and therefore is related to recognizing textual entailment. Thus, we offered to the community a 5-way student response labeling task, as well as 3-way and 2-way RTE-style tasks on educational data. In addition, a partial entailment task was piloted. We present and compare results from 9 participating teams, and discuss future directions."},{"id":"8c7f9a7b72eda6b7a01e30a46cdf2830.html","title":"<b>Design Patterns in Fluid Construction Grammar</b> <b>Luc Steels (editor)</b> Universitat Pompeu Fabra and Sony Computer Science Laboratory, Paris Amsterdam: John\\\\xa0\u2026","url":"https://www.mitpressjournals.org/doi/abs/10.1162/COLI_r_00154","authors":["Nathan Schneider","Reut Tsarfaty"],"date":"2013/06","abstract":"Design Patterns in Fluid Construction Grammar Luc Steels (editor) Universitat Pompeu Fabra and Sony Computer Science Laboratory,"},{"id":"95790c37617c508258b8854efe3726a3.html","title":"UKP-BIU: Similarity and entailment metrics for student response analysis","url":"https://www.aclweb.org/anthology/S13-2048.pdf","authors":["Omer Levy","Torsten Zesch","Ido Dagan","Iryna Gurevych"],"date":"2013/06","abstract":"Our system combines text similarity measures with a textual entailment system. In the main task, we focused on the influence of lexicalized versus unlexicalized features, and how they affect performance on unseen questions and domains. We also participated in the pilot partial entailment task, where our system significantly outperforms a strong baseline."},{"id":"c0a37659a3ef7a08865807f40e5c8016.html","title":"Semeval-2013 task 7: The joint student response analysis and 8th recognizing textual entailment challenge","url":"http://scholar.google.com/scholar?cluster=8805697316973288288&hl=en&oi=scholarr","authors":["Myroslava O Dzikovska","Rodney D Nielsen","Chris Brew","Claudia Leacock","Danilo Giampiccolo","Luisa Bentivogli","Peter Clark","Ido Dagan","Hoa T Dang"],"date":"2013/06","abstract":"We present the results of the Joint Student Response Analysis and 8th Recognizing Textual Entailment Challenge, aiming to bring together researchers in educational NLP technology and textual entailment. The task of giving feedback on student answers requires semantic inference and therefore is related to recognizing textual entailment. Thus, we offered to the community a 5-way student response labeling task, as well as 3-way and 2-way RTE-style tasks on educational data. In addition, a partial entailment task was piloted. We present and compare results from 9 participating teams, and discuss future directions."},{"id":"3552c6d949fcb36062a7e09854f918e4.html","title":"Automatic thesaurus construction for cross generation corpus","url":"https://dl.acm.org/doi/abs/10.1145/2442080.2442084","authors":["Hadas Zohar","Chaya Liebeskind","Jonathan Schler","Ido Dagan"],"date":"2013/04/11","journal":"Journal on Computing and Cultural Heritage (JOCCH)","abstract":"This article describes methods for semiautomatic thesaurus construction, for a cross generation, cross genre, and cross cultural corpus. Semiautomatic thesaurus construction is a complex task, and applying it on a cross generation corpus brings its own challenges. We used a Jewish juristic corpus containing documents and genres that were written across 2000 years, and contain a mix of different languages, dialects, geographies, and writing styles. We evaluated different first and second order methods, and introduced a special annotation scheme for this problem, which showed that first order methods performed surprisingly well. We found that in our case, improving the coverage is the more difficult task, for this we introduce a new algorithm to increase recall (coverage)\u2014which is applicable to many other problems as well, and demonstrates significant improvement in our corpus."},{"id":"d6d5fd865d700c52b9c13618b3748dda.html","title":"Parsing morphologically rich languages: Introduction to the special issue","url":"https://www.mitpressjournals.org/doi/abs/10.1162/COLI_a_00133","authors":["Reut Tsarfaty","Djam\\\\xe9 Seddah","Sandra K\\\\xfcbler","Joakim Nivre"],"date":"2013/03","journal":"Computational linguistics","abstract":"Parsing is a key task in natural language processing. It involves predicting, for each natural language sentence, an abstract representation of the grammatical entities in the sentence and the relations between these entities. This representation provides an interface to compositional semantics and to the notions of \u201cwho did what to whom.\u201d The last two decades have seen great advances in parsing English, leading to major leaps also in the performance of applications that use parsers as part of their backbone, such as systems for information extraction, sentiment analysis, text summarization, and machine translation. Attempts to replicate the success of parsing English for other languages have often yielded unsatisfactory results. In particular, parsing languages with complex word structure and flexible word order has been shown to require non-trivial adaptation. This special issue reports on methods that successfully\\\\xa0\u2026"},{"id":"dd4d2b676e414e0c4445bc5254fbaee3.html","title":"Word Segmentation, Unknown-word Resolution, and Morphological Agreement in a Hebrew Parsing System","url":"https://www.mitpressjournals.org/doi/abs/10.1162/COLI_a_00137","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2013/03","journal":"Computational Linguistics","abstract":"We present a constituency parsing system for Modern Hebrew. The system is based on the PCFG-LA parsing method of Petrov et al. , which is extended in various ways in order to accommodate the specificities of Hebrew as a morphologically rich language with a small treebank. We show that parsing performance can be enhanced by utilizing a language resource external to the treebank, specifically, a lexicon-based morphological analyzer. We present a computational model of interfacing the external lexicon and a treebank-based parser, also in the common case where the lexicon and the treebank follow different annotation schemes. We show that Hebrew word-segmentation and constituency-parsing can be performed jointly using CKY lattice parsing. Performing the tasks jointly is effective, and substantially outperforms a pipeline-based model. We suggest modeling grammatical agreement in a constituency\\\\xa0\u2026"},{"id":"366ca3dd4aa01b55b5a9356f316a8b5f.html","title":"A Dataset of Syntactic-Ngrams over Time from a Very Large Corpus of English Books","url":"https://research.google/pubs/pub41603.pdf","authors":["Yoav Goldberg","Jon Orwant"],"date":"2013","abstract":"We created a dataset of syntactic-ngrams (counted dependency-tree fragments) based on a corpus of 3.5 million English books. The dataset includes over 10 billion distinct items covering a wide range of syntactic configurations. It also includes temporal information, facilitating new kinds of research into lexical semantics over time. This paper describes the dataset, the syntactic representation, and the kinds of information provided."},{"id":"63150439e95494cad82a162062bbbfbe.html","title":"Proceedings of the Fourth Workshop on Statistical Parsing of Morphologically-Rich Languages","url":"https://www.aclweb.org/anthology/W13-4900.pdf","authors":["Yoav Goldberg","Yuval Marton","Ines Rehbein","Yannick Versley"],"date":"2013","journal":"Proceedings of the Fourth Workshop on Statistical Parsing of Morphologically-Rich Languages","abstract":"The papers in these proceedings were presented at the fourth Workshop on Statistical Parsing of Morphologically Rich Languages (SPMRL 2013), held in Seattle, USA, on October 18th, 2013, in conjunction with the Conference on Empirical Methods in Natural Language Processing (EMNLP 2013). SPMRL is endorsed by the ACL SIGPARSE and SIGLEX interest groups and provides a forum for research in parsing morphologically-rich languages, with the goal of identifying cross-cutting issues in the annotation and parsing methodology for such languages, which typically have more flexible word order and/or higher word-form variation than English."},{"id":"63c84d150a628d1d8e60f38b2e6b2b62.html","title":"Book Review: Design Patterns in Fluid Construction Grammar edited by Luc Steels","url":"https://aclanthology.org/J13-2006.pdf","authors":["Nathan Schneider","Reut Tsarfaty"],"date":"2013","journal":"Computational Linguistics","abstract":"In computational modeling of natural language phenomena, there are at least three modes of research. The currently dominant statistical paradigm typically prioritizes instance coverage: Data-driven methods seek to use as much information observed in data as possible in order to generalize linguistic analyses to unseen instances. A second approach prioritizes detailed description of grammatical phenomena, that is, forming and defending theories with a focus on a small number of instances. A third approach might be called integrative: Rather than addressing phenomena in isolation, different approaches are brought together to address multiple challenges in a unified framework, and the behavior of the system is demonstrated with a small number of instances. Design"},{"id":"6e30e8fd2a3925f46ece6e9d58596d69.html","title":"Recognizing textual entailment","url":"https://pdfs.semanticscholar.org/e9cb/15132afd04ae93ba693044fd73f6746f58c4.pdf","authors":["Ido Dagan","Dan Roth","Mark Sammons","Fabio Zanzotto"],"date":"2013","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Total citations"},{"id":"8b6c041d53a2627ccb548aaf993a92a0.html","title":"Universal Dependency Annotation for Multilingual Parsing.","url":"https://www.aclweb.org/anthology/P13-2017.pdf","authors":["Ryan T McDonald","Joakim Nivre","Yvonne Quirmbach-Brundage","Yoav Goldberg","Dipanjan Das","Kuzman Ganchev","Keith B Hall","Slav Petrov","Hao Zhang","Oscar T\\\\xe4ckstr\\\\xf6m","Claudia Bedini","N\\\\xfaria Bertomeu Castell\\\\xf3","Jungmee Lee"],"date":"2013","abstract":"We present a new collection of treebanks with homogeneous syntactic dependency annotation for six languages: German, English, Swedish, Spanish, French and Korean. To show the usefulness of such a resource, we present a case study of crosslingual transfer parsing with more reliable evaluation than has been possible before. This \u2018universal\u2019treebank is made freely available in order to facilitate research on multilingual dependency parsing. 1"},{"id":"9fc950d91120cb30652343715fc96fa5.html","title":"A Non-Monotonic Arc-Eager Transition System for Dependency Parsing","url":"https://www.aclweb.org/anthology/W13-3518.pdf","authors":["Matthew Honnibal","Yoav Goldberg","Markn Johnson"],"date":"2013","abstract":"Previous incremental parsers have used monotonic state transitions. However, transitions can be made to revise previous decisions quite naturally, based on further information."},{"id":"c321a86bcb1bcbad1b67d5e44022472e.html","title":"Efficient Implementation of Beam-Search Incremental Parsers","url":"https://www.aclweb.org/anthology/P13-2111.pdf","authors":["Yoav Goldberg","Kai Zhao","Liang Huang"],"date":"2013","abstract":"Beam search incremental parsers are accurate, but not as fast as they could be. We demonstrate that, contrary to popular belief, most current implementations of beam parsers in fact run in O (n2), rather than linear time, because each statetransition is actually implemented as an O (n) operation. We present an improved implementation, based on Tree Structured Stack (TSS), in which a transition is performed in O (1), resulting in a real lineartime algorithm, which is verified empirically. We further improve parsing speed by sharing feature-extraction and dotproduct across beam items. Practically, our methods combined offer a speedup of\u223c 2x over strong baselines on Penn Treebank sentences, and are orders of magnitude faster on much longer sentences."},{"id":"e1f2be14ce3ff1c744b95dcfe8b3b701.html","title":"A dynamic oracle for arc-eager dependency parsing","url":"https://www.aclweb.org/anthology/C12-1059.pdf","authors":["Yoav Goldberg","Joakim Nivre"],"date":"2012/12","abstract":"The standard training regime for transition-based dependency parsers makes use of an oracle, which predicts an optimal transition sequence for a sentence and its gold tree. We present an improved oracle for the arc-eager transition system, which provides a set of optimal transitions for every valid parser configuration, including configurations from which the gold tree is not reachable. In such cases, the oracle provides transitions that will lead to the best reachable tree from the given configuration. The oracle is efficient to implement and provably correct. We use the oracle to train a deterministic left-to-right dependency parser that is less sensitive to error propagation, using an online training procedure that also explores parser configurations resulting from non-optimal sequences of transitions. This new parser outperforms greedy parsers trained using conventional oracles on a range of data sets, with an average improvement of over 1.2 LAS points and up to almost 3 LAS points on some data sets."},{"id":"7cc8e2bc310a0dd3761182f531053e03.html","title":"Semantic annotation for textual entailment recognition","url":"https://link.springer.com/chapter/10.1007/978-3-642-37798-3_2","authors":["Assaf Toledo","Sophia Katrenko","Stavroula Alexandropoulou","Heidi Klockmann","Asher Stern","Ido Dagan","Yoad Winter"],"date":"2012/10/27","abstract":"We introduce a new semantic annotation scheme for the Recognizing Textual Entailment (RTE) dataset as well as a manually annotated dataset that uses this scheme. The scheme addresses three types of modification that license entailment patterns: <i>restrictive</i>, <i>appositive</i> and <i>conjunctive</i>, with a formal semantic specification of these patterns\u2019 contribution for establishing entailment. These inferential constructions were found to occur in 77.68% of the entailments in the RTE 1-3 corpora. They were annotated with cross-annotator agreement of 70.73% on average. A central aim of our annotations is to examine components that address these phenomena in RTE systems. Specifically, the new annotated dataset is used for examining a syntactic rule base within the BIUTEE recognizer, a publicly available entailment system. According to our tests, the rule base is rarely used to process the phenomena\\\\xa0\u2026"},{"id":"3bffee13958cc941eca266f577e5560b.html","title":"Event orientated adnominals and compositionality","url":"https://www.phil.uu.nl/~yoad/papers/WinterZwartsEventAdnominals.pdf","authors":["Yoad Winter","Joost Zwarts"],"date":"2012/10","journal":"Unpublished Ms., to appear in Proceedings of Annual Meeting of the Israeli Association of Theoretical Linguistics","abstract":"When a noun is modified by an adnominal, as in blue door, short giraffe, or book on the table, the modifier is often analyzed as applying to an argument of the predicate that the noun denotes. We call this argument the referential argument of the noun (Williams 1981, Higginbotham 1985). Consider for instance (1).(1) a.[[blue door]]= \u03bbx. door (x)< x is blue b.[[short giraffe]]= \u03bbx. giraffe (x)< x is short (relative to giraffes) c.[[book on the table]]= \u03bbx. book (x)< x is on the table"},{"id":"f9bea65f13ea0df7d40bbf30535758a5.html","title":"Textual entailment","url":"https://nlpado.de/~sebastian/pub/papers/ox13_pado_preprint.pdf","authors":["Sebastian Pad\\\\xf3","Ido Dagan"],"date":"2012/08/29","journal":"Oxford Handbook of Computational Linguistics. Oxford University Press, Oxford","abstract":"Textual entailment is a binary relation between two natural language texts (the so-called text and hypothesis) that holds when readers of the text would agree that the hypothesis is most likely true (Peter is snoring\u2192 A man sleeps). The recognition of textual entailment requires an account of linguistic variability (ie, the possibility to realize a certain state of affairs in different ways, as in Peter buys the car\u2194 The car is purchased by Peter) as well as of the derivation of additional knowledge (as in Peter buys the car\u2192 Peter owns the car). In contrast to classical (logics-based) inference, textual entailment also covers cases of very probable, but still defeasible, entailment (A hurricane hit Peter\u2019s town\u2192 Peter\u2019s town was damaged). A substantial part of human common-sense reasoning involves such defeasible inferences. As a consequence, textual entailment is of considerable interest for many real-world language processing tasks where it can serve as a generic, application-independent framework for semantic inference. This chapter discusses the history of textual entailment, relevant linguistic phenomena, approaches to recognizing textual entailment, and its integration in various NLP tasks."},{"id":"084cc39218d8d2d987106fe995f846a1.html","title":"Houvardas, J., and E. Stamatatos (2006).","url":"http://library.oapen.org/bitstream/handle/20.500.12657/27654/1002351.pdf?sequence=1#page=308","authors":["V Keselj","F Peng","N Cercone","C Thomas","M Koppel","N Akiva","Ido Dagan","J Schler","S Argamon","S Raghavan","A Kovashka","R Mooney","Y Seroussi","I Zukerman","F Bohnert"],"date":"2012/07/16","journal":"Digital Humanities 2012","abstract":"Dogon languages are spoken predominately in eastern Mali in West Africa. The Dogon were made famous by Marcel Griaule, a French anthropologist who pioneered Ethnography in France, and worked with the Dogon between 1931-1956. He reported that the Dogon had advanced astronomical knowledge of the Sirius binary star system, knowledge that is not possible without telescope. Since then, the Dogon have been shrouded in controversy and mystery."},{"id":"dc7f74d882353edb2ee95865c8a4b3f2.html","title":"Domain adaptation of a dependency parser with a class-class selectional preference model","url":"https://www.aclweb.org/anthology/W12-3308.pdf","authors":["Raphael Cohen","Yoav Goldberg","Michael Elhadad"],"date":"2012/07/09","abstract":"When porting parsers to a new domain, many of the errors are related to wrong attachment of out-of-vocabulary words. Since there is no available annotated data to learn the attachment preferences of the target domain words, we attack this problem using a model of selectional preferences based on domainspecific word classes. Our method uses Latent Dirichlet Allocations (LDA) to learn a domain-specific Selectional Preference model in the target domain using un-annotated data. The model provides features that model the affinities among pairs of words in the domain. To incorporate these new features in the parsing model, we adopt the co-training approach and retrain the parser with the selectional preferences features. We apply this method for adapting Easy First, a fast nondirectional parser trained on WSJ, to the biomedical domain (Genia Treebank). The Selectional Preference features reduce error by 4.5% over the co-training baseline."},{"id":"6e83f7989aac934e6f9adccfa3b66608.html","title":"Efficient tree-based approximation for entailment graph learning","url":"https://www.aclweb.org/anthology/P12-1013.pdf","authors":["Jonathan Berant","Ido Dagan","Meni Adler","Jacob Goldberger"],"date":"2012/07","abstract":"Learning entailment rules is fundamental in many semantic-inference applications and has been an active field of research in recent years. In this paper we address the problem of learning transitive graphs that describe entailment rules between predicates (termed entailment graphs). We first identify that entailment graphs exhibit a \u201ctree-like\u201d property and are very similar to a novel type of graph termed forest-reducible graph. We utilize this property to develop an iterative efficient approximation algorithm for learning the graph edges, where each iteration takes linear time. We compare our approximation algorithm to a recently-proposed state-of-the-art exact algorithm and show that it is more efficient and scalable both theoretically and empirically, while its output quality is close to that given by the optimal solution of the exact algorithm."},{"id":"7a70d4523bfbbdd4fd00f9d2565604d6.html","title":"Learning verb inference rules from linguistically-motivated evidence","url":"https://www.aclweb.org/anthology/D12-1018.pdf","authors":["Hila Weisman","Jonathan Berant","Idan Szpektor","Ido Dagan"],"date":"2012/07","abstract":"Learning inference relations between verbs is at the heart of many semantic applications. However, most prior work on learning such rules focused on a rather narrow set of information sources: mainly distributional similarity, and to a lesser extent manually constructed verb co-occurrence patterns. In this paper, we claim that it is imperative to utilize information from various textual scopes: verb co-occurrence within a sentence, verb cooccurrence within a document, as well as overall corpus statistics. To this end, we propose a much richer novel set of linguistically motivated cues for detecting entailment between verbs and combine them as features in a supervised classification framework. We empirically demonstrate that our model significantly outperforms previous methods and that information from each textual scope contributes to the verb entailment learning task."},{"id":"84ece2bdea9fc53240c553f8913b71b6.html","title":"Entailment-based text exploration with application to the health-care domain","url":"https://www.aclweb.org/anthology/P12-3014.pdf","authors":["Meni Adler","Jonathan Berant","Ido Dagan"],"date":"2012/07","abstract":"We present a novel text exploration model, which extends the scope of state-of-the-art technologies by moving from standard concept-based exploration to statement-based exploration. The proposed scheme utilizes the textual entailment relation between statements as the basis of the exploration process. A user of our system can explore the result space of a query by drilling down/up from one statement to another, according to entailment relations specified by an entailment graph and an optional concept taxonomy. As a prominent use case, we apply our exploration system and illustrate its benefit on the health-care domain. To the best of our knowledge this is the first implementation of an exploration system at the statement level that is based on the textual entailment relation."},{"id":"8ad97e761f4c0dcd426cb897a86fa496.html","title":"Biutee: A modular open-source system for recognizing textual entailment","url":"https://www.aclweb.org/anthology/P12-3013.pdf","authors":["Asher Stern","Ido Dagan"],"date":"2012/07","abstract":"This paper introduces BIUTEE 1, an opensource system for recognizing textual entailment. Its main advantages are its ability to utilize various types of knowledge resources, and its extensibility by which new knowledge resources and inference components can be easily integrated. These abilities make BIUTEE an appealing RTE system for two research communities:(1) researchers of end applications, that can benefit from generic textual inference, and (2) RTE researchers, who can integrate their novel algorithms and knowledge resources into our system, saving the time and effort of developing a complete RTE system from scratch. Notable assistance for these researchers is provided by a visual tracing tool, by which researchers can refine and \u201cdebug\u201d their knowledge resources and inference components."},{"id":"bcdd132a9ddde1cf69065c99824d5c71.html","title":"Efficient search for transformation-based inference","url":"https://www.aclweb.org/anthology/P12-1030.pdf","authors":["Asher Stern","Roni Stern","Ido Dagan","Ariel Felner"],"date":"2012/07","abstract":"This paper addresses the search problem in textual inference, where systems need to infer one piece of text from another. A prominent approach to this task is attempts to transform one text into the other through a sequence of inference-preserving transformations, aka a proof, while estimating the proof\u2019s validity. This raises a search challenge of finding the best possible proof. We explore this challenge through a comprehensive investigation of prominent search algorithms and propose two novel algorithmic components specifically designed for textual inference: a gradient-style evaluation function, and a locallookahead node expansion method. Evaluations, using the open-source system, BIUTEE, show the contribution of these ideas to search efficiency and proof quality."},{"id":"fb6cd0a51751f417d524071bb68ce84b.html","title":"Crowdsourcing inference-rule evaluation","url":"https://www.aclweb.org/anthology/P12-2031.pdf","authors":["Naomi Zeichner","Jonathan Berant","Ido Dagan"],"date":"2012/07","abstract":"The importance of inference rules to semantic applications has long been recognized and extensive work has been carried out to automatically acquire inference-rule resources. However, evaluating such resources has turned out to be a non-trivial task, slowing progress in the field. In this paper, we suggest a framework for evaluating inference-rule resources. Our framework simplifies a previously proposed \u201cinstance-based evaluation\u201d method that involved substantial annotator training, making it suitable for crowdsourcing. We show that our method produces a large amount of annotations with high inter-annotator agreement for a low cost at a short period of time, without requiring training expert annotators."},{"id":"fc7e018e1c6b4dfcff915c54a97fd25c.html","title":"Joint evaluation of morphological segmentation and syntactic parsing","url":"https://www.aclweb.org/anthology/P12-2002.pdf","authors":["Reut Tsarfaty","Joakim Nivre","Evelina Andersson"],"date":"2012/07","abstract":"We present novel metrics for parse evaluation in joint segmentation and parsing scenarios where the gold sequence of terminals is not known in advance. The protocol uses distance-based metrics defined for the space of trees over lattices. Our metrics allow us to precisely quantify the performance gap between non-realistic parsing scenarios (assuming gold segmented and tagged input) and realistic ones (not assuming gold segmentation and tags). Our evaluation of segmentation and parsing for Modern Hebrew sheds new light on the performance of the best parsing systems to date in the different scenarios."},{"id":"231349fed4d08f989e39f0bb24ac1905.html","title":"Precision-biased Parsing and High-Quality Parse Selection","url":"https://arxiv.org/abs/1205.4387","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2012/05/20","journal":"Arxiv preprint arXiv:1205.4387","abstract":"We introduce precision-biased parsing: a parsing task which favors precision over recall by allowing the parser to abstain from decisions deemed uncertain. We focus on dependency-parsing and present an ensemble method which is capable of assigning parents to 84% of the text tokens while being over 96% accurate on these tokens. We use the precision-biased parsing task to solve the related high-quality parse-selection task: finding a subset of high-quality (accurate) trees in a large collection of parsed text. We present a method for choosing over a third of the input trees while keeping unlabeled dependency parsing accuracy of 97% on these trees. We also present a method which is not based on an ensemble but rather on directly predicting the risk associated with individual parser decisions. In addition to its efficiency, this method demonstrates that a parsing system can provide reasonable estimates of confidence in its predictions without relying on ensembles or aggregate corpus counts."},{"id":"9a501fac2b05fd383c7a3519da295bcc.html","title":"Task-specific Word-Clustering for Part-of-Speech Tagging","url":"https://arxiv.org/abs/1205.4298","authors":["Yoav Goldberg"],"date":"2012/05/19","journal":"Arxiv preprint arXiv:1205.4298","abstract":"While the use of cluster features became ubiquitous in core NLP tasks, most cluster features in NLP are based on distributional similarity. We propose a new type of clustering criteria, specific to the task of part-of-speech tagging. Instead of distributional similarity, these clusters are based on the beha vior of a baseline tagger when applied to a large corpus. These cluster features provide similar gains in accuracy to those achieved by distributional-similarity derived clusters. Using both types of cluster features together further improve tagging accuracies. We show that the method is effective for both the in-domain and out-of-domain scenarios for English, and for French, German and Italian. The effect is larger for out-of-domain text."},{"id":"38f01f81bd6f9e50b621a53d11f993d8.html","title":"Proceedings of the ACL 2012 Joint Workshop on Statistical Parsing and Semantic Processing of Morphologically Rich Languages","url":"https://www.aclweb.org/anthology/W12-3400.pdf","authors":["Marianna Apidianaki","Ido Dagan","Jennifer Foster","Yuval Marton","Djam\\\\xe9 Seddah","Reut Tsarfaty"],"date":"2012","abstract":"Morphologically Rich Languages (MRLs) are languages in which grammatical relations such as Subject, Predicate, and Object, are largely indicated morphologically (eg, through inflection) instead of positionally. This poses serious challenges for current (English-centric) syntactic and semantic processing. Furthermore, since grammatical relations provide the interface to compositional semantics, morpho-syntactic phenomena may significantly complicate processing the syntax\u2013semantics interface. In statistical parsing, English parsing performance has reached a high plateau in certain genres. Semantic processing of English has similarly seen much progress in recent years. MRL processing presents new challenges, such as optimal morphological representation, non position-centric algorithms, or different semantic distance measures."},{"id":"4dd02b8444502483fbe695cce53cd47b.html","title":"A probabilistic lexical model for ranking textual inferences","url":"https://www.aclweb.org/anthology/S12-1032.pdf","authors":["Eyal Shnarch","Ido Dagan","Jacob Goldberger"],"date":"2012","abstract":"Identifying textual inferences, where the meaning of one text follows from another, is a general underlying task within many natural language applications. Commonly, it is approached either by generative syntactic-based methods or by \u201clightweight\u201d heuristic lexical models. We suggest a model which is confined to simple lexical information, but is formulated as a principled generative probabilistic model. We focus our attention on the task of ranking textual inferences and show substantially improved results on a recently investigated question answering data set."},{"id":"6ac5d14ef61d0d803a18a0b25f4d997b.html","title":"Statistical thesaurus construction for a morphologically rich language","url":"https://www.aclweb.org/anthology/S12-1009.pdf","authors":["Chaya Liebeskind","Ido Dagan","Jonathan Schler"],"date":"2012","abstract":"Corpus-based thesaurus construction for Morphologically Rich Languages (MRL) is a complex task, due to the morphological variability of MRL. In this paper we explore alternative term representations, complemented by clustering of morphological variants. We introduce a generic algorithmic scheme for thesaurus construction in MRL, and demonstrate the empirical benefit of our methodology for a Hebrew thesaurus."},{"id":"cefd7a13c7131c5ea387e0abc5d2230a.html","title":"Cross-Framework Evaluation for Statistical Parsing","url":"https://www.diva-portal.org/smash/record.jsf?pid=diva2:585582","authors":["Joakim Nivre","Reut Tsarfaty","Evelina Andersson"],"date":"2012","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"c4c63c710c90188a9520efbb513d3085.html","title":"Introduction to the EXCITEMENT project: towards an open platform for EXploring Customer Interactions through Textual entailMENT","url":"https://www.isca-speech.org/archive/avios_12/avio_024.html","authors":["Moshe Wasserblat","Ezra Daya","Eyal Hurvitz","Maya Gorodetsky","Dmitri Volsky","Ido Dagan","Meni Adler","Asher Steren","Sebastian Pado","Tae-Gil Noh","Britta Zeller","G\\\\xfcnter Neumann","Kathrin Eichler","Rui Wang","Gabriele Fidanza","Giorgio Gianforme","Matthias Meisdrock","Bernardom Magnini","Luisa Bentivogli","Roberto Zanoli","Alberto Lavelli"],"date":"2012","abstract":"Identifying semantic inferences between text units is a major underlying language processing task, needed in practically all text understanding applications. While such inferences are broadly needed, there are currently no generic semantic \u201cengines\u201d or platforms for broad textual inference. The primary scientific motivation for the EXCITEMENT project is to change this ineffective state of affairs and to offer an encompassing open source platform for textual inference. On the industrial side, EXCITEMENT is focused on the text analytics and speech analytics markets and follows the increasing demand for automatically analyzing customer interactions, which today cross multiple channels including speech, email, chat and social media."},{"id":"df461587fbf8682009caca3df1bbcabb.html","title":"Sentence clustering via projection over term clusters","url":"https://www.aclweb.org/anthology/S12-1005.pdf","authors":["Lili Kotlerman","Ido Dagan","Maya Gorodetsky","Ezra Daya"],"date":"2012","abstract":"This paper presents a novel sentence clustering scheme based on projecting sentences over term clusters. The scheme incorporates external knowledge to overcome lexical variability and small corpus size, and outperforms common sentence clustering methods on two reallife industrial datasets."},{"id":"78c3b7e65a109338cc25fffa50916b5d.html","title":"Automatic Syntactic Processing of Modern Hebrew","url":"https://www.cs.bgu.ac.il/~elhadad/nlpproj/pub/yoav-phd.pdf","authors":["Yoav Goldberg"],"date":"2011/11","abstract":"Natural language is the primary means of communication between humans. Language is composed of words, which are combined to form sentences, which, in turn, are combined to form larger units such as paragraphs. While single words can convey myriad meanings, it is the combination of words into sentences that allows for efficient communication and the realization of complex ideas. When words are combined to form a sentence, their combination is governed by a set of rules, called the syntax, or the grammar, of the language. These syntactic rules pose constraints on the ways in which words can be combined (\u201ckid cake the ate a\u201d is clearly ungrammatical), and assign meanings to valid configurations of words (\u201cthe kid ate a cake\u201d and \u201cthe cake ate a kid\u201d are both well formed sentences and contain the exact same words, yet they convey two entirely different messages. The first is an everyday event, while the second is a creepy event from a bizarre horror movie). In other words, sentences must obey structural constraints posed by the syntax, and the structure of the sentence determines its meaning. In many cases, the sentence structure can be recovered even when the sentence words are unknown: consider \u201cthe plumpets ghoked a gloomp\u201d\u2013without knowing what plumpets, ghoked or gloomp are (these are all made-up words), we know that there is an action of \u201cghoking\u201d, there is something called \u201cplumpets\u201d(probably composed of several \u201cplumpet\u201d) which is the subject of the ghoking action (which happened in the past) and that there is something called a \u201cgloomp\u201d which is the object of the ghoking action. This is an important property, that\\\\xa0\u2026"},{"id":"e0f5fc9dbccafd6b332fb833c34815ff.html","title":"The Seventh PASCAL Recognizing Textual Entailment Challenge.","url":"http://allenai.org/content/team/peterc/publications/RTE7_overview.proceedings.pdf","authors":["Luisa Bentivogli","Peter Clark","Ido Dagan","Danilo Giampiccolo"],"date":"2011/11","abstract":"This paper presents the Seventh Recognizing Textual Entailment (RTE-7) challenge. This year\u2019s challenge replicated the exercise proposed in RTE-6, consisting of a Main Task, in which Textual Entailment is performed on a real corpus in the Update Summarization scenario; a Main subtask aimed at detecting novel information; and a KBP Validation Task, in which RTE systems had to validate the output of systems participating in the KBP Slot Filling Task. Thirteen teams participated in the Main Task (submitting 33 runs) and 5 in the Novelty Detection Subtask (submitting 13 runs). The KBP Validation Task was undertaken by 2 participants which submitted 5 runs. The ablation test experiment, introduced in RTE-5 to evaluate the impact of knowledge resources used by the systems participating in the Main Task and extended also to tools in RTE-6, was also repeated in RTE-7."},{"id":"12d35eb89a1e48e0c7e3edf2e9cd37d9.html","title":"Knowledge and Tree-Edits in Learnable Entailment Proofs.","url":"https://www.researchgate.net/profile/Lili_Kotlerman/publication/267917672_Knowledge_and_Tree-Edits_in_Learnable_Entailment_Proofs/links/547472650cf2778985abddae/Knowledge-and-Tree-Edits-in-Learnable-Entailment-Proofs.pdf","authors":["Asher Stern","Shachar Mirkin","Eyal Shnarch","Lili Kotlerman","Ido Dagan","Amnon Lotan","Jonathan Berant"],"date":"2011/10/25","abstract":"This paper describes BIUTEE-Bar Ilan University Textual Entailment Engine. BIUTEE is a natural language inference system in which the hypothesis is proven by the text, based on linguistic-and world-knowledge resources, as well as syntactically motivated tree transformations. The main progress in BIUTEE in the last year is a new confidence model that estimates the validity of the proof found by BIUTEE."},{"id":"87948e71862a3e179cb566575508c69e.html","title":"Proceedings of the Second Workshop on Statistical Parsing of Morphologically Rich Languages","url":"https://www.aclweb.org/anthology/W11-3800.pdf","authors":["Djam\\\\xe9 Seddah","Reut Tsarfaty","Jennifer Foster"],"date":"2011/10","abstract":"Welcome to the second workshop on Statistical Parsing of Morphologically Rich Languages! Following the warm reception of the first official SPMRL workshop at NAACL-HLT 2010, our aim with the second workshop is to build upon the success of the first and offer a platform to the growing community of people who are interested in developing tools and resources for parsing MRLs. We decided to collocate with the International Workshop on Parsing Technologies (IWPT), both because the themes of the two events are so closely related and because the seeds of the SPMRL workshop were planted during IWPT 2009 in Paris. The warm welcome and support of the IWPT community made it our unequivocal choice, and we are honored and pleased to collocate our second SPMRL workshop with this year\u2019s IWPT event"},{"id":"6b7d4738b564dde1198537a1d1b65025.html","title":"A support tool for deriving domain taxonomies from wikipedia","url":"https://www.aclweb.org/anthology/R11-1069.pdf","authors":["Lili Kotlerman","Zemer Avital","Ido Dagan","Amnon Lotan","Ofer Weintraub"],"date":"2011/09","abstract":"Organizing data into category hierarchies (taxonomies) is useful for content discovery, search, exploration and analysis. In industrial settings targeted taxonomies for specific domains are mostly created manually, typically by domain experts, which is time consuming and requires a high level of expertise. This paper presents an algorithm and an implemented interactive system for automatically generating target-domain taxonomies based on the Wikipedia Category Hierarchy. The system also enables human post-editing, facilitated by intelligent assistance."},{"id":"94e66652d864fe89d2a0664de7e69ac9.html","title":"A confidence model for syntactically-motivated entailment proofs","url":"https://www.aclweb.org/anthology/R11-1063.pdf","authors":["Asher Stern","Ido Dagan"],"date":"2011/09","abstract":"This paper presents a novel method for recognizing textual entailment which derives the hypothesis from the text through a sequence of parse tree transformations. Unlike related approaches based on tree-edit-distance, we employ transformations which better capture linguistic structures of entailment. This is achieved by (a) extending an earlier deterministic knowledge-based algorithm with syntactically-motivated on-the-fly transformations, and (b) by introducing an algorithm that uniformly learns costs for all types of transformations. Our evaluations and analysis support the validity of this approach."},{"id":"dc51e24a091120c15e119bed64321e7f.html","title":"Sparse Canonical Correlation Analysis for Biomarker Discovery: A Case Study in Tuberculosis","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.232.9577&rep=rep1&type=pdf#page=81","authors":["Juho Rousu","Daniel D Agranoff","John Shawe-Taylor","Delmiro Fernandez-Reyes"],"date":"2011/07/20","journal":"Machine Learning in Systems Biology","abstract":"Biomarker discovery from\u2019omics data is a challenging task due to the high dimensionality of data and the relative scarcity of samples. Here we explore the potential of canonical correlation analysis, a family of methods that finds correlated components in two views. In particular we use the recently introduced technique of sparse canonical correlation analysis that finds a projection directions that are primally sparse in one of the views and dually sparse in the other view. Our experiments show that the method is able to discover meaningful feature combinations that may have use as biomarkers for tuberculosis."},{"id":"2f284473cf82cf4c1d68e45ee852ce7e.html","title":"Evaluating dependency parsing: Robust and heuristics-free cross-annotation evaluation","url":"https://www.aclweb.org/anthology/D11-1036.pdf","authors":["Reut Tsarfaty","Joakim Nivre","Evelina Andersson"],"date":"2011/07","abstract":"Methods for evaluating dependency parsing using attachment scores are highly sensitive to representational variation between dependency treebanks, making cross-experimental evaluation opaque. This paper develops a robust procedure for cross-experimental evaluation, based on deterministic unificationbased operations for harmonizing different representations and a refined notion of tree edit distance for evaluating parse hypotheses relative to multiple gold standards. We demonstrate that, for different conversions of the Penn Treebank into dependencies, performance trends that are observed for parsing results in isolation change or dissolve completely when parse hypotheses are normalized and brought into the same common ground."},{"id":"8f6891b1dac4a7963b34fbb3c75567f9.html","title":"Towards a probabilistic model for lexical entailment","url":"https://www.aclweb.org/anthology/W11-2402.pdf","authors":["Eyal Shnarch","Jacob Goldberger","Ido Dagan"],"date":"2011/07","abstract":"While modeling entailment at the lexical-level is a prominent task, addressed by most textual entailment systems, it has been approached mostly by heuristic methods, neglecting some of its important aspects. We present a probabilistic approach for this task which covers aspects such as differentiating various resources by their reliability levels, considering the length of the entailed sentence, the number of its covered terms and the existence of multiple evidence for the entailment of a term. The impact of our model components is validated by evaluations, which also show that its performance is in line with the best published entailment systems."},{"id":"ae7d28826457a8cb324c98aab352023f.html","title":"Classification-based contextual preferences","url":"https://www.aclweb.org/anthology/W11-2403.pdf","authors":["Shachar Mirkin","Ido Dagan","Lili Kotlerman","Idan Szpektor"],"date":"2011/07","abstract":"This paper addresses context matching in textual inference. We formulate the task under the Contextual Preferences framework which broadly captures contextual aspects of inference. We propose a generic classificationbased scheme under this framework which coherently attends to context matching in inference and may be employed in any inferencebased task. As a test bed for our scheme we use the Name-based Text Categorization (TC) task. We define an integration of Contextual Preferences into the TC setting and present a concrete self-supervised model which instantiates the generic scheme and is applied to address context matching in the TC task. Experiments on standard TC datasets show that our approach outperforms the state of the art in context modeling for Name-based TC."},{"id":"671dfed607987823a04e02b5df8f6d37.html","title":"Joint Hebrew segmentation and parsing using a PCFG-LA lattice parser","url":"https://www.aclweb.org/anthology/P11-2124.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2011/06/19","abstract":"We experiment with extending a lattice parsing methodology for parsing Hebrew (Goldberg and Tsarfaty, 2008; Golderg et al., 2009) to make use of a stronger syntactic model: the PCFG-LA Berkeley Parser. We show that the methodology is very effective: using a small training set of about 5500 trees, we construct a parser which parses and segments unsegmented Hebrew text with an F-score of almost 80%, an error reduction of over 20% over the best previous result for this task. This result indicates that lattice parsing with the Berkeley parser is an effective methodology for parsing over uncertain inputs."},{"id":"d7ed5380a7279526cde23e0d9bfbb62a.html","title":"Cross-partition clustering: revealing corresponding themes across related datasets","url":"https://www.tandfonline.com/doi/abs/10.1080/0952813X.2010.490960","authors":["Zvika Marx","Ido Dagan","Eli Shamir"],"date":"2011/06/01","journal":"Journal of Experimental & Theoretical Artificial Intelligence","abstract":"This article studies the task of discovering correspondences across related domains based on real-world data collections. We address this task through a designated extension of distributional data-clustering methods. The method is empirically demonstrated on synthetic data as well as on texts addressing different religions, where the goal is to identify commonalities shared by all religions. This article generalises and demonstrates the empirical improvement relative to our previous studies on this subject, as well as to other comparable methods."},{"id":"10b5842436697e001ee40dc30fa49b92.html","title":"Language-independent parsing with empty elements","url":"https://www.aclweb.org/anthology/P11-2037.pdf","authors":["Shu Cai","David Chiang","Yoav Goldberg"],"date":"2011/06","abstract":"We present a simple, language-independent method for integrating recovery of empty elements into syntactic parsing. This method outperforms the best published method we are aware of on English and a recently published method on Chinese."},{"id":"59577f4b618b4002841b83dd3cf1fea2.html","title":"A probabilistic modeling framework for lexical entailment","url":"https://www.aclweb.org/anthology/P11-2098.pdf","authors":["Eyal Shnarch","Jacob Goldberger","Ido Dagan"],"date":"2011/06","abstract":"Recognizing entailment at the lexical level is an important and commonly-addressed component in textual inference. Yet, this task has been mostly approached by simplified heuristic methods. This paper proposes an initial probabilistic modeling framework for lexical entailment, with suitable EM-based parameter estimation. Our model considers prominent entailment factors, including differences in lexical-resources reliability and the impacts of transitivity and multiple evidence. Evaluations show that the proposed model outperforms most prior systems while pointing at required future improvements."},{"id":"6d6b69b7692ec0389facfef65815db0b.html","title":"Global learning of typed entailment rules","url":"https://www.aclweb.org/anthology/P11-1062.pdf","authors":["Jonathan Berant","Ido Dagan","Jacob Goldberger"],"date":"2011/06","abstract":"Extensive knowledge bases of entailment rules between predicates are crucial for applied semantic inference. In this paper we propose an algorithm that utilizes transitivity constraints to learn a globally-optimal set of entailment rules for typed predicates. We model the task as a graph learning problem and suggest methods that scale the algorithm to larger graphs. We apply the algorithm over a large data set of extracted predicate instances, from which a resource of typed entailment rules has been recently released (Schoenmackers et al., 2010). Our results show that using global transitivity information substantially improves performance over this resource and several baselines, and that our scaling methods allow us to increase the scope of global learning of entailment-rule graphs."},{"id":"47b9f7c2dc31c45aa816e19449a2ee78.html","title":"Learning entailment relations by global graph structure optimization","url":"https://www.mitpressjournals.org/doi/abs/10.1162/COLI_a_00085","authors":["Jonathan Berant","Ido Dagan","Jacob Goldberger"],"date":"2011/03","journal":"Computational Linguistics","abstract":"Identifying entailment relations between predicates is an important part of applied semantic inference. In this article we propose a global inference algorithm that learns such entailment rules. First, we define a graph structure over predicates that represents entailment relations as directed edges. Then, we use a global transitivity constraint on the graph to learn the optimal set of edges, formulating the optimization problem as an Integer Linear Program. The algorithm is applied in a setting where, given a target concept, the algorithm learns on the fly all entailment rules between predicates that co-occur with this concept. Results show that our global algorithm improves performance over baseline algorithms by more than 10%."},{"id":"d74df2d5d948faabfb2f7316eed43fc5.html","title":"Transliterated pairs acquisition in medical Hebrew","url":"https://www.researchgate.net/profile/Michael_Elhadad/publication/266407564_Transliterated_Pairs_Acquisition_in_Medical_Hebrew/links/54b504610cf28ebe92e4acc0.pdf","authors":["Raphael Cohen","Yoav Goldberg","Michael Elhadad"],"date":"2011/01/23","journal":"Proc. Machine Translation and Morphologically-rich Languages Workshop","abstract":"The phonetic transcription of a word from a source language using a different script is called transliteration. Transliterations affect Information Extraction (IE) in two ways. First, it takes time for a transliterated word to make it into a technical lexicon, making recognition difficult. A second problem is the variability of ways a foreign word can be rendered phonetically, leading in most cases (except for very short words) to many possible spellings of the word and, therefore, making lexicon-based recognition difficult. In this paper, we present a method for automatically acquiring transliterated words and their source word in order to improve a technical lexicon, addressing both problems: spelling variants and unknown tokens."},{"id":"8f323dc44c0fea4bbe4f2ad3dc2a64c1.html","title":"Learning sparser perceptron models","url":"https://pdfs.semanticscholar.org/6a4b/296ed7102cde2da400fac7ce6f5f78d6d2de.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2011","abstract":"The averaged-perceptron learning algorithm is simple, versatile and effective. However, when used in NLP settings it tends to produce very dense solutions, while much sparser ones are also possible. We present a simple modification to the perceptron algorithm which allows it to produce sparser solutions while remaining accurate and computationally efficient. We test the method on a multiclass classification task, a structured prediction task, and a guided learning task. In all of the experiments the method produced models which are about 4-5 times smaller than the averaged perceptron, while remaining as accurate."},{"id":"d59078681ba9bb15faf2072d96be5b73.html","title":"Rich parameterization improves RNA structure prediction","url":"https://www.liebertpub.com/doi/abs/10.1089/cmb.2011.0184","authors":["Shay Zakov","Yoav Goldberg","Michael Elhadad","Michal Ziv-Ukelson"],"date":"2011","journal":"Research in Computational Molecular Biology","abstract":"Current approaches to RNA structure prediction range from physics-based methods, which rely on thousands of experimentally measured thermodynamic parameters, to machine-learning (ML) techniques. While the methods for parameter estimation are successfully shifting toward ML-based approaches, the model parameterizations so far remained fairly constant. We study the potential contribution of increasing the amount of information utilized by RNA folding prediction models to the improvement of their prediction quality. This is achieved by proposing novel models, which refine previous ones by examining more types of structural elements, and larger sequential contexts for these elements. Our proposed fine-grained models are made practical thanks to the availability of large training sets, advances in machine-learning, and recent accelerations to RNA folding algorithms. We show that the application of more\\\\xa0\u2026"},{"id":"10753ba2b719d51be50e0b4c96461a0a.html","title":"Rule Chaining and Approximate Match in textual inference.","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.418.7637&rep=rep1&type=pdf","authors":["Asher Stern","Eyal Shnarch","Shachar Mirkin","Lili Kotlerman","Naomi Zeichner","Ido Dagan","Amnon Lotan","Jonathan Berant"],"date":"2010/10/27","abstract":"This paper describes the participation of Bar-Ilan university in the sixth RTE challenge. Our textual-entailment engine, BiUTEE, was enhanced with new components that introduce chaining of lexical-entailment rules, and tackle the problem of approximately matching the text and the hypothesis after all available knowledge of entailment rules was utilized. We have also re-engineered our system aiming at an open-source open architecture. BiUTEE\u2019s performance is better than the median of all-submissions, and outperforms significantly an IR-oriented baseline."},{"id":"c3cc66f3aabc821a16bd7675c2c14f9a.html","title":"Directional distributional similarity for lexical inference","url":"https://u.cs.biu.ac.il/~nlp/downloads/publications/directional-distsim.pdf","authors":["Lili Kotlerman","Ido Dagan","Idan Szpektor","Maayan Zhitomirsky-Geffet"],"date":"2010/10/01","journal":"Natural Language Engineering","abstract":"Distributional word similarity is most commonly perceived as a symmetric relation. Yet, directional relations are abundant in lexical semantics and in many Natural Language Processing (NLP) settings that require lexical inference, making symmetric similarity measures less suitable for their identification. This paper investigates the nature of directional (asymmetric) similarity measures that aim to quantify distributional feature inclusion. We identify desired properties of such measures for lexical inference, specify a particular measure based on Average Precision that addresses these properties, and demonstrate the empirical benefit of directional measures for two different NLP datasets."},{"id":"86b29b844e11848052d42357a5ee6658.html","title":"Recognising entailment within discourse","url":"https://www.aclweb.org/anthology/C10-1087.pdf","authors":["Shachar Mirkin","Jonathan Berant","Ido Dagan","Eyal Shnarch"],"date":"2010/08","abstract":"Texts are commonly interpreted based on the entire discourse in which they are situated. Discourse processing has been shown useful for inference-based application; yet, most systems for textual entailment\u2013a generic paradigm for applied inference\u2013have only addressed discourse considerations via off-the-shelf coreference resolvers. In this paper we explore various discourse aspects in entailment inference, suggest initial solutions for them and investigate their impact on entailment performance. Our experiments suggest that discourse provides useful information, which significantly improves entailment inference, and should be better addressed by future entailment systems."},{"id":"74f931cf2438281038668db5ae922381.html","title":"Inspecting the structural biases of dependency parsing algorithms","url":"https://www.aclweb.org/anthology/W10-2927.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2010/07/15","abstract":"We propose the notion of a structural bias inherent in a parsing system with respect to the language it is aiming to parse. This structural bias characterizes the behaviour of a parsing system in terms of structures it tends to under-and over-produce. We propose a Boosting-based method for uncovering some of the structural bias inherent in parsing systems. We then apply our method to four English dependency parsers (an Arc-Eager and Arc-Standard transition-based parsers, and first-and second-order graph-based parsers). We show that all four parsers are biased with respect to the kind of annotation they are trained to parse. We present a detailed analysis of the biases that highlights specific differences and commonalities between the parsing systems, and improves our understanding of their strengths and weaknesses."},{"id":"3abbb47ac85de956d2bc52e7078ce2b1.html","title":"Global learning of focused entailment graphs","url":"https://www.aclweb.org/anthology/P10-1124.pdf","authors":["Jonathan Berant","Ido Dagan","Jacob Goldberger"],"date":"2010/07","abstract":"We propose a global algorithm for learning entailment relations between predicates. We define a graph structure over predicates that represents entailment relations as directed edges, and use a global transitivity constraint on the graph to learn the optimal set of edges, by formulating the optimization problem as an Integer Linear Program. We motivate this graph with an application that provides a hierarchical summary for a set of propositions that focus on a target concept, and show that our global algorithm improves performance by more than 10% over baseline algorithms."},{"id":"4a5b539f7217e5407e4c90c2661f5b4d.html","title":"Generating entailment rules from framenet","url":"https://www.aclweb.org/anthology/P10-2045.pdf","authors":["Roni Ben Aharon","Idan Szpektor","Ido Dagan"],"date":"2010/07","abstract":"Many NLP tasks need accurate knowledge for semantic inference. To this end, mostly WordNet is utilized. Yet Word-Net is limited, especially for inference between predicates. To help filling this gap, we present an algorithm that generates inference rules between predicates from FrameNet. Our experiment shows that the novel resource is effective and complements WordNet in terms of rule coverage."},{"id":"a9d9a4979cd3119029f0a856f4eade6c.html","title":"Assessing the role of discourse references in entailment inference","url":"https://www.aclweb.org/anthology/P10-1123.pdf","authors":["Shachar Mirkin","Ido Dagan","Sebastian Pad\\\\xf3"],"date":"2010/07","abstract":"Discourse references, notably coreference and bridging, play an important role in many text understanding applications, but their impact on textual entailment is yet to be systematically understood. On the basis of an in-depth analysis of entailment instances, we argue that discourse references have the potential of substantially improving textual entailment recognition, and identify a number of research directions towards this goal."},{"id":"27e14d0b3b2b2e684036995b6310e72a.html","title":"Easy first dependency parsing of modern Hebrew","url":"https://www.aclweb.org/anthology/W10-1412.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2010/06/05","abstract":"We investigate the performance of an easyfirst, non-directional dependency parser on the Hebrew Dependency treebank. We show that with a basic feature set the greedy parser\u2019s accuracy is on a par with that of a first-order globally optimized MST parser. The addition of morphological-agreement feature improves the parsing accuracy, making it on-par with a second-order globally optimized MST parser. The improvement due to the morphological agreement information is persistent both when gold-standard and automatically-induced morphological information is used."},{"id":"cbf97a7f6e67100e67fafbe3570780e7.html","title":"Statistical parsing of morphologically rich languages (SPMRL): what, how and whither","url":"https://www.aclweb.org/anthology/W10-1401.pdf","authors":["Reut Tsarfaty","Djam\\\\xe9 Seddah","Yoav Goldberg","Sandra K\\\\xfcbler","Marie Candito","Jennifer Foster","Yannick Versley","Ines Rehbein","Lamia Tounsi"],"date":"2010/06/05","abstract":"The term Morphologically Rich Languages (MRLs) refers to languages in which significant information concerning syntactic units and relations is expressed at word-level. There is ample evidence that the application of readily available statistical parsing models to such languages is susceptible to serious performance degradation. The first workshop on statistical parsing of MRLs hosts a variety of contributions which show that despite languagespecific idiosyncrasies, the problems associated with parsing MRLs cut across languages and parsing frameworks. In this paper we review the current state-of-affairs with respect to parsing MRLs and point out central challenges. We synthesize the contributions of researchers working on parsing Arabic, Basque, French, German, Hebrew, Hindi and Korean to point out shared solutions across languages. The overarching analysis suggests itself as a source of directions for future investigations."},{"id":"33097872c29f71ec97c7bbb1c1d83dfb.html","title":"An efficient algorithm for easy-first non-directional dependency parsing","url":"https://www.aclweb.org/anthology/N10-1115.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2010/06/02","abstract":"We present a novel deterministic dependency parsing algorithm that attempts to create the easiest arcs in the dependency structure first in a non-directional manner. Traditional deterministic parsing algorithms are based on a shift-reduce framework: they traverse the sentence from left-to-right and, at each step, perform one of a possible set of actions, until a complete tree is built. A drawback of this approach is that it is extremely local: while decisions can be based on complex structures on the left, they can look only at a few words to the right. In contrast, our algorithm builds a dependency tree by iteratively selecting the best pair of neighbours to connect at each parsing step. This allows incorporation of features from already built structures both to the left and to the right of the attachment point. The parser learns both the attachment preferences and the order in which they should be performed. The result is a deterministic, best-first, O (nlogn) parser, which is significantly more accurate than best-first transition based parsers, and nears the performance of globally optimized parsing models."},{"id":"4503d0737497a8b27c4b0d96c024c2eb.html","title":"Modeling morphosyntactic agreement in constituency-based parsing of Modern Hebrew","url":"https://www.aclweb.org/anthology/W10-1405.pdf","authors":["Reut Tsarfaty","Khalil Sima\u2019an"],"date":"2010/06","abstract":"We show that na\u0131ve modeling of morphosyntactic agreement in a Constituency-Based (CB) statistical parsing model is worse than none, whereas a linguistically adequate way of modeling inflectional morphology in CB parsing leads to improved performance. In particular, we show that an extension of the Relational-Realizational (RR) model that incorporates agreement features is superior to CB models that treat morphosyntax as statesplits (SP), and that the RR model benefits more from inflectional features. We focus on parsing Hebrew and report the best result to date, F184. 13 for parsing off of gold-tagged text, 5% error reduction from previous results."},{"id":"a47b0631c39a199376ec36bfefb68035.html","title":"Statistical parsing of morphologically rich languages (spmrl) what, how and whither","url":"https://www.aclweb.org/anthology/W10-1401.pdf","authors":["Reut Tsarfaty","Djam\\\\xe9 Seddah","Yoav Goldberg","Sandra K\\\\xfcbler","Yannick Versley","Marie Candito","Jennifer Foster","Ines Rehbein","Lamia Tounsi"],"date":"2010/06","abstract":"The term Morphologically Rich Languages (MRLs) refers to languages in which significant information concerning syntactic units and relations is expressed at word-level. There is ample evidence that the application of readily available statistical parsing models to such languages is susceptible to serious performance degradation. The first workshop on statistical parsing of MRLs hosts a variety of contributions which show that despite languagespecific idiosyncrasies, the problems associated with parsing MRLs cut across languages and parsing frameworks. In this paper we review the current state-of-affairs with respect to parsing MRLs and point out central challenges. We synthesize the contributions of researchers working on parsing Arabic, Basque, French, German, Hebrew, Hindi and Korean to point out shared solutions across languages. The overarching analysis suggests itself as a source of directions for future investigations."},{"id":"570be9f151d9611db20cfbdd6150eb43.html","title":"Building Textual Entailment Specialized Data Sets: a Methodology for Isolating Linguistic Phenomena Relevant to Inference.","url":"https://u.cs.biu.ac.il/~nlp/downloads/publications/478_Paper.pdf","authors":["Luisa Bentivogli","Elena Cabrio","Ido Dagan","Danilo Giampiccolo","Medea Lo Leggio","Bernardo Magnini"],"date":"2010/05/19","abstract":"This paper proposes a methodology for the creation of specialized data sets for Textual Entailment, made of monothematic Text-Hypothesis pairs (ie pairs in which only one linguistic phenomenon relevant to the entailment relation is highlighted and isolated). The annotation procedure assumes that humans have knowledge about the linguistic phenomena relevant to inference, and a classification of such phenomena both into fine grained and macro categories is suggested. We experimented with the proposed methodology over a sample of pairs taken from the RTE-5 data set, and investigated critical issues arising when entailment, contradiction or unknown pairs are considered. The result is a new resource, which can be profitably used both to advance the comprehension of the linguistic phenomena relevant to entailment judgments and to make a first step towards the creation of large-scale specialized data sets."},{"id":"3c38f6978236e8bee9cf0efa5d664f23.html","title":"A Resource for Investigating the Impact of Anaphora and Coreference on Inference.","url":"https://www.academia.edu/download/31326476/LREC-2010_Abad-etal.pdf","authors":["Azad Abad","Luisa Bentivogli","Ido Dagan","Danilo Giampiccolo","Shachar Mirkin","Emanuele Pianta","Asher Stern"],"date":"2010/05","abstract":"Discourse phenomena play a major role in text processing tasks. However, so far relatively little study has been devoted to the relevance of discourse phenomena for inference. Therefore, an experimental study was carried out to assess the relevance of anaphora and coreference for Textual Entailment (TE), a prominent inference framework. First, the annotation of anaphoric and coreferential links in the RTE-5 Search data set was performed according to a specifically designed annotation scheme. As a result, a new data set was created where all anaphora and coreference instances in the entailing sentences which are relevant to the entailment judgment are solved and annotated. A by-product of the annotation is a new \u201caugmented\u201d data set, where all the referring expressions which need to be resolved in the entailing sentences are replaced by explicit expressions. Starting from the final output of the annotation, the actual impact of discourse phenomena on inference engines was investigated, identifying the kind of operations that the systems need to apply to address discourse phenomena and trying to find direct mappings between these operation and annotation types."},{"id":"9ec92712b724c9bbb8370d4bc1d00fe5.html","title":"Learning an expert from human annotations in statistical machine translation: The case of out-of-vocabulary words","url":"http://www.mt-archive.info/10/EAMT-2010-Aziz.pdf","authors":["Wilker Aziz","Marc Dymetman","Shachar Mirkin","Lucia Specia","Nicola Cancedda","Ido Dagan"],"date":"2010/05","journal":"Proceedings of the 14th annual meeting of the European Association for Machine Translation (EAMT), Saint-Rapha, France","abstract":"We present a general method for incorporating an \u201cexpert\u201d model into a Statistical Machine Translation (SMT) system, in order to improve its performance on a particular \u201carea of expertise\u201d, and apply this method to the specific task of finding adequate replacements for Out-of-Vocabulary (OOV) words. Candidate replacements are paraphrases and entailed phrases, obtained using monolingual resources. These candidate replacements are transformed into \u201cdynamic biphrases\u201d, generated at decoding time based on the context of each source sentence. Standard SMT features are enhanced with a number of new features aimed at scoring translations produced by using different replacements. Active learning is used to discriminatively train the model parameters from human assessments of the quality of translations. The learning framework yields an SMT system which is able to deal with sentences containing OOV words but also guarantees that the performance is not degraded for input sentences without OOV words. Results of experiments on English-French translation show that this method outperforms previous work addressing OOV words in terms of acceptability."},{"id":"e64dfc7541585e9e64111eda4db55b3b.html","title":"The fourth pascal recognizing textual entailment challenge","url":"https://www.microsoft.com/en-us/research/publication/the-fourth-pascal-recognizing-textual-entailment-challenge/","authors":["Ido Dagan","Bill Dolan","Bernardo Magnini","Dan Roth"],"date":"2010/01/1","journal":"Journal of Natural Language Engineering","abstract":"The goal of identifying textual entailment\u2013whether one piece of text can be plausibly inferred from another\u2013has emerged in recent years as a generic core problem in natural language understanding. Work in this area has been largely driven by the PASCAL Recognizing Textual Entailment (RTE) challenges, which are a series of annual competitive meetings. The current work exhibits strong ties to some earlier lines of research, particularly automatic acquisition of paraphrases and lexical semantic relationships and unsupervised inference in applications such as question answering, information extraction and summarization. It has also opened the way to newer lines of research on more involved inference methods, on knowledge representations needed to support this natural language understanding challenge and on the use of learning methods in this context. RTE has fostered an active and growing community of researchers focused on the problem of applied entailment. This special issue of the JNLE provides an opportunity to showcase some of the most important work in this emerging area."},{"id":"287a7c3db53ad6ae7b72c878383d75be.html","title":"Recognizing textual entailment: Rational, evaluation and approaches\u2013erratum","url":"https://www.cambridge.org/core/journals/natural-language-engineering/article/recognizing-textual-entailment-rational-evaluation-and-approaches-erratum/A8332663248862777F4665C08BA33E9F","authors":["Ido Dagan","Bill Dolan","Bernardo Magnini","Dan Roth"],"date":"2010/01","journal":"Natural Language Engineering","abstract":"<div class=\\"gsh_csp\\">Due to publisher error, this article was omitted from the printed issue of <i>Natural Language Engineering</i> volume 15 issue 4."},{"id":"36304af58bf01d02088b608126e36847.html","title":"Semantic Inference at the LexicalSyntactic Level","url":"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.465.8266","authors":["Roy Bar-Haim","Ido Dagan","Iddo Greental","Eyal Shnarch"],"date":"2010","abstract":"Semantic inference is an important component in many natural language understanding applications. Classi-cal approaches to semantic inference rely on complex logical representations. However, practical applications usually adopt shallower lexical or lexical-syntactic rep-resentations, but lack a principled inference framework. We propose a generic semantic inference framework that operates directly on syntactic trees. New trees are inferred by applying entailment rules, which provide a unified representation for varying types of inferences. Rules were generated by manual and automatic meth-ods, covering generic linguistic structures as well as specific lexical-based inferences. Initial empirical eval-uation in a Relation Extraction setting supports the va-lidity of our approach."},{"id":"6048aa0f858c5600128dc5d6089ddb93.html","title":"Proceedings of the NAACL HLT 2010 First Workshop on Statistical Parsing of Morphologically-Rich Languages","url":"https://www.aclweb.org/anthology/W10-1400.pdf","authors":["Yuval Marton","Nizar Habash","Owen Rambow","Bharat Ram Ambati","Samar Husain","Sambhav Jain","Dipti Misra Sharma","Rajeev Sangal","Kepa Bengoetxea","Koldo Gojenola","Reut Tsarfaty","Khalil Sima\'an","Tagyoung Chung","Matt Post","Daniel Gildea","Wolfgang Maier","Mohammed Attia","Jennifer Foster","Deirdre Hogan","Joseph Le Roux","Lamia Tounsi","Josef van Genabith","Bharat Ram Ambati","Samar Husain","Joakim Nivre","Rajeev Sangal","Yoav Goldberg","Michael Elhadad"],"date":"2010","journal":"Proceedings of the NAACL HLT 2010 First Workshop on Statistical Parsing of Morphologically-Rich Languages","abstract":"The idea of organizing this workshop was sparked following very interesting discussions that occurred during EACL09 among various researchers working on statistical parsing of different types of languages. Indeed, an opportunity to discuss the issues that we were all experiencing was much needed, and it seemed such a good idea that we decided to take advantage of IWPT\u201909, which was held that year in Paris, to organize a panel on this topic. We planned to have presentations on the various issues faced by this small emerging community, which would allow us to share our sometimes similar solutions for parsing different languages."},{"id":"aaccb377fbb1a5ce7958a4533348a88e.html","title":"RELATIONAL-REALIZATIONAL SYNTAX: AN ARCHITECTURE FOR SPECIFYING AND LEARNING MORPHOSYNTACTIC DESCRIPTIONS","url":"http://cslipublications.stanford.edu/LFG/15/lfg10.pdf#page=458","authors":["Reut Tsarfaty","Miriam Butt","Tracy Holloway King"],"date":"2010","journal":"Proceedings of LFG10","abstract":"This paper presents a novel architecture for specifying rich morphosyntactic representations and learning the associated grammars from annotated data. The key idea underlying the architecture is the application of the traditional notion of a \u201cparadigm\u201d to the syntactic domain. N-place predicates associated with paradigm cells are viewed as relational networks that are realized recursively by combining and ordering cells from other paradigms. The complete morphosyntactic representation of a sentence is then viewed as a nested integrated structure interleaving function and form by means of realization rules. This architecture, called Relational-Realizational, has a simple instantiation as a generative probabilistic model of which parameters can be statistically learned from treebank data. An application of this model to Hebrew allows for accurate description of word-order and argument marking patterns familiar from Semitic traditional grammars. The associated treebank grammar can be used for statistical parsing and is shown to improve state-of-the-art parsing results for Hebrew. The availability of a simple, formal, robust, implementable and statistically interpretable working model opens new horizons in computational linguistics\u2014at least in principle, we should now be able to quantify typological trends which have so far been stated informally or only tacitly reflected in corpus statistics."},{"id":"c8ea359cc051c007642077454d3ff037.html","title":"Relational-realizational parsing","url":"https://dare.uva.nl/record/1/317909","authors":["Reut Tsarfaty"],"date":"2010","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Total citations"},{"id":"c0a9af16b754dac8c722f908f3e84053.html","title":"The Fifth PASCAL Recognizing Textual Entailment Challenge.","url":"http://www.cs.utexas.edu/users/pclark/papers/RTE6_overview.proceedings.pdf","authors":["Luisa Bentivogli","Peter Clark","Ido Dagan","Danilo Giampiccolo"],"date":"2009/11/17","abstract":"This paper presents the Sixth Recognizing Textual Entailment (RTE-6) challenge. This year a major innovation was introduced, as the traditional Main Task was replaced by a new task, similar to the RTE-5 Search Pilot, in which Textual Entailment is performed on a real corpus in the Update Summarization scenario. A subtask was also proposed, aimed at detecting novel information. To continue the effort of testing RTE in NLP applications, a KBP Validation Pilot Task was set up, in which RTE systems had to validate the output of systems participating in the KBP Slot Filling Task. Eighteen teams participated in the Main Task (48 submitted runs) and 9 in the Novelty Detection Subtask (22 submitted runs). As for the Pilot, 10 runs were submitted by 3 participants. Finally, the exploratory effort started in RTE-5 to perform resource evaluation through ablation tests was not only reiterated in RTE-6, but also extended to tools."},{"id":"f4f82016234ba692c1c09bfe041dddb8.html","title":"Improving text categorization bootstrapping via unsupervised learning","url":"https://dl.acm.org/doi/abs/10.1145/1596515.1596516","authors":["Alfio Gliozzo","Carlo Strapparava","Ido Dagan"],"date":"2009/10/14","journal":"ACM Transactions on Speech and Language Processing (TSLP)","abstract":"We propose a text-categorization bootstrapping algorithm in which categories are described by relevant seed words. Our method introduces two unsupervised techniques to improve the initial categorization step of the bootstrapping scheme: (i) using latent semantic spaces to estimate the similarity among documents and words, and (ii) the Gaussian mixture algorithm, which differentiates relevant and nonrelevant category information using statistics from unlabeled examples. In particular, this second step maps the similarity scores to class posterior probabilities, and therefore reduces sensitivity to keyword-dependent variations in scores. The algorithm was evaluated on two text categorization tasks, and obtained good performance using only the category names as initial seeds. In particular, the performance of the proposed method proved to be equivalent to a pure supervised approach trained on 70--160 labeled\\\\xa0\u2026"},{"id":"f609c2a4a0b9c93c141dfba118e24b8b.html","title":"Hebrew dependency parsing: Initial results","url":"https://www.aclweb.org/anthology/W09-3819.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2009/10/07","abstract":"We describe a newly available Hebrew Dependency Treebank, which is extracted from the Hebrew (constituency) Treebank. We establish some baseline unlabeled dependency parsing performance on Hebrew, based on two state-of-the-art parsers, MST-parser and MaltParser. The evaluation is performed both in an artificial setting, in which the data is assumed to be properly morphologically segmented and POS-tagged, and in a real-world setting, in which the parsing is performed on automatically segmented and POS-tagged text. We present an evaluation measure that takes into account the possibility of incompatible token segmentation between the gold standard and the parsed data. Results indicate that (a) MST-parser performs better on Hebrew data than Malt-Parser, and (b) both parsers do not make good use of morphological information when parsing Hebrew. 1 Introduction"},{"id":"6abfe5e67c814f33dd299b144dde5006.html","title":"G NATURAL","url":"https://www.cambridge.org/core/journals/natural-language-engineering/article/nle-volume-15-issue-4-cover-and-front-matter/4A25FD66DCC0B968E660DA35BB9A9FF3","authors":["Textual Entailment","Ido Dagan","Bill Dolan","Bernardo Magnini","Dan Roth"],"date":"2009/10/04","abstract":""},{"id":"06ac57a0198ad34ad194edb99b2e2c06.html","title":"Considering discourse references in textual entailment annotation","url":"https://u.cs.biu.ac.il/~nlp/downloads/publications/Final-GL2009_19_Bentivogli-et-al.pdf","authors":["Luisa Bentivogli","Ido Dagan","Hoa Trang Dang","Danilo Giampiccolo","Medea Lo Leggio","Bernardo Magnini"],"date":"2009/09/17","journal":"Proceedings of the 5th International Conference on Generative Approaches to the Lexicon (GL 2009)","abstract":"In the 2009 Recognizing Textual Entailment challenge a Search Pilot task has been introduced, aimed at finding all the sentences in a corpus which entail a set of given hypotheses. The preparation of the data set for this task has provided an opportunity to better understand some phenomena concerning textual entailment recognition in a natural setting. This paper focuses on some problematic issues related to resolving coreferences to entities, space, time and events at the corpus level, as emerged during the annotation of the data set for the textual entailment Search Pilot."},{"id":"45e440116b78da2d93732d8fd44aa96d.html","title":"Ontology Evaluation through Text Classi\ufb01cation","url":"http://books.google.com/books?hl=en&lr=&id=uu5rdVCN5xEC&oi=fnd&pg=PA210&dq=info:hTzRfV69hp0J:scholar.google.com&ots=Gd2S5zrhls&sig=hbVD6VY5pom0IEl8OUdoZ5Yxfzo","authors":["DavidGabay YaelNetzer","Meni Adler","Yoav Goldberg","Michael Elhadad"],"date":"2009/09/01","journal":"Advances in Web and Network Technologies and Information Management: AP Web/WAIM 2009 International Workshops: WCMT 2009, RTBI 2009, DBIR-ENQOIR 2009, and PAIS 2009","abstract":"We present a new method to evaluate a search ontology, which relies on mapping ontology instances to textual documents. On the basis of this mapping, we evaluate the adequacy of ontology relations by measuring their classi\ufb01cation potential over the textual documents. This data-driven method provides concrete feedback to ontology maintainers and a quantitative estimation of the functional adequacy of the ontology relations towards search experience improvement. We speci\ufb01cally evaluate whether an ontology relation can help a semantic search engine support exploratory search."},{"id":"c38251d137a2773296ab0c85dc64a28e.html","title":"Bootstrapping distributional feature vector quality","url":"https://www.mitpressjournals.org/doi/abs/10.1162/coli.08-032-r1-06-96","authors":["Maayan Zhitomirsky-Geffet","Ido Dagan"],"date":"2009/09","journal":"Computational linguistics","abstract":"This article presents a novel bootstrapping approach for improving the quality of feature vector weighting in distributional word similarity. The method was motivated by attempts to utilize distributional similarity for identifying the concrete semantic relationship of lexical entailment. Our analysis revealed that a major reason for the rather loose semantic similarity obtained by distributional similarity methods is insufficient quality of the word feature vectors, caused by deficient feature weighting. This observation led to the definition of a bootstrapping scheme which yields improved feature weights, and hence higher quality feature vectors. The underlying idea of our approach is that features which are common to similar words are also most characteristic for their meanings, and thus should be promoted. This idea is realized via a bootstrapping step applied to an initial standard approximation of the similarity space. The\\\\xa0\u2026"},{"id":"3e8984effd526c09448cb72b55a295f6.html","title":"On the role of lexical features in sequence labeling","url":"https://www.aclweb.org/anthology/D09-1119.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2009/08/06","abstract":"We use the technique of SVM anchoring to demonstrate that lexical features extracted from a training corpus are not necessary to obtain state of the art results on tasks such as Named Entity Recognition and Chunking. While standard models require as many as 100K distinct features, we derive models with as little as 1K features that perform as well or better on different domains. These robust reduced models indicate that the way rare lexical features contribute to classification in NLP is not fully understood. Contrastive error analysis (with and without lexical features) indicates that lexical features do contribute to resolving some semantic and complex syntactic ambiguities\u2013but we find this contribution does not generalize outside the training corpus. As a general strategy, we believe lexical features should not be directly derived from a training corpus but instead, carefully inferred and selected from other sources."},{"id":"246abffed77355d01a343297f4162bbf.html","title":"Extracting lexical reference rules from Wikipedia","url":"https://www.aclweb.org/anthology/P09-1051.pdf","authors":["Eyal Shnarch","Libby Barak","Ido Dagan"],"date":"2009/08","abstract":"This paper describes the extraction from Wikipedia of lexical reference rules, identifying references to term meanings triggered by other terms. We present extraction methods geared to cover the broad range of the lexical reference relation and analyze them extensively. Most extraction methods yield high precision levels, and our rule-base is shown to perform better than other automatically constructed baselines in a couple of lexical expansion and matching tasks. Our rule-base yields comparable performance to Word-Net while providing largely complementary information."},{"id":"36a6c393473c1057deb6d2a8e77c9ec7.html","title":"Proceedings of the 2009 Workshop on Applied Textual Inference (TextInfer)","url":"https://www.aclweb.org/anthology/W09-2500.pdf","authors":["Chris Callison-Burch","Ido Dagan","Christopher D Manning","Marco Pennacchiotti","Fabio Massimo Zanzotto"],"date":"2009/08","abstract":"Applied textual inference has attracted a significant amount of attention in recent years. Recognizing textual entailments and detecting semantic equivalences between texts are at the core of many NLP tasks, including question answering, information extraction, text summarization, and many others. Developing generic algorithms and resources for inference and paraphrasing would therefore be applicable to a broad range of NLP applications."},{"id":"4298588df528af5efd006a429b1a42e8.html","title":"A compact forest for scalable inference over entailment and paraphrase rules","url":"https://www.aclweb.org/anthology/D09-1110.pdf","authors":["Roy Bar-Haim","Jonathan Berant","Ido Dagan"],"date":"2009/08","abstract":"A large body of recent research has been investigating the acquisition and application of applied inference knowledge. Such knowledge may be typically captured as entailment rules, applied over syntactic representations. Efficient inference with such knowledge then becomes a fundamental problem. Starting out from a formalism for entailment-rule application we present a novel packed data-structure and a corresponding algorithm for its scalable implementation. We proved the validity of the new algorithm and established its efficiency analytically and empirically."},{"id":"5fa570874927817520732397562698b7.html","title":"Augmenting wordnet-based inference with argument mapping","url":"https://www.aclweb.org/anthology/W09-2504.pdf","authors":["Idan Szpektor","Ido Dagan"],"date":"2009/08","abstract":"WordNet is a useful resource for lexical inference in applications. Inference over predicates, however, often requires a change in argument positions, which is not specified in WordNet. We propose a novel framework for augmenting WordNet-based inferences over predicates with corresponding argument mappings. We further present a concrete implementation of this framework, which yields substantial improvement to WordNet-based inference."},{"id":"6ab88ccdcceae5b95e900f0d722ccf0b.html","title":"Source-language entailment modeling for translating unknown terms","url":"https://www.aclweb.org/anthology/P09-1089.pdf","authors":["Shachar Mirkin","Lucia Specia","Nicola Cancedda","Ido Dagan","Marc Dymetman","Idan Szpektor"],"date":"2009/08","abstract":"This paper addresses the task of handling unknown terms in SMT. We propose using source-language monolingual models and resources to paraphrase the source text prior to translation. We further present a conceptual extension to prior work by allowing translations of entailed texts rather than paraphrases only. A method for performing this process efficiently is presented and applied to some 2500 sentences with unknown terms. Our experiments show that the proposed approach substantially increases the number of properly translated texts."},{"id":"a752134babbb40d886facc6688c7f2bb.html","title":"Directional distributional similarity for lexical expansion","url":"https://www.aclweb.org/anthology/P09-2018.pdf","authors":["Lili Kotlerman","Ido Dagan","Idan Szpektor","Maayan Geffet"],"date":"2009/08","abstract":"Distributional word similarity is most commonly perceived as a symmetric relation. Yet, one of its major applications is lexical expansion, which is generally asymmetric. This paper investigates the nature of directional (asymmetric) similarity measures, which aim to quantify distributional feature inclusion. We identify desired properties of such measures, specify a particular one based on averaged precision, and demonstrate the empirical benefit of directional measures for expansion."},{"id":"c7f427814335133e753722eb2075da21.html","title":"An alternative to head-driven approaches for parsing a (relatively) free word-order language","url":"https://www.aclweb.org/anthology/D09-1088.pdf","authors":["Reut Tsarfaty","Khalil Sima\u2019an","Remko Scha"],"date":"2009/08","abstract":"Applying statistical parsers developed for English to languages with freer wordorder has turned out to be harder than expected. This paper investigates the adequacy of different statistical parsing models for dealing with a (relatively) free word-order language. We show that the recently proposed Relational-"},{"id":"d4bcb0d9b7909120e3c45017a8eeeccc.html","title":"Gaiku: Generating Haiku with word associations norms","url":"https://www.aclweb.org/anthology/W09-2005.pdf","authors":["Yael Netzer","David Gabay","Yoav Goldberg","Michael Elhadad"],"date":"2009/06/04","abstract":"Traditional lexical knowledge bases such as Word-Net formalize a limited set of systematic relations that exist between words, such as synonymy, polysemy, hypernymy. When such relations are composed, they maintain their systematicity, and do not create surprising, unexpected word associations. The human mind is not limited to such systematic relations, and people tend to associate words to each other with a rich set of relations, such as non systematic paradigmatic (doctor-nurse) and syntagmatic relations (mash-potato) as identified by Saussure (1949). Such associations rely on cultural (mash-television), emotional (math-yuck) and personal experience (autumn-Canada)."},{"id":"e16c1d5ef3af513d254bcc55d2ce0bb6.html","title":"Text categorization from category name via lexical reference","url":"https://www.aclweb.org/anthology/N09-2009.pdf","authors":["Libby Barak","Ido Dagan","Eyal Shnarch"],"date":"2009/06","abstract":"Requiring only category names as user input is a highly attractive, yet hardly explored, setting for text categorization. Earlier bootstrapping results relied on similarity in LSA space, which captures rather coarse contextual similarity. We suggest improving this scheme by identifying concrete references to the category name\u2019s meaning, obtaining a special variant of lexical expansion."},{"id":"33dde6aa7a9aff70f99f5a81d2898f0b.html","title":"Enhancing unlexicalized parsing performance using a wide coverage lexicon, fuzzy tag-set mapping, and EM-HMM-based lexical probabilities","url":"https://www.aclweb.org/anthology/E09-1038.pdf","authors":["Yoav Goldberg","Reut Tsarfaty","Meni Adler","Michael Elhadad"],"date":"2009/03","abstract":"We present a framework for interfacing a PCFG parser with lexical information from an external resource following a different tagging scheme than the treebank. This is achieved by defining a stochastic mapping layer between the two resources. Lexical probabilities for rare events are estimated in a semi-supervised manner from a lexicon and large unannotated corpora. We show that this solution greatly enhances the performance of an unlexicalized Hebrew PCFG parser, resulting in state-of-the-art Hebrew parsing results both when a segmentation oracle is assumed, and in a real-word parsing scenario of parsing unsegmented tokens."},{"id":"76cad631d5f07bf85fc3ed01aac63e7e.html","title":"Evaluating the inferential utility of lexical-semantic resources","url":"https://www.aclweb.org/anthology/E09-1064.pdf","authors":["Shachar Mirkin","Ido Dagan","Eyal Shnarch"],"date":"2009/03","abstract":"Lexical-semantic resources are used extensively for applied semantic inference, yet a clear quantitative picture of their current utility and limitations is largely missing. We propose system-and application-independent evaluation and analysis methodologies for resources\u2019 performance, and systematically apply them to seven prominent resources. Our findings identify the currently limited recall of available resources, and indicate the potential to improve performance by examining non-standard relation types and by distilling the output of distributional methods. Further, our results stress the need to include auxiliary information regarding the lexical and logical contexts in which a lexical inference is valid, as well as its prior validity likelihood."},{"id":"03ff5fa5fd63ffc8ff17dc355bcf970d.html","title":"It\u2019s time for a semantic engine!","url":"https://nlp.cs.nyu.edu/sk-symposium/slides/IdoDagan.pdf","authors":["Ido Dagan"],"date":"2009/01/07","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"99a44e060091f7d8b9388203338a4b9b.html","title":"It\u2019s time for a semantic inference engine","url":"https://www.aclweb.org/anthology/W09-3701.pdf","authors":["Ido Dagan"],"date":"2009/01","abstract":"A common computational goal is to encapsulate the modeling of a target phenomenon within a unified and comprehensive\u201d engine\u201d, which addresses a broad range of the required processing tasks. This goal is followed in common modeling of the morphological and syntactic levels of natural language, where most processing tasks are encapsulated within morphological analyzers and syntactic parsers. In this talk I suggest that computational modeling of the semantic level should also focus on encapsulating the various processing tasks within a unified module (engine). The input/output specification of such engine (API) can be based on the textual entailment paradigm, which will be described in brief and suggested as an attractive framework for applied semantic inference. The talk will illustrate an initial proposal for the engine\u2019s API, designed to be embedded within the prominent language processing applications. Finally, I will sketch the entailment formalism and efficient inference algorithm developed at Bar-Ilan University, which illustrates a principled transformational (rather than interpretational) approach towards developing a comprehensive semantic engine."},{"id":"04ce634194a47b27df397198c722020d.html","title":"Bar-Ilan University\u2019s submission to RTE5","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.172.7660&rep=rep1&type=pdf","authors":["Shachar Mirkin","Roy Bar-Haim","Jonathan Berant","Ido Dagan","Eyal Shnarch","Asher Stern","Idan Szpektor"],"date":"2009","journal":"Proceedings of the Second Text Analysis Conference (TAC 2009), Gaithersburg, MD","abstract":"This year we focused on the search pilot, and enhanced our RTE-4 system to address two issues introduced by this novel setting: candidate texts search and document-level discourse analysis. Our system achieved the highest score on the search task, and may be viewed as a first step towards fully addressing this challenging task."},{"id":"debf8acb460673024ad1d8d6f3c298a4.html","title":"Addressing Discourse and Document Structure in the RTE Search Task.","url":"http://www-nlp.stanford.edu/joberant/homepage_files/publications/TAC09.pdf","authors":["Shachar Mirkin","Roy Bar-Haim","Ido Dagan","Eyal Shnarch","Asher Stern","Idan Szpektor","Jonathan Berant"],"date":"2009","abstract":"This paper describes Bar-Ilan University\u2019s submissions to RTE-5. This year we focused on the Search pilot, enhancing our entailment system to address two main issues introduced by this new setting: scalability and, primarily, document-level discourse. Our system achieved the highest score on the Search task amongst participating groups, and proposes first steps towards addressing this challenging setting."},{"id":"ffc12df710805712e7a198bc95045458.html","title":"Ontology evaluation through text classification","url":"https://link.springer.com/chapter/10.1007/978-3-642-03996-6_20","authors":["Yael Netzer","David Gabay","Meni Adler","Yoav Goldberg","Michael Elhadad"],"date":"2009","journal":"Advances in Web and Network Technologies, and Information Management","abstract":"We present a new method to evaluate a <i>search ontology</i>, which relies on mapping ontology instances to textual documents. On the basis of this mapping, we evaluate the adequacy of ontology relations by measuring their classification potential over the textual documents. This data-driven method provides concrete feedback to ontology maintainers and a quantitative estimation of the functional adequacy of the ontology relations towards search experience improvement. We specifically evaluate whether an ontology relation can help a semantic search engine support exploratory search."},{"id":"0b9361fa280b91ac84569108564b9a96.html","title":"Efficient Semantic Deduction and Approximate Matching over Compact Parse Forests.","url":"http://www.academia.edu/download/31704216/BIU.proceedings.pdf","authors":["Roy Bar-Haim","Ido Dagan","Shachar Mirkin","Eyal Shnarch","Idan Szpektor","Jonathan Berant","Iddo Greental"],"date":"2008/11/17","abstract":"Semantic inference is often modeled as application of entailment rules, which specify generation of entailed sentences from a source sentence. Efficient generation and representation of entailed consequents is a fundamental problem common to such inference methods. We present a new data structure, termed compact forest, which allows efficient generation and representation of entailed consequents, each represented as a parse tree. Rule-based inference is complemented with a new approximate matching measure inspired by tree kernels, which is computed efficiently over compact forests. Our system also makes use of novel large-scale entailment rule bases, derived from Wikipedia as well as from information about predicates and their argument mapping, gathered from available lexicons and complemented by unsupervised learning."},{"id":"6768f47c801f14b38cf2ae0ba6ad56de.html","title":"The Fourth PASCAL Recognizing Textual Entailment Challenge.","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.232.4661&rep=rep1&type=pdf","authors":["Danilo Giampiccolo","Hoa Trang Dang","Bernardo Magnini","Ido Dagan","Elena Cabrio","Bill Dolan"],"date":"2008/11/17","abstract":"In 2008 the Recognizing Textual Entailment Challenge (RTE-4) was proposed for the first time as a track at the Text Analysis Conference (TAC). Another important innovation introduced in this campaign was a three-judgment task, which required the systems to make a further distinction between pairs where the entailment does not hold because the content of H is contradicted by the content of T, and pairs where the entailment cannot be determined because the truth of H cannot be verified on the basis of the content of T. A classic twoway task was also offered. RTE-4 attracted 26 teams, more than half of whom submitted runs for the new 3-way task. This paper describes the preparation of the dataset, and gives an overview of the results achieved by the participating systems."},{"id":"4d320b44272cab5621e3ebf0dd6cf139.html","title":"Learning entailment rules for unary templates","url":"https://www.aclweb.org/anthology/C08-1107.pdf","authors":["Idan Szpektor","Ido Dagan"],"date":"2008/08","abstract":"Most work on unsupervised entailment rule acquisition focused on rules between templates with two variables, ignoring unary rules-entailment rules between templates with a single variable. In this paper we investigate two approaches for unsupervised learning of such rules and compare the proposed methods with a binary rule learning method. The results show that the learned unary rule-sets outperform the binary rule-set. In addition, a novel directional similarity measure for learning entailment, termed Balanced-Inclusion, is the best performing measure."},{"id":"6cf94a5e83c485bbe5be6e2c999c86b1.html","title":"A single generative model for joint morphological segmentation and syntactic parsing","url":"https://www.aclweb.org/anthology/P08-1043.pdf","authors":["Yoav Goldberg","Reut Tsarfaty"],"date":"2008/06","journal":"Proceedings of ACL-08: HLT","abstract":"Morphological processes in Semitic languages deliver space-delimited words which introduce multiple, distinct, syntactic units into the structure of the input sentence. These words are in turn highly ambiguous, breaking the assumption underlying most parsers that the yield of a tree for a given sentence is known in advance. Here we propose a single joint model for performing both morphological segmentation and syntactic disambiguation which bypasses the associated circularity. Using a treebank grammar, a data-driven lexicon, and a linguistically motivated unknown-tokens handling technique our model outperforms previous pipelined, integrated or factorized systems for Hebrew morphological and syntactic processing, yielding an error reduction of 12% over the best published results so far."},{"id":"79e2356e45a4f2867347beae6e6bf550.html","title":"Contextual preferences","url":"https://www.aclweb.org/anthology/P08-1078.pdf","authors":["Idan Szpektor","Ido Dagan","Roy Bar-Haim","Jacob Goldberger"],"date":"2008/06","abstract":"The validity of semantic inferences depends on the contexts in which they are applied. We propose a generic framework for handling contextual considerations within applied inference, termed Contextual Preferences. This framework defines the various context-aware components needed for inference and their relationships. Contextual preferences extend and generalize previous notions, such as selectional preferences, while experiments show that the extended framework allows improving inference quality on real application data."},{"id":"b9e181b98fef348fea904a8408b9e6e6.html","title":"EM can find pretty good HMM POS-taggers (when given a good start)","url":"https://www.aclweb.org/anthology/P08-1085.pdf","authors":["Yoav Goldberg","Meni Adler","Michael Elhadad"],"date":"2008/06","abstract":"We address the task of unsupervised POS tagging. We demonstrate that good results can be obtained using the robust EM-HMM learner when provided with good initial conditions, even with incomplete dictionaries. We present a family of algorithms to compute effective initial estimations p (t| w). We test the method on the task of full morphological disambiguation in Hebrew achieving an error reduction of 25% over a strong uniform distribution baseline. We also test the same method on the standard WSJ unsupervised POS tagging task and obtain results competitive with recent state-ofthe-art methods, while using simple and efficient learning methods."},{"id":"e1fd6c462359251a510ac720d8d0ad7a.html","title":"splitSVM: fast, space-efficient, non-heuristic, polynomial kernel computation for NLP applications","url":"https://www.aclweb.org/anthology/P08-2060.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2008/06","abstract":"We present a fast, space efficient and nonheuristic method for calculating the decision function of polynomial kernel classifiers for NLP applications. We apply the method to the MaltParser system, resulting in a Java parser that parses over 50 sentences per second on modest hardware without loss of accuracy (a 30 time speedup over existing methods). The method implementation is available as the open-source splitSVM Java library."},{"id":"ed55eb939f974dbb3f7043f257a5ad05.html","title":"Unsupervised lexicon-based resolution of unknown words for full morphological analysis","url":"https://www.aclweb.org/anthology/P08-1083.pdf","authors":["Meni Adler","Yoav Goldberg","David Gabay","Michael Elhadad"],"date":"2008/06","abstract":"Morphological disambiguation proceeds in 2 stages:(1) an analyzer provides all possible analyses for a given token and (2) a stochastic disambiguation module picks the most likely analysis in context. When the analyzer does not recognize a given token, we hit the problem of unknowns. In large scale corpora, unknowns appear at a rate of 5 to 10%(depending on the genre and the maturity of the lexicon)."},{"id":"67954225b1fe80eaa35e1648dab262f4.html","title":"Tagging a Hebrew Corpus: the Case of Participles.","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.218.3638&rep=rep1&type=pdf","authors":["Meni Adler","Yael Dahan Netzer","Yoav Goldberg","David Gabay","Michael Elhadad"],"date":"2008/05","abstract":"We report on an effort to build a corpus of Modern Hebrew tagged with parts of speech and morphology. We designed a tagset specific to Hebrew while focusing on four aspects: the tagset should be consistent with common linguistic knowledge; there should be maximal agreement among taggers as to the tags assigned to maintain consistency; the tagset should be useful for machine taggers and learning algorithms; and the tagset should be effective for applications relying on the tags as input features. In this paper, we illustrate these issues by explaining our decision to introduce a tag for beinoni forms in Hebrew. We explain how this tag is defined, and how it helped us improve manual tagging accuracy to a high-level, while improving automatic tagging and helping in the task of syntactic chunking."},{"id":"8208dcb3b10b0be9f1e058f7279c5f81.html","title":"Word-Based or Morpheme-Based? Annotation Strategies for Modern Hebrew Clitics.","url":"https://www.cs.brandeis.edu/~marc/misc/proceedings/lrec-2008/pdf/361_paper.pdf","authors":["Reut Tsarfaty","Yoav Goldberg"],"date":"2008/05","abstract":"Morphologically rich languages pose a challenge to the annotators of treebanks with respect to the status of orthographic (spacedelimited) words in the syntactic parse trees. In such languages an orthographic word may carry various, distinct, sorts of information and the question arises whether we should represent such words as a sequence of their constituent morphemes (ie, a Morpheme-Based annotation strategy) or whether we should preserve their special orthographic status within the trees (ie, a Word-Based annotation strategy). In this paper we empirically address this challenge in the context of the development of Language Resources for Modern Hebrew. We compare and contrast the Morpheme-Based and Word-Based annotation strategies of pronominal clitics in Modern Hebrew and we show that the Word-Based strategy is more adequate for the purpose of training statistical parsers as it provides a better PP-attachment disambiguation capacity and a better alignment with initial surface forms. Our findings in turn raise new questions concerning the interaction of morphological and syntactic processing of which investigation is facilitated by the parallel treebank we made available."},{"id":"45ca9ec60b793d5868d78eee9bff2b6f.html","title":"Identification of transliterated foreign words in Hebrew script","url":"https://link.springer.com/chapter/10.1007/978-3-540-78135-6_40","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2008/02/17","abstract":"We present a loosely-supervised method for context-free identification of transliterated foreign names and borrowed words in Hebrew text. The method is purely statistical and does not require the use of any lexicons or linguistic analysis tool for the source languages (Hebrew, in our case). It also does not require any manually annotated data for training \u2013 we learn from noisy data acquired by over-generation. We report precision/recall results of 80/82 for a corpus of 4044 unique words, containing 368 foreign words."},{"id":"fa2947992d954c2fbdb39d7139af1db3.html","title":"Natural language as the basis for meaning representation and inference","url":"https://link.springer.com/chapter/10.1007/978-3-540-78135-6_14","authors":["Ido Dagan","Roy Bar-Haim","Idan Szpektor","Iddo Greental","Eyal Shnarch"],"date":"2008/02/17","abstract":"Semantic inference is an important component in many natural language understanding applications. Classical approaches to semantic inference rely on logical representations for meaning, which may be viewed as being \u201cexternal\u201d to the natural language itself. However, practical applications usually adopt shallower lexical or lexical-syntactic representations, which correspond closely to language structure. In many cases, such approaches lack a principled meaning representation and inference framework. We describe a generic semantic inference framework that operates directly on language-based structures, particularly syntactic trees. New trees are inferred by applying entailment rules, which provide a unified representation for varying types of inferences. Rules were generated by manual and automatic methods, covering generic linguistic structures as well as specific lexical-based inferences. Initial\\\\xa0\u2026"},{"id":"870b3f0c00ded4260e555d89a2bea8bf.html","title":"Identi\ufb01cation of Transliterated Foreign Words in Hebrew Script","url":"http://books.google.com/books?hl=en&lr=&id=ReeQ0ZzovpEC&oi=fnd&pg=PA466&dq=info:e7r_LFyWeoAJ:scholar.google.com&ots=f7SM-jmL1E&sig=joVOlt1aCjiVXgWRiv1d0xX8wkQ","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2008/02/08","journal":"Computational Linguistics and Intelligent Text Processing: 9th International Conference, CICLing 2008, Haifa, Israel, February 17-23, 2008, Proceedings","abstract":"We present a loosely-supervised method for context-free identi\ufb01cation of transliterated foreign names and borrowed words in Hebrew text. The method is purely statistical and does not require the use of any lexicons or linguistic analysis tool for the source languages (Hebrew, in our case). It also does not require any manually annotated data for training\u2013we learn from noisy data acquired by over-generation. We report precision/recall results of 80/82 for a corpus of 4044 unique words, containing 368 foreign words."},{"id":"6c9f93edb630e76b22fe500c4aca2532.html","title":"Efficient semantic inference over language expressions","url":"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.163.6244","authors":["Roy Bar-Haim","Ido Dagan"],"date":"2008","abstract":"over Language Expressions According to the traditional formal semantics approach, inference is conducted at the logical level. Texts are first translated into some logical form and then new propositions are inferred from interpreted texts by a logical theorem prover. However, text understanding systems usually employ shallower lexical and lexical-syntactic representations, sometimes augmented with partial semantic annotations like word senses, named-entity classes and semantic roles. While practical semantic inference is mostly performed over linguistic rather than logical representations, such practices are typically partial and quite ad-hoc, and lack a clear formalism that specifies how inference knowledge should be represented and applied."},{"id":"b0310423ae5f42da5436cf7e0967c2dd.html","title":"Language and Speech Processing Treebank Grammars","url":"http://www.tsarfaty.com/pdfs/TreebankGrammars.pdf","authors":["Reut Tsarfaty"],"date":"2007/11/13","abstract":"Objective Functions\u2022 Most Probable Word sequence\u2022 Most Probable POS sequence over words\u2022 Most Probable Parse"},{"id":"434ffa9f8626a035035d103458e654e7.html","title":"Accurate unlexicalized parsing for modern Hebrew","url":"https://link.springer.com/chapter/10.1007/978-3-540-74628-7_8","authors":["Reut Tsarfaty","Khalil Sima\u2019an"],"date":"2007/09/03","abstract":"Many state-of-the-art statistical parsers for English can be viewed as Probabilistic Context-Free Grammars (PCFGs) acquired from treebanks consisting of phrase-structure trees enriched with a variety of contextual, derivational (e.g., markovization) and lexical information. In this paper we empirically investigate the applicability and adequacy of the unlexicalized variety of such parsing models to Modern Hebrew, a Semitic language that differs in structure and characteristics from English. We show that contrary to experience with parsing the WSJ, the markovized, head-driven unlexicalized variety does not necessarily outperform plain PCFGs for Semitic languages. We demonstrate that enriching unlexicalized PCFGs with morphologically marked agreement features percolated up the parse tree (e.g., definiteness) outperforms plain PCFGs as well as a simple head-driven variation on the MH treebank. We\\\\xa0\u2026"},{"id":"7d5c53ee4c4ebbb55d43c26e2fe5de05.html","title":"Semantic inference at the lexical-syntactic level","url":"https://www.aaai.org/Papers/AAAI/2007/AAAI07-138.pdf","authors":["Roy Bar-Haim","Ido Dagan","Iddo Greental","Eyal Shnarch"],"date":"2007/07/22","journal":"Proceedings of the National Conference on Artificial Intelligence","abstract":"Semantic inference is an important component in many natural language understanding applications. Classical approaches to semantic inference rely on complex logical representations. However, practical applications usually adopt shallower lexical or lexical-syntactic representations, but lack a principled inference framework. We propose a generic semantic inference framework that operates directly on syntactic trees. New trees are inferred by applying entailment rules, which provide a unified representation for varying types of inferences. Rules were generated by manual and automatic methods, covering generic linguistic structures as well as specific lexical-based inferences. Initial empirical evaluation in a Relation Extraction setting supports the validity of our approach."},{"id":"4348378a55df37984d64c453a0f2daf5.html","title":"SVM model tampering and anchored learning: a case study in Hebrew NP chunking","url":"https://www.aclweb.org/anthology/P07-1029.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2007/06","abstract":"We study the issue of porting a known NLP method to a language with little existing NLP resources, specifically Hebrew SVM-based chunking. We introduce two SVM-based methods\u2013Model Tampering and Anchored Learning. These allow fine grained analysis of the learned SVM models, which provides guidance to identify errors in the training corpus, distinguish the role and interaction of lexical features and eventually construct a model with\u223c 10% error reduction. The resulting chunker is shown to be robust in the presence of noise in the training corpus, relies on less lexical features than was previously understood and achieves an F-measure performance of 92.2 on automatically PoS-tagged text. The SVM analysis methods also provide general insight on SVM-based chunking."},{"id":"57c141b24df6ebbf3892015c6bf9a060.html","title":"Three-dimensional parametrization for parsing morphologically rich languages","url":"https://www.aclweb.org/anthology/W07-2219.pdf","authors":["Reut Tsarfaty","Khalil Sima\u2019an"],"date":"2007/06","abstract":"Current parameters of accurate unlexicalized parsers based on Probabilistic Context-Free Grammars (PCFGs) form a twodimensional grid in which rewrite events are conditioned on both horizontal (headoutward) and vertical (parental) histories. In Semitic languages, where arguments may move around rather freely and phrasestructures are often shallow, there are additional morphological factors that govern the generation process. Here we propose that agreement features percolated up the parse-tree form a third dimension of parametrization that is orthogonal to the previous two. This dimension differs from mere \u201cstate-splits\u201d as it applies to a whole set of categories rather than to individual ones and encodes linguistically motivated co-occurrences between them. This paper presents extensive experiments with extensions of unlexicalized PCFGs for parsing Modern Hebrew in which tuning the parameters in three dimensions gradually leads to improved performance. Our best result introduces a new, stronger, lower bound on the performance of treebank grammars for parsing Modern Hebrew, and is on a par with current results for parsing Modern Standard Arabic obtained by a fully lexicalized parser trained on a much larger treebank."},{"id":"5df50aeda25d073bf4f6283ace88ec5f.html","title":"Proceedings of the ACL-PASCAL Workshop on Textual Entailment and Paraphrasing","url":"https://www.aclweb.org/anthology/W07-1400.pdf","authors":["Satoshi Sekine","Kentaro Inui","Ido Dagan","Bill Dolan","Danilo Giampiccolo","Bernardo Magnini"],"date":"2007/06","abstract":"Recognizing and generating textual entailment and paraphrases are regarded as important technologies in a broad range of NLP applications, including, information extraction, summarization, question answering, information retrieval, machine translation and text generation. Both textual entailment and paraphrasing address relevant aspects of natural language semantics. Entailment is a directional relation between two expressions in which one of them implies the other, whereas paraphrase is a relation in which two expressions convey essentially the same meaning. Indeed, paraphrase can be defined as bi-directional entailment. While it may be debatable how such semantic definitions can be made well-founded, in practice we have already seen evidence that such knowledge is essential for many applications."},{"id":"72070cce0526d11d20178d22f74528b2.html","title":"Semantic inference at the lexical-syntactic level for textual entailment recognition","url":"https://www.aclweb.org/anthology/W07-1422.pdf","authors":["Roy Bar-Haim","Ido Dagan","Iddo Greental","Idan Szpektor","Moshe Friedman"],"date":"2007/06","abstract":"We present a new framework for textual entailment, which provides a modular integration between knowledge-based exact inference and cost-based approximate matching. Diverse types of knowledge are uniformly represented as entailment rules, which were acquired both manually and automatically. Our proof system operates directly on parse trees, and infers new trees by applying entailment rules, aiming to strictly generate the target hypothesis from the source text. In order to cope with inevitable knowledge gaps, a cost function is used to measure the remaining \u201cdistance\u201d from the hypothesis."},{"id":"87034cf3cfe1d19ef201126e77a5e45b.html","title":"Instance-based evaluation of entailment rule acquisition","url":"https://www.aclweb.org/anthology/P07-1058.pdf","authors":["Idan Szpektor","Eyal Shnarch","Ido Dagan"],"date":"2007/06","abstract":"Obtaining large volumes of inference knowledge, such as entailment rules, has become a major factor in achieving robust semantic processing. While there has been substantial research on learning algorithms for such knowledge, their evaluation methodology has been problematic, hindering further research. We propose a novel evaluation methodology for entailment rules which explicitly addresses their semantic properties and yields satisfactory human agreement levels. The methodology is used to compare two state of the art learning algorithms, exposing critical issues for future progress."},{"id":"9a4c6d1499d7f4766ada44e122fb9b76.html","title":"Cross lingual and semantic retrieval for cultural heritage appreciation","url":"https://www.aclweb.org/anthology/W07-0909.pdf","authors":["Idan Szpektor","Ido Dagan","Alon Lavie","Danny Shacham","Shuly Wintner"],"date":"2007/06","abstract":"We describe a system which enhances the experience of museum visits by providing users with language-technology-based information retrieval capabilities. The system consists of a cross-lingual search engine, augmented by state of the art semantic expansion technology, specifically designed for the domain of the museum (history and archaeology of Israel). We discuss the technology incorporated in the system, its adaptation to the specific domain and its contribution to cultural heritage appreciation."},{"id":"e17099d1e53d079850a55bdfa4041762.html","title":"The third pascal recognizing textual entailment challenge","url":"https://www.aclweb.org/anthology/W07-1401.pdf","authors":["Danilo Giampiccolo","Bernardo Magnini","Ido Dagan","Bill Dolan"],"date":"2007/06","abstract":"This paper presents the Third PASCAL Recognising Textual Entailment Challenge (RTE-3), providing an overview of the dataset creating methodology and the submitted systems. In creating this year\u2019s dataset, a number of longer texts were introduced to make the challenge more oriented to realistic scenarios. Additionally, a pool of resources was offered so that the participants could share common tools. A pilot task was also set up, aimed at differentiating unknown entailments from identified contradictions and providing justifications for overall system decisions. 26 participants submitted 44 runs, using different approaches and generally presenting new entailment models and achieving higher scores than in the previous challenges."},{"id":"18e4e985bcf05a56d09d0e9ca74251a4.html","title":"Participants in action: aspectual meanings and thematic relations interplay in the semantics of semitic morphology","url":"https://dare.uva.nl/record/1/279377","authors":["Reut Tsarfaty"],"date":"2007","journal":"Lecture Notes in Computer Science","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Total citations"},{"id":"379e79b49a8eab584804097e1edf3df6.html","title":"Dimensions of Parameterization for Modern Hebrew Statistical Parsing","url":"https://dare.uva.nl/personal/pure/en/publications/dimensions-of-parameterization-for-modern-hebrew-statistical-parsing(775232c3-7544-4b87-980d-d419064df780).html","authors":["Reut Tsarfaty","K Sima\'an"],"date":"2007","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"389caeff16417bd0c7ebb5e070bbde51.html","title":"Learning canonical forms of entailment rules","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.81.7039&rep=rep1&type=pdf","authors":["Idan Szpektor","Ido Dagan"],"date":"2007","journal":"Proceedings of RANLP","abstract":"We propose a modular approach to paraphrase and entailment-rule learning that addresses the morphosyntactic variability of lexical-syntactic templates. Using an entailment module that captures generic morpho-syntactic regularities, we transform every identified template into a canonical form. This way, statistics from different template variations are accumulated for a single template form. Additionally, morpho-syntactic redundant rules are not acquired. This scheme also yields more informative evaluation for the acquisition quality, since the bias towards rules with many frequent variations is avoided."},{"id":"c3dbb4fedb7c83dcbeb79422fdb2a2eb.html","title":"Toward Better Understanding of Hebrew NP Chunks","url":"https://www.researchgate.net/profile/Michael_Elhadad/publication/228938196_Toward_Better_Understanding_of_Hebrew_NP_Chunks/links/0deec5241441fc4321000000/Toward-Better-Understanding-of-Hebrew-NP-Chunks.pdf","authors":["Yoav Goldberg","Michael Elhadad"],"date":"2007","journal":"ISCOL/BIFSAI 2007","abstract":"In (Goldberg and Elhadad, 2007) we presented two techniques (SVM Model Tampering and Anchored Learning) for investigating the SVM learning process and resulting models. These techniques were applied to the task of SVM based Hebrew NP Chunking. The results were better understanding of SVM based chunking, of the role lexical features play in the learned models, of the Hebrew NP chunking task definition, and identification of several deficencies in the NP Chunking corpus. This paper focuses on the Hebrew specific issues raised by that work, which are presented with more detail."},{"id":"65d52be5a124d42dff5148a667493ab2.html","title":"Feature instability as a criterion for selecting potential style markers","url":"https://onlinelibrary.wiley.com/doi/abs/10.1002/asi.20428","authors":["Moshe Koppel","Navot Akiva","Ido Dagan"],"date":"2006/09","journal":"Journal of the American Society for Information Science and Technology","abstract":"We introduce a new measure on linguistic features, called <i>stability</i>, which captures the extent to which a language element such as a word or a syntactic construct is replaceable by semantically equivalent elements. This measure may be perceived as quantifying the degree of available \u201csynonymy\u201d for a language item. We show that frequent, but unstable, features are especially useful as discriminators of an author\'s writing style."},{"id":"45cfe46ea40253ffb2801ae02565bc00.html","title":"Semantic similarity: what for?","url":"https://dl.acm.org/doi/abs/10.5555/1641976.1641978","authors":["Ido Dagan"],"date":"2006/07/23","abstract":"Linguistic similarity has been a prominent notion and tool in computational linguistics and related areas, as elaborated nicely in the announcement of this workshop. Yet, what exactly counts as\\" similarity\\", or when two linguistic concepts should be regarded as similar, often remains rather vague and ill posed, which is in fact quite typical for unsupervised notions. This talk will focus on similarity at the semantic level, and will explore the perspective that different notions of similarity may be defined relative to concrete modeling goals. In particular, I will refer to the two major goals in semantic modeling: predicting likelihood of occurrence, which is the typical goal in disambiguation and language modeling, and recognizing target meanings, which is the typical semantic goal in text understanding applications such as question answering, information extraction, summarization and information retrieval. We will discuss each\\\\xa0\u2026"},{"id":"05d51e612ab445c97e2ab8b870317935.html","title":"Noun phrase chunking in hebrew: Influence of lexical and morphological features","url":"https://www.aclweb.org/anthology/P06-1087.pdf","authors":["Yoav Goldberg","Meni Adler","Michael Elhadad"],"date":"2006/07/17","abstract":"We present a method for Noun Phrase chunking in Hebrew. We show that the traditional definition of base-NPs as nonrecursive noun phrases does not apply in Hebrew, and propose an alternative definition of Simple NPs. We review syntactic properties of Hebrew related to noun phrases, which indicate that the task of Hebrew SimpleNP chunking is harder than base-NP chunking in English. As a confirmation, we apply methods known to work well for English to Hebrew data. These methods give low results (F from 76 to 86) in Hebrew. We then discuss our method, which applies SVM induction over lexical and morphological features. Morphological features improve the average precision by~ 0.5%, recall by~ 1%, and F-measure by~ 0.75, resulting in a system with average performance of 93% precision, 93.4% recall and 93.2 F-measure.*"},{"id":"83678268951bc5b47e2de63976effcd1.html","title":"Integrating pattern-based and distributional similarity methods for lexical entailment acquisition","url":"https://dl.acm.org/citation.cfm?id=1273148","authors":["Shachar Mirkin","Ido Dagan","Maayan Geffet"],"date":"2006/07/17","abstract":"This paper addresses the problem of acquiring lexical semantic relationships, applied to the lexical entailment relation. Our main contribution is a novel conceptual integration between the two distinct acquisition paradigms for lexical relations-the pattern-based and the distributional similarity approaches. The integrated method exploits mutual complementary information of the two approaches to obtain candidate relations and informative characterizing features. Then, a small size training set is used to construct a more accurate supervised classifier, showing significant increase in both recall and precision over the original approaches."},{"id":"38f862bf4d463343098055c7dcc46336.html","title":"Lexical reference: a semantic matching subtask","url":"https://www.aclweb.org/anthology/W06-1621.pdf","authors":["Oren Glickman","Eyal Shnarch","Ido Dagan"],"date":"2006/07","abstract":"Semantic lexical matching is a prominent subtask within text understanding applications. Yet, it is rarely evaluated in a direct manner. This paper proposes a definition for lexical reference which captures the common goals of lexical matching. Based on this definition we created and analyzed a test dataset that was utilized to directly evaluate, compare and improve lexical matching models. We suggest that such decomposition of the global semantic matching task is critical in order to fully understand and improve individual components."},{"id":"4c9632cd78856a1790313b50e7598cf8.html","title":"Integrated morphological and syntactic disambiguation for Modern Hebrew","url":"https://www.aclweb.org/anthology/P06-3009.pdf","authors":["Reut Tsarfaty"],"date":"2006/07","abstract":"Current parsing models are not immediately applicable for languages that exhibit strong interaction between morphology and syntax, eg, Modern Hebrew (MH), Arabic and other Semitic languages. This work represents a first attempt at modeling morphological-syntactic interaction in a generative probabilistic framework to allow for MH parsing. We show that morphological information selected in tandem with syntactic categories is instrumental for parsing Semitic languages. We further show that redundant morphological information helps syntactic disambiguation."},{"id":"e7b23d88f3d8aada5a9bd77bd2528d4f.html","title":"Direct word sense matching for lexical substitution","url":"https://www.aclweb.org/anthology/P06-1057.pdf","authors":["Ido Dagan","Oren Glickman","Alfio Gliozzo","Efrat Marmorshtein","Carlo Strapparava"],"date":"2006/07","abstract":"This paper investigates conceptually and empirically the novel sense matching task, which requires to recognize whether the senses of two synonymous words match in context. We suggest direct approaches to the problem, which avoid the intermediate step of explicit word sense disambiguation, and demonstrate their appealing advantages and stimulating potential for future research."},{"id":"077dfdde815619943bba05016805fe5e.html","title":"Investigating lexical substitution scoring for subtitle generation","url":"https://www.aclweb.org/anthology/W06-2907.pdf","authors":["Oren Glickman","Ido Dagan","Walter Daelemans","Mikaela Keller","Samy Bengio"],"date":"2006/06","abstract":"This paper investigates an isolated setting of the lexical substitution task of replacing words with their synonyms. In particular, we examine this problem in the setting of subtitle generation and evaluate state of the art scoring methods that predict the validity of a given substitution. The paper evaluates two context independent models and two contextual models. The major findings suggest that distributional similarity provides a useful complementary estimate for the likelihood that two Wordnet synonyms are indeed substitutable, while proper modeling of contextual constraints is still a challenging task for future research."},{"id":"ac032669ca54aa97422d2d5d728224d6.html","title":"Machine Learning Challenges: Evaluating Predictive Uncertainty, Visual Object Classification, and Recognizing Textual Entailment, First Pascal Machine Learning Challenges\\\\xa0\u2026","url":"http://books.google.com/books?hl=en&lr=&id=TT73BwAAQBAJ&oi=fnd&pg=PA1&dq=info:2B7TYnvmxIEJ:scholar.google.com&ots=cuSWKZ0ub4&sig=QengItjD-BscyLQ6e52zVtBBBdY","authors":["Joaquin Qui\\\\xf1onero-Candela","Ido Dagan","Bernardo Magnini","Florence D\'Alch\\\\xe9-Buc"],"date":"2006/04/07","abstract":""},{"id":"6ca16bf224f26cf8e52547c1e1886b53.html","title":"The second pascal recognising textual entailment challenge","url":"http://scholar.google.com/scholar?cluster=4198264021694391846&hl=en&oi=scholarr","authors":["R Bar Haim","Ido Dagan","Bill Dolan","Lisa Ferro","Danilo Giampiccolo","Bernardo Magnini","Idan Szpektor"],"date":"2006/04","journal":"Proceedings of the Second PASCAL Challenges Workshop on Recognising Textual Entailment"},{"id":"9c5957fdcd5fa17ba98e95c40647ba40.html","title":"Investigating a generic paraphrase-based approach for relation extraction","url":"https://www.aclweb.org/anthology/E06-1052.pdf","authors":["Lorenza Romano","Milen Kouylekov","Idan Szpektor","Ido Dagan","Alberto Lavelli"],"date":"2006/04","abstract":"Unsupervised paraphrase acquisition has been an active research field in recent years, but its effective coverage and performance have rarely been evaluated. We propose a generic paraphrase-based approach for Relation Extraction (RE), aiming at a dual goal: obtaining an applicative evaluation scheme for paraphrase acquisition and obtaining a generic and largely unsupervised configuration for RE. We analyze the potential of our approach and evaluate an implemented prototype of it using an RE dataset. Our findings reveal a high potential for unsupervised paraphrase acquisition. We also identify the need for novel robust models for matching paraphrases in texts, which should address syntactic complexity and variability."},{"id":"4aee3c38b8acdef7c2e8ea8ff940ec6d.html","title":"Evaluating Predictive Uncertainty, Visual Objects Classification and Recognising textual entailment: selected proceedings of the First PASCAL Machine Learning Challenges Workshop","url":"https://hal.archives-ouvertes.fr/hal-00343082/","authors":["Joaquin Candela-Quinonero","Ido Dagan","Bernardo Magnini","Florence d\'Alch\\\\xe9-Buc"],"date":"2006"},{"id":"57fd14689e91cc51f4d21e3b3d366240.html","title":"Reviewers for Volume 32","url":"https://www.aclweb.org/anthology/J06-4013.pdf","authors":["Jan Alexandersson","Michael Hess","Tom Morton","Thorsten Brants","Derrick Higgins","Mark-Jan Nederhof","Chris Brew","Graeme Hirst","Ani Nenkova","Claire Cardie","Julia Hockenmaier","Miles Osborne","John Carroll","Rebecca Hwa","David Palmer","Ciprian Chelba","Mark Johnson","Massimo Poesio","Francine Chen","Ron Kaplan","Detlef Prescher","Keh-jiann Chen","Nikiforos Karamanis Phil Resnik","David Chiang","Andy Kehler","Martin Reynaert","Massi Ciaramita","Rodger Kibble","Maarten de Rijke","Christopher Collins","Adam Kilgarriff","Fabio Rinaldi","Michael Collins","Dan Klein","Graeme Ritchie","Ann Copestake","Kevin Knight","Brian Roark","Richard Craggs","Philipp Koehn","Dan Roth","Walter Daelemans","Andras Kornai","Michel Simard","Ido Dagan","Emiel Krahmer","Radu Soricut","Paul Deane","Sadao Kurohashi","Richard Sproat","Mona Diab","Mirella Lapata","Michael Strube","John Dowding","Lillian Lee","G \\\\xf6khan Tur","Phil Edmonds","Beth Levin","Sebastian Varges","David Eichmann","Gina Levow","Richard Wicentowski","Jason Eisner","Hang Li","Dekai Wu","Roger Evans","Elizabeth Liddy","Fei Xia","Radu Florian","Marc Light","Steve Young","George Foster","Jimmy Lin","Menno van Zaanen","Claire Gardent","Benardo Magnini","Annie Zaenen","John Goldsmith","Chris Manning","Fabio Massimo Zanzotto","Gregory Grefenstette Mark Maybury","Pierre Zweigenbaum","Peter Heeman","Mary McGee Wood"],"date":"2006","abstract":"This journal has a knowledgeable and hard-working editorial board, listed on the inside front cover of each issue; but for most submissions we also enlist the aid of specialist reviewers outside the editorial board. The editor of Computational Linguistics would like to express his gratitude to the external reviewers listed below, who anonymously reviewed papers for the journal during the preparation of this volume (Volume 32). Their generosity, judicious judgment, and prompt response substantially helped us to publish a journal that both is timely and maintains exacting scientific standards; it is a genuine pleasure to thank them collectively for their dedicated service."},{"id":"77c05da025c4f65765e74de314495332.html","title":"Strategic intelligence analysis: from information processing to meaning-making","url":"https://link.springer.com/chapter/10.1007/11760146_43","authors":["Yair Neuman","Liran Elihay","Meni Adler","Yoav Goldberg","Amir Viner"],"date":"2006","journal":"Intelligence and Security Informatics","abstract":"Strategic intelligence involves the efforts to understand the \\"Big Picture\\" emerging from data sources. Concerning textual data, this process involves the extraction of meaning from textual information. In this paper we present a new methodology for meaning extraction from news articles. This methodology is based on the gradual construction of visual maps from processed textual information. The methodology is not a substitute for meaning-making by human agents but combines computational power with human evaluation and provides a tool for identifying emerging patterns of meaning."},{"id":"960a59600d6774e62c7843b8501ab56b.html","title":"Evaluating Predictive Uncertainty, Visual Object Categorization and Textual Entailment, volume 3944 of","url":"http://scholar.google.com/scholar?cluster=9651992554516653204&hl=en&oi=scholarr","authors":["J Quinonero-Candela","Ido Dagan","B Magnini","F D\'Alch\\\\xe9-Buc"],"date":"2006"},{"id":"a7d22394cfc478d924d3ed3552b0ee17.html","title":"The interplay of syntax and morphology in building parsing models for modern hebrew","url":"http://www.tsarfaty.com/pdfs/esslli06.pdf","authors":["Reut Tsarfaty"],"date":"2006","journal":"Proceedings of ESSLI Student Session","abstract":"As of yet, there is no statistical parser for Modern Hebrew (MH). Current practice in building parsing models is not immediately applicable to languages that exhibit strong interaction between syntax and morphology, eg Modern Hebrew, Arabic and other Semitic languages. We suggest that incorporating morphological and morphosyntactic information into the parsing model is essential for parsing Semitic languages. Using a morphological analyzer, a part-of-speech tagger, and a PCFG-based general purpose parser, we segment and parse unseen MH sentences using a small annotated corpus. The Parseval scores obtained are not comparable to those of, eg, state-of-the-art models for English, due to remaining syntactic ambiguity and limited morphological treatment. We conjecture that adequate morphological and syntactic processing of MH should be done in a unified framework in which morphology and syntax can freely interact and share information in both directions."},{"id":"af3bab1afab18851235b3122f37762f2.html","title":"Machine Learning Challenges","url":"https://link.springer.com/content/pdf/10.1007/11736790.pdf","authors":["Joaquin Qui\\\\xf1onero-Candela","Ido Dagan","BernardoMagnini Florenced\u2019Alch\\\\xe9-Buc"],"date":"2006","abstract":"The first PASCAL Machine Learning Challenges Workshop (MLCW 2005)(see, www. pascal-network. org/Workshops/PC04/) was held in Southampton, UK, during April 11-13, 2005. This conference was organized by the Challenges programme of the European Network of Excellence PASCAL (Pattern Analysis, Statistical modelling and ComputationAl Learning) in the framework of the IST Programme of the European Community. First annually and now quarterly, the PASCAL Challenges Programme plays the role of selecting and sponsoring challenging tasks, either practical or theoretical. The aim is to raise difficult machine learning questions and to motivate innovative research and development of new approaches. Financial support covers all the work concerning the cleaning and labelling of the data as well as the preparation of evaluation tools for ranking the results. For the first round of the programme, four\\\\xa0\u2026"},{"id":"b345040e8dc3672f3afe1292c893fb02.html","title":"Causative constructions and aspectual meanings: a case study from Semitic derivational morphology","url":"http://www.academia.edu/download/5445850/10.1.1.98.1080.pdf#page=255","authors":["Reut Tsarfaty"],"date":"2005/12/19","journal":"Fifteenth Amsterdam Colloquium","abstract":"This work aims at identifying aspectual properties of events denoted by morphological causatives in Modern Hebrew (MH). The main purpose of this investigation is to establish a clear connection between causative constructions and aspectual meanings, two notions that are not so easily correlated. A secondary goal is to argue for the systematic aspectual contribution of Semitic derivational morphology. Our theory is inspired by Smith\u2019s causal chain and builds on a thematic account of Semitic derivational morphology. Combining a formal and empirical investigation we argue that the MH causative template Hiph\u2019il shifts the viewpoint of an event onto its initiation and development phases, making it more appropriate for imperfective use."},{"id":"a7290f0c471ad322dfcd68636b8c2312.html","title":"A generalized framework for revealing analogous themes across related topics","url":"https://www.aclweb.org/anthology/H05-1123.pdf","authors":["Zvika Marx","Ido Dagan","Eli Shamir"],"date":"2005/10","abstract":"This work addresses the task of identifying thematic correspondences across subcorpora focused on different topics. We introduce an unsupervised algorithmic framework based on distributional data clustering, which generalizes previous initial works on this task. The empirical results reveal interesting commonalities of different religions. We evaluate the results through measuring the overlap of our clusters with clusters compiled manually by experts. The tested variants of our framework are shown to outperform alternative methods applicable to the task."},{"id":"cc459f92cb45f9eb1bd2bd5685165579.html","title":"Investigating unsupervised learning for text categorization bootstrapping","url":"https://www.aclweb.org/anthology/H05-1017.pdf","authors":["Alfio Gliozzo","Carlo Strapparava","Ido Dagan"],"date":"2005/10","abstract":"We propose a generalized bootstrapping algorithm in which categories are described by relevant seed features. Our method introduces two unsupervised steps that improve the initial categorization step of the bootstrapping scheme:(i) using Latent Semantic space to obtain a generalized similarity measure between instances and features, and (ii) the Gaussian Mixture algorithm, to obtain uniform classification probabilities for unlabeled examples. The algorithm was evaluated on two Text Categorization tasks and obtained state-of-theart performance using only the category names as initial seeds."},{"id":"25f30dac32395ce6751cefb384eef71a.html","title":"Participants in Action: The interplay of aspectual meanings and thematic relations in the semantics of Semitic morphology","url":"https://link.springer.com/chapter/10.1007/978-3-540-75144-1_15","authors":["Reut Tsarfaty"],"date":"2005/09/12","abstract":"This work aims to demonstrate that event structure and thematic relations are closely intertwined. Specifically, we show that in Modern Hebrew the choice of a morphological template has profound effects on the event structure of derived verbs. These effects are correlated with the thematic features marked by the templates, and are mediated by the aspectual classification of the lexical material provided by roots."},{"id":"e0a399eddbe3023cc37b7b69f369b01a.html","title":"A probabilistic lexical approach to textual entailment","url":"https://u.cs.biu.ac.il/~nlp/downloads/publications/ProbabilisticLexical.pdf","authors":["Oren Glickman","Ido Dagan","Moshe Koppel"],"date":"2005/07/30","journal":"IJCAI","abstract":"The textual entailment problem is to determine if a given text entails a given hypothesis. This paper describes first a general generative probabilistic setting for textual entailment. We then focus on the sub-task of recognizing whether the lexical concepts present in the hypothesis are entailed from the text. This problem is recast as one of text categorization in which the classes are the vocabulary words. We make novel use of Na\\\\xefve Bayes to model the problem in an entirely unsupervised fashion. Empirical tests suggest that the method is effective and compares favorably with state-of-theart heuristic scoring approaches."},{"id":"076c7595eb2913b2c8adaa1c8fe7c019.html","title":"A probabilistic classification approach for lexical textual entailment","url":"https://www.aaai.org/Papers/AAAI/2005/AAAI05-166.pdf","authors":["Oren Glickman","Ido Dagan","Moshe Koppel"],"date":"2005/07/09","abstract":"The textual entailment task\u2013determining if a given text entails a given hypothesis\u2013provides an abstraction of applied semantic inference. This paper describes first a general generative probabilistic setting for textual entailment. We then focus on the sub-task of recognizing whether the lexical concepts present in the hypothesis are entailed from the text. This problem is recast as one of text categorization in which the classes are the vocabulary words. We make novel use of Na\\\\xefve Bayes to model the problem in an entirely unsupervised fashion. Empirical tests suggest that the method is effective and compares favorably with state-of-the-art heuristic scoring approaches."},{"id":"0dd14fb8b94af23afaecf1123a850a45.html","title":"The distributional inclusion hypotheses and lexical entailment","url":"https://www.aclweb.org/anthology/P05-1014.pdf","authors":["Maayan Geffet","Ido Dagan"],"date":"2005/06","abstract":"This paper suggests refinements for the Distributional Similarity Hypothesis. Our proposed hypotheses relate the distributional behavior of pairs of words to lexical entailment\u2013a tighter notion of semantic similarity that is required by many NLP applications. To automatically explore the validity of the defined hypotheses we developed an inclusion testing algorithm for characteristic features of two words, which incorporates corpus and web-based feature sampling to overcome data sparseness. The degree of hypotheses validity was then empirically tested and manually analyzed with respect to the word sense level. In addition, the above testing algorithm was exploited to improve lexical entailment acquisition."},{"id":"1b9ef5c6a4daa07311494d1bc36e217b.html","title":"Proceedings of the Ninth Conference on Computational Natural Language Learning (CoNLL-2005)","url":"https://www.aclweb.org/anthology/W05-0600.pdf","authors":["Ido Dagan","Daniel Gildea"],"date":"2005/06","abstract":"The 2005 Conference on Computational Natural Language Learning (CoNLL-2005) is the ninth in a series of meetings organized by SIGNLL, the ACL special interest group on natural language learning. This year\u2019s CoNLL will be held in Ann Arbor, Michigan, on June 29 and 30, in conjunction with the ACL 2005 conference."},{"id":"98415e2b116a891509ba065048c9071f.html","title":"Proceedings of the ACL Workshop on Empirical Modeling of Semantic Equivalence and Entailment","url":"https://www.aclweb.org/anthology/W05-1200.pdf","authors":["Bill Dolan","Ido Dagan"],"date":"2005/06","abstract":"The last few years have seen a surge in interest in modeling techniques aimed at measuring semantic equivalence and entailment, with work on paraphrase acquisition/generation, WordNetbased expansion, distributional similarity, supervised learning of semantic variability in information extraction, and the identification of patterns in template-based QA. Being able to identify when two strings\u201d mean the same thing\u201d or that one entails the other are crucial abilities for a broad range of NLP-related applications, ranging from question answering to summarization."},{"id":"de5d41afe8d24446dd55ed02b7176d7a.html","title":"A probabilistic setting and lexical coocurrence model for textual entailment","url":"https://www.aclweb.org/anthology/W05-1208.pdf","authors":["Oren Glickman","Ido Dagan"],"date":"2005/06","abstract":"This paper proposes a general probabilistic setting that formalizes a probabilistic notion of textual entailment. We further describe a particular preliminary model for lexical-level entailment, based on document cooccurrence probabilities, which follows the general setting. The model was evaluated on two application independent datasets, suggesting the relevance of such probabilistic approaches for entailment modeling."},{"id":"012a416bc1af060b74f6e125465bfbf1.html","title":"The PASCAL recognising textual entailment challenge","url":"https://link.springer.com/chapter/10.1007/11736790_9","authors":["Ido Dagan","Oren Glickman","Bernardo Magnini"],"date":"2005/04/11","abstract":"This paper describes the PASCAL Network of Excellence first <i>Recognising Textual Entailment</i> (RTE-1) Challenge benchmark. The RTE task is defined as recognizing, given two text fragments, whether the meaning of one text can be inferred (entailed) from the other. This application-independent task is suggested as capturing major inferences about the variability of semantic expression which are commonly needed across multiple applications. The Challenge has raised noticeable attention in the research community, attracting 17 submissions from diverse groups, suggesting the generic relevance of the task."},{"id":"c877742498663de107846c9ced987a68.html","title":"A lexical alignment model for probabilistic textual entailment","url":"https://link.springer.com/chapter/10.1007/11736790_16","authors":["Oren Glickman","Ido Dagan","Moshe Koppel"],"date":"2005/04/11","abstract":"This paper describes the Bar-Ilan system participating in the Recognising Textual Entailment Challenge. The paper proposes first a general probabilistic setting that formalizes the notion of textual entailment. We then describe a concrete alignment-based model for lexical entailment, which utilizes web co-occurrence statistics in a bag of words representation. Finally, we report the results of the model on the <i>Recognising Textual Entailment</i> challenge dataset along with some analysis."},{"id":"b1e29f9af9a87902a68f2dbcd937d05d.html","title":"Web based probabilistic textual entailment","url":"https://www.researchgate.net/profile/Oren_Glickman/publication/244447093_Web_Based_Probabilistic_Textual_Entailment/links/5e22ee3fa6fdcc101571cd62/Web-Based-Probabilistic-Textual-Entailment.pdf","authors":["Oren Glickman","Ido Dagan","Moshe Koppel"],"date":"2005/04","journal":"Proceedings of the 1st Pascal Challenge Workshop","abstract":"This paper proposes a general probabilistic setting that formalizes the notion of textual entailment. In addition we describe a concrete model for lexical entailment based on web co-occurrence statistics in a bag of words representation."},{"id":"ba7df1bf2c1f7dab0f447e6da49a0fc7.html","title":"binyanim ba\'avir\': An investigation of Aspect Semantics in Modern Hebrew","url":"https://eprints.illc.uva.nl/755/","authors":["Reut Tsarfaty"],"date":"2005/03/3","abstract":""},{"id":"c62857c09c01c877edaca09715b200fa.html","title":"Connecting Causative Constructions and Aspectual Meanings: A Case Study from Semitic Derivational Morphology.","url":"https://dare.uva.nl/record/1/246535","authors":["Reut Tsarfaty"],"date":"2005","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Total citations"},{"id":"53bffdf4b20ff8b686f849ae8ffde9cd.html","title":"Acquiring lexical paraphrases from a single corpus","url":"http://books.google.com/books?hl=en&lr=&id=ejXv2scn794C&oi=fnd&pg=PA81&dq=info:U3mr-q-oL7UJ:scholar.google.com&ots=tjjJp7e0r4&sig=Hx015kFwysH8i8jua3AINYI222M","authors":["Oren Glickman","Ido Dagan"],"date":"2004/11/30","journal":"Recent Advances in Natural Language Processing III. John Benjamins Publishing, Amsterdam, Netherlands","abstract":"This paper studies the potential of extracting lexical paraphrases from a single corpus, focusing on the extraction of verb paraphrases. Most previous approaches detect individual paraphrase instances within a pair (or set) of comparable corpora, each of them containing roughly the same information, and rely on the substantial level of correspondence of such corpora. We present a novel method that successfully detects isolated paraphrase instances within a single corpus without relying on any a-priori structure and information."},{"id":"b41106d0c341a9cf61d8cf6c52affcbb.html","title":"Unsupervised and supervised exploitation of semantic domains in lexical disambiguation","url":"https://www.sciencedirect.com/science/article/pii/S088523080400018X","authors":["Alfio Gliozzo","Carlo Strapparava","Ido Dagan"],"date":"2004/07/01","journal":"Computer Speech & Language","abstract":""},{"id":"87419e07868d01024622c6708f495c63.html","title":"Scaling web-based acquisition of entailment relations","url":"https://www.aclweb.org/anthology/W04-3206.pdf","authors":["Idan Szpektor","Hristo Tanev","Ido Dagan","Bonaventura Coppola"],"date":"2004/07","abstract":"Paraphrase recognition is a critical step for natural language interpretation. Accordingly, many NLP applications would benefit from high coverage knowledge bases of paraphrases. However, the scalability of state-of-the-art paraphrase acquisition approaches is still limited. We present a fully unsupervised learning algorithm for Web-based extraction of entailment relations, an extended model of paraphrases. We focus on increased scalability and generality with respect to prior work, eventually aiming at a full scale knowledge base. Our current implementation of the algorithm takes as its input a verb lexicon and for each verb searches the Web for related syntactic entailment templates. Experiments show promising results with respect to the ultimate goal, achieving much better scalability than prior Web-based methods."},{"id":"b5c85f1d4583f358df934488cad9a4dc.html","title":"Probabilistic textual entailment: Generic applied modeling of language variability","url":"http://www.academia.edu/download/42124110/ProbabilisticTE_fv07.pdf","authors":["Ido Dagan","Oren Glickman"],"date":"2004/01/26","journal":"Learning Methods for Text Understanding and Mining","abstract":"A most prominent phenomenon of natural languages is variability\u2013stating the same meaning in various ways. Robust language processing applications\u2013like Information Retrieval (IR), Question Answering (QA), Information Extraction (IE), text summarization and machine translation\u2013must recognize the different forms in which their inputs and requested outputs might be expressed. Today, inferences about language variability are often performed by practical systems at a\\" shallow\\" semantic level, due to the fact that robust semantic interpretation into logic-based meaning-level representations is not feasible. However, there is yet no generally applicable framework for modeling variability in an application independent manner. Consequently this problem is treated mostly independently within individual systems, and usually to a quite limited extent. In this paper we outline a proposal for a generic model for recognizing language variability at a shallow semantic level, its implementation as a practical engine to be leveraged within a variety of applications, and several learning tasks that it poses. Our approach is based on a notion of textual entailment between text expressions, capturing that the meaning of one expression can be inferred from the other. We propose an inference model that approximates entailment without any explicit interpretation into meaning representations, but rather operating directly over lexical-syntactic units. The model consists of a knowledge base of basic patterns along with compositional probabilistic inference rules, and can be implemented as a practical Prolog-style engine. We further propose learning approaches for\\\\xa0\u2026"},{"id":"d311e9a2932cf4038190078842ecfc76.html","title":"Philosophy of cognition Why people think computers can\u2019t","url":"https://www.academia.edu/download/30693332/MMAI.pdf","authors":["Reut Tsarfaty"],"date":"2004/01/07","abstract":"The purpose of this paper is to present Marvin Minsky\u2019s view of Artificial intelligence, based on three of his papers. This paper is organized as follows. In section 1 I provide a brief introduction to AI and to Marvin Minsky\u2019s work. In sections 2/3 I discuss questions about the limits/capabilities of machines as presented in [Marvin Minsky, 1982], In section 4 I present a theory suggested [Marvin Minsky, 1974] to support his ideas and consequently I show an application of that theory for dealing with different forms of humor as presented in [Marvin Minsky, 1981]. The approaches and examples I present in sections 2 to 4 are all adopted from [Marvin Minsky, 1974][Marvin Minsky, 1981] and [Marvin Minsky, 1982]."},{"id":"0baed24442f248b8dc6267ca34fa10de.html","title":"Statistical and Learning Methods in Natural Language Processing","url":"http://cs.haifa.ac.il/~shuly/teaching/04/statnlp/hpos4.pdf","authors":["Ido Dagan","Shuly Wintner"],"date":"2004","abstract":"Objective: reducing the degree of morphological ambiguity using statistical data automatically derived from large Hebrew corpora, in order to improve the recall of Hebrew search engines."},{"id":"ccf0d46458e9f640653017c756967ac7.html","title":"Introduction to the special issue on word sense disambiguation","url":"https://www.infona.pl/resource/bwmeta1.element.elsevier-bb4d8d31-d995-3a05-b47f-e6163620d56e","authors":["Judita Preiss","Mark Stevenson"],"date":"2004","journal":"Computer Speech & Language"},{"id":"ce6bcde0ac1d08035764c91e3c41168a.html","title":"Feature vector quality and distributional similarity","url":"https://www.aclweb.org/anthology/C04-1036.pdf","authors":["Maayan Geffet","Ido Dagan"],"date":"2004","abstract":"We suggest a new goal and evaluation criterion for word similarity measures. The new criterion-meaning-entailing substitutability-fits the needs of semantic-oriented NLP applications and can be evaluated directly (independent of an application) at a good level of human agreement. Motivated by this semantic criterion we analyze the empirical quality of distributional word feature vectors and its impact on word similarity results, proposing an objective measure for evaluating feature vector quality. Finally, a novel feature weighting and selection function is presented, which yields superior feature vectors and better word similarity performance."},{"id":"014a7d85f2e80a459fe01e803357e5de.html","title":"Course on Empirical Learning Methods in NLP\u2013References","url":"http://cs.haifa.ac.il/~shuly/teaching/04/statnlp/bib.doc","authors":["Ido Dagan"],"date":"2003/06","journal":"Presented at Trento University","abstract":"Foundations of Statistical Natural Language Processing by Christopher D. Manning and Hinrich Sch\\\\xfctze, MIT Press, 1999 (Second printing with corrections\u20132000). The home page for the book is at http://mitpress. mit. edu/catalog/item/default. asp? ttype= 2&tid= 3391."},{"id":"49367d9a91485f51f8761adc4a08de96.html","title":"Identifying structure across pre-partitioned data","url":"https://proceedings.neurips.cc/paper/2003/file/de7092ba6df4276921d27a3704c57998-Paper.pdf","authors":["Zvika Marx","Ido Dagan","Eli Shamir"],"date":"2003","journal":"Advances in neural information processing systems","abstract":"We propose an information-theoretic clustering approach that incorporates a pre-known partition of the data, aiming to identify common clusters that cut across the given partition. In the standard clustering setting the formation of clusters is guided by a single source of feature information. The newly utilized pre-partition factor introduces an additional bias that counterbalances the impact of the features whenever they become correlated with this known partition. The resulting algorithmic framework was applied successfully to synthetic data, as well as to identifying text-based cross-religion correspondences."},{"id":"4f542800f18f2bf1d6d447e9ad61df87.html","title":"A corpus-independent feature set for style-based text categorization","url":"http://www.academia.edu/download/47390282/A_Corpus-Independent_Feature_Set_for_Sty20160720-6271-vkiogp.pdf","authors":["Moshe Koppel","Navot Akiva","Ido Dagan"],"date":"2003","journal":"IJCAI-2003 Workshop on Computational Approaches to Text Style and Synthesis, Acapulco, Mexico","abstract":"We suggest a corpus-independent feature set appropriate for style-based text categorization problems. To achieve this, we introduce a new measure on linguistic features, called stability, which captures the extent to which a language element, such as a word or syntactic construct, is replaceable by semantically equivalent elements. This measure may be perceived as quantifying the degree of available \u201csynonymy\u201d for a language item. We show that frequent but unstable features are especially useful for stylebased text categorization."},{"id":"4c2cd1fbf8ef923b39adca6a259d538c.html","title":"Cross-dataset clustering: Revealing corresponding themes across multiple corpora","url":"https://www.aclweb.org/anthology/W02-2009.pdf","authors":["Ido Dagan","Zvika Marx","Eli Shamir"],"date":"2002","abstract":"We present a method for identifying corresponding themes across several corpora that are focused on related, but distinct, domains. This task is approached through simultaneous clustering of keyword sets extracted from the analyzed corpora. Our algorithm extends the informationbottleneck soft clustering method for a suitable setting consisting of several datasets. Experimentation with topical corpora reveals similar aspects of three distinct religions. The evaluation is by way of comparison to clusters constructed manually by an expert."},{"id":"94bfa76f3463a9c9a6ddb9056f0187e4.html","title":"Crosscomponent clustering for template induction","url":"https://u.cs.biu.ac.il/~nlp/downloads/publications/marx_dagan_02.pdf","authors":["Zvika Marx","Ido Dagan","Eli Shamir"],"date":"2002","journal":"Workshop on Text Learning (TextML-2002), Sydney, Australia","abstract":"We suggest an unsupervised approach to template induction for information extraction, through detecting sub-topics and themes that cut across the documents of a topical corpus. We introduce a new method \u0153 cross component clustering \u0153 that simultaneously clusters the components forming our setting, each of which consists of the words of a single article. Our algorithm is derived from the Information Bottleneck clustering algorithm. The resulting clusters are found to be in systematic correspondence with sets of terms that are used in filling the slots of the MUC3/4 ready-made template, which was used for evaluation."},{"id":"c2af36e469a64077d95e491fa3bbacc5.html","title":"Coupled clustering: a method for detecting structural correspondence","url":"http://www.jmlr.org/papers/v3/marx02a.html","authors":["Zvika Marx","Ido Dagan","Joachim M Buhmann","Eli Shamir"],"date":"2002","journal":"Journal of Machine Learning Research","abstract":"This paper proposes a new paradigm and a computational framework for revealing equivalencies (analogies) between sub-structures of distinct composite systems that are initially represented by unstructured data sets. For this purpose, we introduce and investigate a variant of traditional data clustering, termed coupled clustering, which outputs a configuration of corresponding subsets of two such representative sets. We apply our method to synthetic as well as textual data. Its achievements in detecting topical correspondences between textual corpora are evaluated through comparison to performance of human experts."},{"id":"ce69c1c885af4e2a9b27d425aadd67ac.html","title":"Conceptual mapping through keyword coupled clustering","url":"https://link.springer.com/article/10.1007/BF02512360","authors":["Zvika Marx","Ido Dagan"],"date":"2001/09/01","journal":"Mind & Society","abstract":"This paper introduces coupled clustering\u2014a novel computational framework for detecting corresponding themes in unstructured data. Gaining its inspiration from the structure mapping theory, our framework utilizes unsupervised statistical learning tools for automatic construction of aligned representations reflecting the context of the particular mapping being made. The coupled clustering algorithm is demonstrated and evaluated through detecting conceptual correspondences in textual corpora. In its current phase, the method is primarily oriented towards context-dependent feature-based similarity. However, it is preliminary demonstrated how it could be utilized for identification of relational commonalities, as well."},{"id":"e45ec26c0545a79ca6ef645cb2044ca5.html","title":"Incorporating compositional evidence in memory-based partial parsing","url":"https://www.aclweb.org/anthology/P00-1007.pdf","authors":["Yuval Krymolowski","Ido Dagan"],"date":"2000/10","abstract":"In this paper, a memory-based parsing method is extended for handling compositional structures. The method is oriented for learning to parse any selected subset of target syntactic structures. It is local, yet can handle also compositional structures. Parts of speech as well as embedded instances are being used simultaneously. The output is a partial parse in which instances of the target structures are marked."},{"id":"3e6d28b7b14ce5005e8677fb2591de90.html","title":"Contextual word similarity","url":"http://books.google.com/books?hl=en&lr=&id=VoOLvxyX0BUC&oi=fnd&pg=PA459&dq=info:I1JJMg01ohIJ:scholar.google.com&ots=ww8_IF6On1&sig=4fvfT0dbIh2iEIASvrtv60qpKGk","authors":["Ido Dagan"],"date":"2000/07/25","journal":"Handbook of Natural Language Processing","abstract":"Identifying different types of similarities between words has been an important goal in Natural Language Processing (NLP). This chapter describes the basic statistical approach for computing the degree of similarity between words. In this approach a word is represented by a word co-occurrence vector in which each entry corresponds to another word in the lexicon. The value of an entry specifies the frequency of joint occurrence of the two words in the corpus; that is, the frequency in which they cooccur within some particular relations in the text. The degree of similarity between a pair of words is then computed by some similarity or distance measure that is applied to the corresponding pairs of vectors."},{"id":"c1399d12880bb85a064a4594c8a33ab8.html","title":"A comprehensive bilingual word alignment system","url":"https://link.springer.com/chapter/10.1007/978-94-017-2535-4_4","authors":["Yaacov Choueka","Ehud S Conley","Ido Dagan"],"date":"2000","abstract":"This chapter describes a general, comprehensive and robust word-alignment system and its application to the Hebrew-English language pair. A major goal of the system architecture is to assume as little as possible about its input and about the relative nature of the two languages, while allowing the use of (minimal) specific monolingual pre-processing resources when required. The system thus receives as input a pair of raw parallel texts and requires only a tokeniser (and possibly a lemmatiser) for each language. After tokenisation (and lemmatisation if necessary), a rough initial alignment is obtained for the texts using a version of Fung and McKeown\u2019s <i>DK-vec</i> algorithm (Fung und McKeown, 1997; Fung, this volume). The initial alignment is given as input to a version of the <i>word_ align</i> algorithm (Dagan, Church and Gale, 1993), an extension of Model 2 in the IBM statistical translation model. <i>Word_align</i>\\\\xa0\u2026"},{"id":"07451fd8d5c4b7598e4ded7e392cdc49.html","title":"Committee-based sample selection for probabilistic classifiers","url":"https://www.jair.org/index.php/jair/article/view/10244","authors":["Shlomo Argamon-Engelson","Ido Dagan"],"date":"1999/11/15","journal":"Journal of Artificial Intelligence Research","abstract":"In many real-world learning tasks it is expensive to acquire a sufficient number of labeled examples for training. This paper investigates methods for reducing annotation cost by <i>sample selection</i>. In this approach, during training the learning program examines many unlabeled examples and selects for labeling only those that are most informative at each stage. This avoids redundantly labeling examples that contribute little new information."},{"id":"60d05697f0456c3b41ae4429a4a52c97.html","title":"Similarity-based models of word cooccurrence probabilities","url":"https://link.springer.com/article/10.1023/A:1007537716579","authors":["Ido Dagan","Lillian Lee","Fernando CN Pereira"],"date":"1999/02/01","journal":"Machine learning","abstract":"In many applications of natural language processing (NLP) it is necessary to determine the likelihood of a given word combination. For example, a speech recognizer may need to determine which of the two word combinations \u201ceat a peach\u201d and \u201deat a beach\u201d is more likely. Statistical NLP methods determine the likelihood of a word combination from its frequency in a training corpus. However, the nature of language is such that many word combinations are infrequent and do not occur in any given corpus. In this work we propose a method for estimating the probability of such previously unseen word combinations using available information on \u201cmost similar\u201d words."},{"id":"6f4f514535cf2b3f607491a387391218.html","title":"Eric Brill Dept. of Computer Science brill@ cs. jhu. edu Johns Hopkins University Baltimore, MD, USA James Brooks Dept. of Computer and jbrooks@ gradient. cis. upenn. edu\\\\xa0\u2026","url":"https://link.springer.com/content/pdf/10.1007/978-94-017-2390-9.pdf#page=307","authors":["Kenneth Church","Michael Collins","Bruce Croft","Ido Dagan","Pim van der Eijk","Helmut Feldweg","Hideo Fujii","Cap Gemini"],"date":"1999","journal":"Natural Language Processing Using Very Large Corpora","abstract":"Index accent/diacritic restoration, 100-109, 112, 113, 117,118 acronymic abbreviations, 147 acronyms, 52 adaptive language modeling, 122 adjacent character groups, 139 words, 141 algorithm Baum-Welch, 5, 6, 27, 28, 34, 36-38 inside-outside, 197 convergence, 198 local minima, 199 online, 125 supervised training, 38 unsupervised learning, 33 Viterbi, 1, 15, 103 aligment, 225 character-based, 211 document elements, 267 multiparagraph, 265 offset probability, 216 thresholds, 217 translation probability, 212 word alignment, 209 ambiguity, 275 accent/diacritic, 100, 117 class, 2-4, 7-9 morphological, 47 rate, 6 type, 8 authorship identification, 105 baseline error, 152 Baum-Welch training, 38, 41 Bayesian classifier, 105-107, 111,114-116, 118, 119"},{"id":"ce63226241a938f295ce325dafa36346.html","title":"Proceedings of the Fourth Workshop on Very Large Corpora","url":"http://scholar.google.com/scholar?cluster=10700900845674491184&hl=en&oi=scholarr","authors":["Eva Ejerhed","Ido Dagan"],"date":"1999"},{"id":"f624b6d0daf4c2a29b945e3bad5f637d.html","title":"Detecting sub-topic correspondence through bipartite term clustering","url":"https://www.aclweb.org/anthology/W99-0907.pdf","authors":["Zvika Marx","Ido Dagan","Eli Shamir"],"date":"1999","abstract":"Ido DAGAN The Institute for Info. Retrieval and Computational Linguistics, The Department of Mathematics and Computer Science, Bar-Ilan University Ramat-Gan 52900, Israel, dagan@ cs. biu. ac. il related to each other?"},{"id":"2fcaed52c32c5d18dc7b5a1a74cd543f.html","title":"A memory-based approach to learning shallow natural language patterns","url":"https://arxiv.org/abs/cmp-lg/9806011","authors":["Shlomo Argamon","Ido Dagan","Yuval Krymolowski"],"date":"1998/06/16","journal":"arXiv preprint cmp-lg/9806011","abstract":"Recognizing shallow linguistic patterns, such as basic syntactic relationships between words, is a common task in applied natural language and text processing. The common practice for approaching this task is by tedious manual definition of possible pattern structures, often in the form of regular expressions or finite automata. This paper presents a novel memory-based learning method that recognizes shallow patterns in new text based on a bracketed training corpus. The training data are stored as-is, in efficient suffix-tree data structures. Generalization is performed on-line at recognition time by comparing subsequences of the new text to positive and negative evidence in the corpus. This way, no information in the training is lost, as can happen in other learning systems that construct a single generalized model at the time of training. The paper presents experimental results for recognizing noun phrase, subject-verb and verb-object patterns in English. Since the learning approach enables easy porting to new domains, we plan to apply it to syntactic patterns in other languages and to sub-language patterns for information extraction."},{"id":"b82fe3f77de359f6673efc620b9a37ac.html","title":"Mining text using keyword distributions","url":"https://link.springer.com/article/10.1023/A:1008623632443","authors":["Ronen Feldman","Ido Dagan","Haym Hirsh"],"date":"1998/05/01","journal":"Journal of Intelligent Information Systems","abstract":"Knowledge Discovery in Databases (KDD) focuses on the computerized exploration of large amounts of data and on the discovery of interesting patterns within them. While most work on KDD has been concerned with structured databases, there has been little work on handling the huge amount of information that is available only in unstructured textual form. This paper describes the KDT system for Knowledge Discovery in Text, in which documents are labeled by keywords, and knowledge discovery is performed by analyzing the co-occurrence frequencies of the various keywords labeling the documents. We show how this keyword-frequency approach supports a range of KDD operations, providing a suitable foundation for knowledge discovery and exploration for collections of unstructured text."},{"id":"f6657b3b66341ff0080b271029dc1907.html","title":"Technomonitor.","url":"https://elibrary.ru/item.asp?id=4862864","authors":["Ido Dagan"],"date":"1998","journal":"Online","abstract":"Discusses the trends and technological developments for automating some text-processing tasks and ways these developments can help persons deal with major information access problems. Details on the use of information extraction techniques; Use of manual classification to classify documents by end-users and information specialists."},{"id":"6c146c916385cd07dcb42f878d68e261.html","title":"Similarity-based methods for word sense disambiguation","url":"https://arxiv.org/abs/cmp-lg/9708010","authors":["Ido Dagan","Lillian Lee","Fernando Pereira"],"date":"1997/08/18","journal":"arXiv preprint cmp-lg/9708010","abstract":"We compare four similarity-based estimation methods against back-off and maximum-likelihood estimation methods on a pseudo-word sense disambiguation task in which we controlled for both unigram and bigram frequency. The similarity-based methods perform up to 40% better on this particular task. We also conclude that events that occur only once in the training set have major impact on similarity-based estimates."},{"id":"21b250aedc96eebe4590324736b128e0.html","title":"Mistake-driven learning in text categorization","url":"https://arxiv.org/abs/cmp-lg/9706006","authors":["Ido Dagan","Yael Karov","Dan Roth"],"date":"1997/06/09","journal":"arXiv preprint cmp-lg/9706006","abstract":"Learning problems in the text processing domain often map the text to a space whose dimensions are the measured features of the text, eg, its words. Three characteristic properties of this domain are (a) very high dimensionality,(b) both the learned concepts and the instances reside very sparsely in the feature space, and (c) a high variation in the number of active features in an instance. In this work we study three mistake-driven learning algorithms for a typical task of this nature--text categorization. We argue that these algorithms--which categorize documents by learning a linear separator in the feature space--have a few properties that make them ideal for this domain. We then show that a quantum leap in performance is achieved when we further modify the algorithms to better address some of the specific characteristics of the domain. In particular, we demonstrate (1) how variation in document length can be tolerated by either normalizing feature weights or by using negative weights,(2) the positive effect of applying a threshold range in training,(3) alternatives in considering feature frequency, and (4) the benefits of discarding features while training. Overall, we present an algorithm, a variation of Littlestone\'s Winnow, which performs significantly better than any other algorithm tested on this task using a similar feature set."},{"id":"fd0266c3b2104a3775538ca2925665fc.html","title":"Termight: Coordinating humans and machines in bilingual terminology acquisition","url":"https://link.springer.com/article/10.1023/A:1007926723945","authors":["Ido Dagan","Ken Church"],"date":"1997/03/01","journal":"Machine translation","abstract":"We propose a semi-automatic tool, termight, that supports the construction of bilingual glossaries. Termight consists of two components which address the two subtasks in glossary construction: (a) preparing a monolingual list of all technical terms in a source-language document, and (b) finding the translations for these terms in parallel source\u2013target documents. As a first step (in each component) the tool extracts automatically candidate terms and candidate translations, based on term-extraction and word-alignment algorithms. It then performs several additional preprocessing steps which greatly facilitate human post-editing of the candidate lists. These steps include grouping and sorting of candidates and associating example concordance lines with each candidate. Finally, the data prepared in preprocessing is presented to the user via an interactive interface which supports quick post-editing operations\\\\xa0\u2026"},{"id":"7877fe6d45cbf14af01ffcf40d791f4d.html","title":"Mistake-driven learning with thesaurus for text categorization","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.1482&rep=rep1&type=pdf","authors":["Takefumi Yamazaki","Ido Dagan"],"date":"1997","journal":"Proceedings of NLPRS-97, the Natural Language Processing Pacific Rim Symposium","abstract":"This paper extends the mistake-driven learner WINNOW to better utilize thesauri for text categorization. In our method not only words but also semantic categories given by the thesaurus are used as features in a classier. New ltering and disambiguation methods are used as pre-processing to solve the problems caused by the use of the thesaurus. In order to verify our methods, we test a large body of tagged Japanese newspaper articles created by RWCP1. Experimental results show that WINNOW with thesauri attains high accuracy and that the proposed ltering and disambiguation methods also contribute to the improved accuracy."},{"id":"3081b2e38a3451a780ab21173573a59d.html","title":"Minimizing manual annotation cost in supervised training from corpora","url":"https://arxiv.org/abs/cmp-lg/9606030","authors":["Sean P Engelson","Ido Dagan"],"date":"1996/06/24","journal":"arXiv preprint cmp-lg/9606030","abstract":"Corpus-based methods for natural language processing often use supervised training, requiring expensive manual annotation of training corpora. This paper investigates methods for reducing annotation cost by {\\\\\\\\it sample selection}. In this approach, during training the learning program examines many unlabeled examples and selects for labeling (annotation) only those that are most informative at each stage. This avoids redundantly annotating examples that contribute little new information. This paper extends our previous work on {\\\\\\\\it committee-based sample selection} for probabilistic classifiers. We describe a family of methods for committee-based sample selection, and report experimental results for the task of stochastic part-of-speech tagging. We find that all variants achieve a significant reduction in annotation cost, though their computational efficiency differs. In particular, the simplest method, which has no parameters to tune, gives excellent results. We also show that sample selection yields a significant reduction in the size of the model used by the tagger."},{"id":"155d74a2c2b1f1d73f4690d11aaf58cc.html","title":"Computational Linguistics ISSN 0891-2017","url":"https://www.aclweb.org/anthology/J96-2000.pdf","authors":["Julia Hirschberg","Robert C Berwick","Graeme Hirst","Richard Sproat","Pierre Isabelle","Robert JP Ingria","Hiyan Alshawi","Mark Johnson","John Lafferty","Lori Levin","Johanna Moore","Stephen Pulman","Mats Rooth","Keh-Yih Su","David Weir","Anne Abeille","Patrick Blackburn","Susan Brennan","Matt Crocker","Ido Dagan","Masaaki Nagata","Megumi Kameyama","Ed Stabler","Kees van Deemter","Gregory Ward","Pete Whitelock","Eric Brill","Richard Crouch","David Johnson","Julian Kupiec","Emmanuel Roche","Hinrich Schiitze","Marilyn Walker"],"date":"1996/06","journal":"Computational Linguistics","abstract":"Creative Commons License ACL materials are Copyright\\\\xa9 1963\u20132019 ACL; other materials are copyrighted by their respective copyright holders. Materials prior to 2016 here are licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 International License. Permission is granted to make copies for the purposes of teaching and research. Materials published in or after 2016 are licensed on a Creative Commons Attribution 4.0 International License."},{"id":"e273ff05dead65b08f7cb2a369e7a6ce.html","title":"Keyword-based browsing and analysis of large document sets","url":"https://www.academia.edu/download/49469460/Keyboard_sdair.pdf","authors":["Ido Dagan","Ronen Feldman","Haym Hirsh"],"date":"1996/04","journal":"Proceedings of the symposium on document analysis and information retrieval (SDAIR-96), Las Vegas, Nevada","abstract":"Knowledge Discovery in Databases (KDD) focuses on the computerized exploration of large amounts of data and on the discovery of interesting patterns within them. While most work on KDD has been concerned with structured databases, there has been little work on handling the huge amount of information that is available only in unstructured textual form. This paper describes the KDT system for Knowledge Discovery in Texts. It is built on top of a text-categorization paradigm where text articles are annotated with keywords organized in a hierarchical structure. Knowledge discovery is performed by analyzing the co-occurrence frequencies of"},{"id":"0a2068bc17d19c0ba8eed9575f7255d8.html","title":"Efficient algorithms for mining and manipulating associations in texts","url":"http://scholar.google.com/scholar?cluster=18025103419565185400&hl=en&oi=scholarr","authors":["Ronen Feldman","Ido Dagan","W Kloesgen"],"date":"1996","journal":"CYBERNETICS AND SYSTEMS RESEARCH"},{"id":"cf7012f358a3ec4f7fb64609256b5612.html","title":"Proceedings of the Fourth Workshop on Very Large Corpora: 4 August 1996, University of Copenhagen, Copenhagen, Denmark","url":"http://scholar.google.com/scholar?cluster=5478008953305989381&hl=en&oi=scholarr","authors":["Eva Ejerhed","Ido Dagan"],"date":"1996"},{"id":"c8fe48dfb2d539788cc6542c574a26dd.html","title":"Syntax and lexical statistics in anaphora resolution","url":"https://www.tandfonline.com/doi/abs/10.1080/08839519508945492","authors":["Ido Dagan","John Justeson","Shalom Lappin","Herbert Leass","Amnon Ribak"],"date":"1995/11/01","journal":"Applied Artificial Intelligence an International Journal","abstract":"We describe a syntactically based salience algorithm for pronominal anaphora resolution and a procedure for reevaluating the decisions of the algorithm on the basis of statistically modeled lexical semantic/pragmatic preferences. We report the results of an extensive blind test of both systems on computer manual text. We discuss the implications of these results for the comparative roles of syntactically defined salience and statistically measured lexical preference in determining the references of pronouns in text."},{"id":"2f2a7fdec0ea4023eabcd7505fc946f8.html","title":"Sample selection in natural language learning","url":"https://link.springer.com/chapter/10.1007/3-540-60925-3_50","authors":["Sean P Engelson","Ido Dagan"],"date":"1995/08/20","abstract":"Many corpus-based methods for natural language processing are based on supervised training, requiring expensive manual annotation of training corpora. This paper investigates reducing annotation cost by <i>sample selection</i>. In this approach, the learner examines many unlabeled examples and selects for labeling only those that are most informative at each stage of training. In this way it is possible to avoid redundantly annotating examples that contribute little new information. The paper first analyzes the issues that need to be addressed when constructing a sample selection algorithm, arguing for the attractiveness of <i>committee-based</i> selection methods. We then focus on selection for training probabilistic classifiers, which are commonly applied to problems in statistical natural language processing. We report experimental results of applying a specific type of committee-based selection during training of a\\\\xa0\u2026"},{"id":"95d6afb64f31ec4e3663f9dad7e778e3.html","title":"Knowledge Discovery in Textual Databases (KDT).","url":"https://www.aaai.org/Papers/KDD/1995/KDD95-012.pdf","authors":["Ronen Feldman","Ido Dagan"],"date":"1995/08/20","journal":"KDD","abstract":"The information age is characterized by a rapid growth in the amount of information available in electronic media. Traditional data handling methods are not adequate to cope with this information flood. Knowledge Discovery in Databases (KDD) is a new paradigm that focuses on computerized exploration of large amounts of data and on discovery of relevant and interesting patterns within them. While most work on KDD is concerned with structured databases, it is clear that this paradigm is required for handling the huge amount of information that is available only in unstructured textual form. To apply traditional KDD on texts it is necessary to impose some structure on the data that would be rich enough to allow for interesting KDD operations. On the other hand, we have to consider the severe limitations of current text processing technology and define rather simple structures that can be extracted from texts fairly automatically and in a reasonable cost. We propose using a text categorization paradigm to annotate text articles with meaningful concepts that are organized in hierarchical structure. We suggest that this relatively simple annotation is rich enough to provide the basis for a KDD framework, enabling data summarization, exploration of interesting patterns, and trend analysis. This research combines the KDD and text categorization paradigms and suggests advances to the state of the art in both areas."},{"id":"aa590dd151ce35f0ce299459ce113836.html","title":"Knowledge discovery in textual database (KDT)","url":"http://scholar.google.com/scholar?cluster=18353641162458083912&hl=en&oi=scholarr","authors":["Ronen Feldman","Ido Dagan"],"date":"1995/08","journal":"Proceedings of the first ACM SIGKDD International Conference on Knowledge Discovery and Data Mining"},{"id":"9c85dc0bff9d5bb3443b442c3f59b850.html","title":"Committee-based sampling for training probabilistic classifiers","url":"https://www.sciencedirect.com/science/article/pii/B978155860377650027X","authors":["Ido Dagan","Sean P Engelson"],"date":"1995/01/1","abstract":"<div><div class=\\"gsh_csp\\">In many real-world learning tasks, it is expensive to acquire a sufficient number of labeled examples for training. This paper proposes a general method for efficiently training probabilistic classifiers, by selecting for training only the more informative examples in a stream of unlabeled examples. The method, <i>committee-based sampling</i>, evaluates the informativeness of an example by measuring the degree of disagreement between several model variants. These variants (the committee) are drawn randomly from a probability distribution conditioned by the training set selected so far (Monte-Carlo sampling). The method is particularly attractive because it evaluates the expected information gain from a training example implicitly, making the model both easy to implement and generally applicable."},{"id":"cf2ba650e9ce914bb94fd4eed5240407.html","title":"Selective sampling in natural language learning","url":"https://www.aaai.org/Papers/BISFAI/1995/BISFAI95-006.pdf","authors":["Ido Dagan","Sean P Engelson"],"date":"1995","journal":"Proceedings of the IJCAI Workshop on New Approaches to Learning for Natural Language Processing","abstract":"Many corpus-based methods for natural language processing are based on supervised training, requiring expensive manual annotation of training corpora. This paper investigates reducing annotation cost by selective sampling. In this approach, the learner examines many unlabeled examples and selects for labeling only those that are most informative at each stage of training. In this way it is possible to avoid redundantly annotating examples that contribute little new information. The paper first analyzes the issues that need to be addressed when constructing a selective sampling algorithm, arguing for the attractiveness of committee-based sampling methods. We then focus on selective sampling for training probabilistic classifiers, which are commonly applied to problems in statistical natural language processing. We report experimental results of applying a specific type of committee-based sampling during\\\\xa0\u2026"},{"id":"64d3c6cd50efa419e523ab419851fc4e.html","title":"Termight: Identifying and translating technical terminology","url":"https://www.aclweb.org/anthology/A94-1006.pdf","authors":["Ido Dagan","Kenneth Church"],"date":"1994/10","abstract":"We propose a semi-automatic tool, termight, that helps professional translators and terminologists identify technical terms and their translations. The tool makes use of part-of-speech tagging and wordalignment programs to extract candidate terms and their translations. Although the extraction programs are far from perfect, it isn\'t too hard for the user to filter out the wheat from the chaff. The extraction algorithms emphasize completeness. Alternative proposals are likely to miss important but infrequent terms/translations. To reduce the burden on the user during the filtering phase, candidates are presented in a convenient order, along with some useful concordance evidence, in an interface that is designed to minimize keystrokes. Termight is currently being used by the translators at AT\u2022 T Business Translation Services (formerly AT&T Language Line Services)."},{"id":"da844f8c1d91e2c59a12497cfa4bc525.html","title":"Similarity-based estimation of word cooccurrence probabilities","url":"https://arxiv.org/abs/cmp-lg/9405001","authors":["Ido Dagan","Fernando Pereira","Lillian Lee"],"date":"1994/05/02","journal":"arXiv preprint cmp-lg/9405001","abstract":"In many applications of natural language processing it is necessary to determine the likelihood of a given word combination. For example, a speech recognizer may need to determine which of the two word combinations``eat a peach\'\'and``eat a beach\'\'is more likely. Statistical NLP methods determine the likelihood of a word combination according to its frequency in a training corpus. However, the nature of language is such that many word combinations are infrequent and do not occur in a given corpus. In this work we propose a method for estimating the probability of such previously unseen word combinations using available information on``most similar\'\'words. We describe a probabilistic word association model based on distributional word similarity, and apply it to improving probability estimates for unseen word bigrams in a variant of Katz\'s back-off model. The similarity-based method yields a 20% perplexity improvement in the prediction of unseen bigrams and statistically significant reductions in speech-recognition error."},{"id":"1e44682b6fc01c7b4520d65b96e79101.html","title":"Word sense disambiguation using a second language monolingual corpus","url":"https://dl.acm.org/doi/abs/10.5555/203987.203991","authors":["Ido Dagan","Alon Itai"],"date":"1994","journal":"Computational linguistics","abstract":"This paper presents a new approach for resolving lexical ambiguities in one language using statistical data from a monolingual corpus of another language. This approach exploits the differences between mappings of words to senses in different languages. The paper concentrates on the problem of target word selection in machine translation, for which the approach is directly applicable. The presented algorithm identifies syntactic relations between words, using a source language parser, and maps the alternative interpretations of these relations to the target language, using a bilingual lexicon. The preferred senses are then selected according to statistics on lexical relations in the target language. The selection is based on a statistical model and on a constraint propagation algorithm, which simultaneously handles all ambiguities in the sentence. The method was evaluated using three sets of Hebrew and German\\\\xa0\u2026"},{"id":"c7546971458b6cacf6f7ec987af945ba.html","title":"Aligning parallel texts: Do methods developed for English-French generalize to Asian languages","url":"https://pdfs.semanticscholar.org/8d02/1434c8da92634a49cead486826789af8ffff.pdf","authors":["Kenneth Church","Ido Dagan","William Gale","Pascale Fung","Jon Helfman","Bala Satish"],"date":"1993/08/10","journal":"Proceedings of the Pacific Asia Conference on Formal and Computational Linguistics","abstract":"Parallel texts have recently received considerable attention in machine translation (eg, Brown et al, 1990), bilingual lexicography (eg, Klavans and Tzoukermann, 1990), and terminology research for human translators (eg, Isabelle, 1992). We have been most interested in the terminology application. How would Microsoft, or some other software vendor, want the term\\" dialog box\\" to be translated in their manuals? Technical terms such as\\" dialog box\\" are difficult for translators because they are generally not as familiar with the subject domain as either the author of the source, text or the reader of the target text. Parallel texts could be used to help translators overcome their lack of domain expertise by providing them with the ability to search previously translated documents for examples of potentially difficult terminology and see how they were translated in the past.\\" Existing translations contain more solutions to more translation problems than any other existing resource.\\"(Isabelle, 1992)"},{"id":"c099d29175a9e7637b61eb5e85ccc637.html","title":"Contextual word similarity and estimation from sparse data","url":"https://www.aclweb.org/anthology/P93-1022.pdf","authors":["Ido Dagan","Shaul Marcus","Shaul Markovitch"],"date":"1993/06","abstract":"In recent years there is much interest in word cooccurrence relations, such as n-grams, verbobject combinations, or cooccurrence within a limited context. This paper discusses how to estimate the probability of cooccurrences that do not occur in the training data. We present a method that makes local analogies between each specific unobserved cooccurrence and other cooccurrences that contain similar words, as determined by an appropriate word similarity metric. Our evaluation suggests that this method performs better than existing smoothing methods, and may provide an alternative to class based models."},{"id":"51839a106221f5f871fd99fa113a6d08.html","title":"Robust bilingual word alignment for machine aided translation","url":"https://www.aclweb.org/anthology/W93-0301.pdf","authors":["Ido Dagan","Kenneth Church","Willian Gale"],"date":"1993","abstract":"We have developed a new program called word_align for aligning parallel text, text such as the Canadian Hansards that are available in two or more languages. The program takes the output of char_align (Church, 1993), a robust alternative to sentence-based alignment programs, and applies word-level constraints using a version of Brown el al.\'s Model 2 (Brown et al., 1993), modified and extended to deal with robustness issues. Word_align was tested on a subset of Canadian Hansards supplied by Simard (Simard et al., 1992). The combination of word_align plus char_align reduces the variance (average square error) by a factor of 5 over char_align alone. More importantly, because word_align and char_align were designed to work robustly on texts that are smaller and more noisy than the Hansards, it has been possible to successfully deploy the programs at AT&T Language Line Services, a commercial translation service, to help them with difficult terminology."},{"id":"64c7352c2d13671309ccf313e199c8dd.html","title":"A Combined Symbolic-empirical Approach for the Automatic Translation of Compounds","url":"http://scholar.google.com/scholar?cluster=1034527605485457882&hl=en&oi=scholarr","authors":["Ulrike Rackow","Ido Dagan","Ulrike Schwall"],"date":"1992"},{"id":"c764559b57dc36e3a96389360c949e64.html","title":"Automatic translation of noun compounds","url":"https://www.aclweb.org/anthology/C92-4201.pdf","authors":["Ulrike Rackow","Ido Dagan","Ulrike Schwall"],"date":"1992","abstract":"It is widely known that the word formation mechanism of compounding is highly productive, in Ger man as well as in English, and that efficient strategies have to bc, lcvelopcd to dcal with this linguistic phe nomenon in any kind of NI, 1 system. Although this fact is generally agreed upon and a lot of linguistic rc search has been it, me, it has not bccn possible so fat to, levelop a general and overall pro,: cdure to solve the probh: m in a satisfactory aud ade, lnatc way ((: f."},{"id":"cb9605429ecfb914b29ffa4026d66d36.html","title":"Multilingual statistical approaches for natural language disambiguation","url":"http://scholar.google.com/scholar?cluster=14432641086509145325&hl=en&oi=scholarr","authors":["Ido Dagan"],"date":"1992","journal":"Doctoral dissertation, Israel Institute of Technology, Haifa, Israel"},{"id":"6926933dde62e104e653b3f9f889841f.html","title":"A set expression based inheritance system","url":"https://link.springer.com/article/10.1007/BF01531060","authors":["Ido Dagan","Alon Itai"],"date":"1991/09/01","journal":"Annals of Mathematics and Artificial Intelligence","abstract":"This paper describes a new formalism for inheritance systems, based on the formal semantics of set expressions. Using the formalism, it is possible to define new semantic classes by arbitrary set expressions operating on previously defined classes. Thus generalizing both<i>IS-A</i> links and<i>IS-NOT-A</i> links and adding the set intersection operation. We present an efficient algorithm which follows these definitions to deduce the properties implied by the inheritance network, i.e., the properties of the classes containing a given element. The application which motivated the development of the formalism, namely semantic disambiguation of natural language, is also described."},{"id":"74b1418cbd702ad840be60af010be171.html","title":"A statistical filter for resolving pronoun references","url":"http://books.google.com/books?hl=en&lr=&id=NVltkYpCcrYC&oi=fnd&pg=PA125&dq=info:8-Nv59vv7CUJ:scholar.google.com&ots=GctFbMffof&sig=q1K3JztnvBRz7C4g3hFdR8e9NM0","authors":["YA Feldman","A Bruckstein"],"date":"1991/06/17","journal":"Artificial Intelligence and Computer Vision","abstract":"Current methods for resolving pronoun references assume the existence of selectional constraints to \ufb01lter out semantically inappropriate referents. However, such constraints are usually not available for broad domains, because of the need to acquire a huge amount of information. This work suggests to use statistical data on cooccurrence patterns instead of selec-tional constraints. These patterns were collected automatically from large corpora and were used to \ufb01lter out implausible candidates. The method was combined with Hobbs\u2019 algorithm to resolve references of the pronoun \u201cit\u201d. The results of an initial experiment are presented, and show that the addition of the statistical data to the disambiguation mechanism indeed improves its performance."},{"id":"b37dbe147579d39415eff857e43ce94b.html","title":"Two languages are more informative than one","url":"https://www.aclweb.org/anthology/P91-1017.pdf","authors":["Ido Dagan","Alon Itai","Ulrike Schwall"],"date":"1991/06","abstract":"This paper presents a new approach for resolving lexical ambiguities in one language using statistical data on lexical relations in another language. This approach exploits the differences between mappings of words to senses in different languages. We concentrate on the problem of target word selection in machine translation, for which the approach is directly applicable, and employ a statistical model for the selection mechanism. The model was evaluated using two sets of Hebrew and German examples and was found to be very useful for disambiguation."},{"id":"fb8d9cd9d844dd65ca69939b3fcbd6cc.html","title":"Lexical disambiguation: sources of information and their statistical realization","url":"https://www.aclweb.org/anthology/P91-1048.pdf","authors":["Ido Dagan"],"date":"1991/06","abstract":"Lexieal disambiguation can be achieved using different sources of information. Aiming at high performance of automatic disambiguation it is important to know the relative importance and applicability of the various sources. In this paper we classify several sources of information and show how some of them can be achieved using statistical data. First evaluations indicate the extreme importance of local information, which mainly represents lexical associations and seleetional restrictions for syntactically related words."},{"id":"1eed31525b16aa798617227c1b5d0f8e.html","title":"Automatic processing of large corpora for the resolution of anaphora references","url":"https://www.aclweb.org/anthology/C90-3063.pdf","authors":["Ido Dagan","Alon Itai"],"date":"1990","abstract":"Manual acquisition of semantic constraints in broad domains is very expensive. This paper presents an automatic scheme for collecting statistics on cooccurrence patterns in a large corpus. To a large extent, these statistics reflect, semantic constraints and thus are used to disambiguate anaphora references and syntactic ambiguities. The scherne was implemented by gathering statistics on the output of other linguistic tools. An experiment was performed to resolve references of the pronoun\\" it\\" in sentences that were randomly selected from the corpus. Ttle results of the experiment show that in most of the cases the cooccurrence statistics indeed reflect the semantic constraints and thus provide a basis {\'or a useful disambiguat. ion tool."},{"id":"fea291ae6775f7f3a0215c00351a417b.html","title":"Automatic acquisition of constraints for the resolution of anaphora references and syntactic ambiguities","url":"http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/1990/CS/CS0626.pdf","authors":["Ido Dagan","Alon Itai"],"date":"1990","abstract":"Manual acquisition of semantic constraints in broad domains is very expensive. This paper presents an automatic scheme for collecting statistics on cooccurrence patterns in a large corpus. To a large extent, these statistics reflect semantic constraints and ihus are used to disambiguate anaphora references and syntactic ambiguities. The scheme was implemented by gathering statistics on the output of other linguistic tools. An experiment was performed to resolve references of the pronoun\\" it\\" in sentences that were randomly selected from the corpus. The results of the experiment show that in most of the cases the cooccurrence statistics indeed reflect the semantic constraints and thus provide a basis for a useful disambiguation tool."},{"id":"4807d52cbaea0716b5fb956c677403ac.html","title":"Semantic disambiguation in MT: A prototype and its consequences","url":"http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-info.cgi/1989/CS/CS0548","authors":["Ido Dagan","Alon Itai"],"date":"1989","abstract":"This paper describes a program and a fonnal model for disambiguation in machine translation. The model uses semantic constraints and was implemented for English-to-Hebrew translation. It solves in a unified way both syntactic and lexical (target word selection) ambiguities. The model reduces the redundancy in the representation of semantic constraints and thus reduces the overall size of the semantic database as well as facilitating its acquisition. Our model implies that the same constraints may be used for translation in both directions. Using this property we suggest a scheme for the automatic acquisition of the semantic database using corpora from both languages."},{"id":"09ae66e278dedb19bec2afe87e068c54.html","title":"Cited by 179","url":"https://scholar.google.co.il/scholar?oi=bibs&hl=en&oe=ASCII&cites=1143417000908024923&as_sdt=5","authors":["Ron Yair Pinter ","Ido Dagan","Martin Charles Golumbic"],"date":"1988","journal":"Discrete Applied Mathematics"},{"id":"06a5017b08491d0db7b848ef357908e8.html","title":"Natural Language Knowledge Graphs","url":"https://www.tsdconference.org/tsd2016/video/1609_TSD_NLKG.pdf","authors":["Ido Dagan"],"abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"106125728a2b5cee0dcf985bc56dd697.html","title":"19. CONTEXTUAL WORD SIMILARITY","url":"https://gramatica.usc.es/~gamallo/aulas/MasterLexicografia/biblio/Dagan_similarity.pdf","authors":["Ido Dagan"],"abstract":"Identifying different types of similarities between words has been an important goal in Natural Language Processing (NLP). This chapter describes the basic statistical approach for computing the degree of similarity between words. In this approach a word is represented by a word co-occurrence vector in which each entry corresponds to another word in the lexicon. The value of an entry specifies the frequency of joint occurrence of the two words in the corpus, that is, the frequency in which they co-occur within some particular relationships in the text. The degree of similarity between a pair of words is then computed by some similarity or distance measure that is applied to the corresponding pairs of vectors. This chapter describes in detail different types of lexical relationships that can be used for constructing word cooccurrence vectors. It then defines a schematic form for vector-based similarity measures and describes concrete measures that correspond to the general form. We also give examples for word similarities identified by corpus-based measures, along with \u201cexplanations\u201d of the major data elements that entailed the observed similarity. This chapter describes in detail the basic vector-based approach for computing word similarity. Similarities may be computed between different lexical units, such as word strings, word lemmas, and multi-word terms or phrases. We shall use the term \u201cword\u201d to denote a lexical unit but the discussion applies to other units as well."},{"id":"1e29264bba1829756f9f0d020c9d77c2.html","title":"EXploring Customer Interactions through Textual EntailMENT","url":"https://pdfs.semanticscholar.org/03a7/28dc1876f503419a6b2a42e68253ce773346.pdf","authors":["Ido Dagan","Bernardo Magnini","Guenter Neumann","Sebastian Pado"],"abstract":"EXCITEMENT is a 3-year research project (1/2012-12/2014) funded by the European Commission under FP7. The project consortium includes NICE Systems LTD (Israel) as coordinator, four academic partners, University of Bar Ilan (Israel), DFKI (Germany), FBK (Italy), University of Heidelberg (Germany), and two industrial partners, Almawave SRL (Italy) and OMQ GmbH (Germany). The main topic of the project is identifying semantic inferences between text units, a major language processing task, needed in practically all text understanding applications. While such inferences are broadly needed, there are currently no generic semantic engines or platforms for broad textual inference. The primary scientific motivation for the EXCITEMENT project is to change this ineffective state of affairs and to offer an encompassing open source platform for textual inference. On the industrial side, EXCITEMENT is focused on the text analytics market and follows the increasing demand for automatically analyzing customer interactions, which today cross multiple channels including speech, email, chat and social media."},{"id":"272083e25f6dfd114b07c87388d0a7cc.html","title":"Supporting Material for the Paper: Rich Parameterization Improves RNA Structure Prediction","url":"https://pdfs.semanticscholar.org/ff40/06c112812cef905889c00a55830843452896.pdf","authors":["Shay Zakov","Yoav Goldberg","Michael Elhadad","Michal Ziv-Ukelson"],"abstract":"We specify here the features which are used by our models. Each feature description is composed of two parts: a description of a structural element, and a (possibly empty) description of a sequential context. All models discussed in the paper are obtained by combining a set of structural elements St with a set of sequential contexts Co, and producing all corresponding features (ie producing a feature for each structural element in St and a corresponding sequential context from Co). In Section 1 we define the different loop types, which are used for categorizing structural elements. In Section 2 we give the three sets of structural elements Stbase, Stmed, and Sthigh, and in Section 3 we give the three sets of sequential contexts Cobase, Comed, and Cohigh, which are used in our models. All examples in the text refer to the sequence-folding (x, y) depicted in Fig. 1."},{"id":"2b29ba0a705f1d8f7105b6f46b129826.html","title":"Cited by 3","url":"https://scholar.google.co.il/scholar?oi=bibs&hl=en&oe=ASCII&cites=3365042071955341514&as_sdt=5","authors":["Micah Shlain","Hillel Taub-Tabib","Shoval Sadde","Yoav Goldberg"]},{"id":"3019b98e0410cebf419f065ee1657a0e.html","title":"Bringing Textual Descriptions to Life: Semantic Parsing of Requirements Documents into Executable Scenarios","url":"https://www.openu.ac.il/iscol2015/downloads/ISCOL2015_submission6_c_2.pdf","authors":["Ilia Pogrebezky","Smadar Szekely","Reut Tsarfaty","David Harel"],"abstract":"We present an end-to-end framework for translating natural language (NL) requirements into executable systems. Specifically, we implement semantic parsers for two sorts of input:(i) requirements documents written in a controlled natural language (CNL), and (ii) requirements documents written in NL. For each requirements document, we output the system model (SM) architecture along with a set of live sequence charts (LSCs) that capture the dynamic behavior of the specified system. Our parsers are embedded in PlayGo, a development environment for specifying (playing-in) requirements as LSCs and executing (playing-out) the resulting behavior. Thus, our output systems may be depicted visually, executed interactively, or provided as a standalone Java executable. PlayGo further allows for post-editing the predicted output via a friendly GUI, thus enabling the rapid development of parallel text: code data for statistical natural language programming."},{"id":"33305d7315d62c18a86d723794dc9843.html","title":"Generating Language from BlissSymbols Using Semantic Authoring","url":"https://www.cs.bgu.ac.il/~yoavg/publications/Issac2006bliss.doc","authors":["Yael Netzer","Ofer Biller","Michael Elhadad","Yoav Goldberg"],"abstract":"Objectives"},{"id":"3d7489853315475323bbc3d69d762a7e.html","title":"Full Access","url":"https://dl.acm.org/doi/abs/10.5555/1868771","authors":["Djam\\\\xc3\\\\xa9 Seddah","Sandra K\\\\xc3\\\\xbcbler","Reut Tsarfaty"],"abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_oci_field\\">Scholar articles"},{"id":"42ac00538bfea6bb9d85b5ca4809b653.html","title":"Effective Paraphrase Expansion in Addressing Lexical Variability","url":"https://fruct.org/publications/abstract-AINL-FRUCT-2016/files/Kon.pdf","authors":["Vasily Konovalov","Meni Adler","Ido Dagan"],"abstract":"In this paper, we investigate the contribution of automatically generated translation-based paraphrases to address lexical variability with application in dialogue systems. We compare the proposed methods with the state of the art approach. Furthermore, we define the desired criteria for the pivot language to generate the paraphrases, and find that the performance of paraphrase expansion correlates well with the averaged smoothed BLEU measure. The results suggest that:(1) The paraphrase expansion leads to better performance than the bag of words baseline.(2) The gain in performance often comes from a few most effective pivot languages.(3) The differences between machine translation engines are not reflected in empirical evaluation. By using the most effective pivot languages we can save the expenses to generate additional paraphrases, and as a result, to save the resources to train a classification model."},{"id":"437c48ba73d2f1c4d7b0dfb2a50eba23.html","title":"Evaluating recurrent neural networks as cognitive models of syntax","url":"http://tallinzen.net/media/papers/linzen_et_al_rnn_agreement.pdf","authors":["Tal Linzen","Emile Enguehard","Yoav Goldberg","Emmanuel Dupoux"],"abstract":"We analyze the ability of modern recurrent neural networks (RNNs) to learn subject-verb number agreement, a phenomenon considered to require a representation of the structure of the sentence; our goal was to assess the potential of RNNs to serve as cognitive models of syntax. Given explicit supervision, the network made few errors overall, but error rates increased in more complex sentences, and the pattern of errors was qualitatively different than in human experiments. Multi-task learning narrowed the gap between RNNs and humans. In summary, RNNs may be able to develop structural representations, but require strong supervision to do so."},{"id":"5c7779b7da21cd0798143533511b1137.html","title":"Contextual Preferences for Name-based Text Categorization","url":"http://scholar.google.com/scholar?cluster=6265193869646916067&hl=en&oi=scholarr","authors":["Shachar Mirkin","Ido Dagan","Lili Kotlerman","Idan Szpektor"],"abstract":"Name-based Text Categorization (TC) is an unsupervised setting of TC where the only input provided is the category name. Prior work suggested considering for categorization only candidate documents that contain terms that directly entail the category name. A major issue with this method\u2013the ambiguity in entailing terms\u2013was addressed by matching between vector-space representation of contexts for the rule and the tested document. We propose a novel context model for identifying invalid rule application, which utilizes classifiers for context representation. We suggest a general scheme that may be utilized in any inference-based task, and demonstrate an implementation for TC based on selfsupervised classifiers. Our experiments on standard TC datasets show that our model outperforms state-of-the-art context models."},{"id":"5c7e0ce0e9a028be87ff2d5d523e0df2.html","title":"Acquiring lexical paraphrases from a single corpus 1 Index of Subjects and Terms 11","url":"https://u.cs.biu.ac.il/~nlp/downloads/publications/ranlp03-book.pdf","authors":["Oren Glickman","Ido Dagan"],"abstract":"This paper studies the potential of extracting lexical paraphrases from a single corpus, focusing on the extraction of verb paraphrases. Most previous approaches detect individual paraphrase instances within a pair (or set) of comparable corpora, each of them containing roughly the same information, and rely on the substantial level of correspondence of such corpora. We present a novel method that successfully detects isolated paraphrase instances within a single corpus without relying on any a-priori structure and information."},{"id":"5e32e7324862cabf64b51a0159fcdf5b.html","title":"19.1. 1. Applications of word similarity","url":"http://u.cs.biu.ac.il/~nlp/downloads/publications/contextual_word_similarity.doc","authors":["Ido Dagan"],"abstract":"The concept of word similarity was traditionally captured within thesauri. A thesaurus is a lexicographic resource that specifies semantic relationships between words, listing for each word related words such as synonyms, hyponyms and hypernyms. Thesauri have been used to assist writers in selecting appropriate words and terms and in enriching the vocabulary of a text. To this end, modern word processors provide a thesaurus as a built in tool."},{"id":"62ebf0cdd1d86e1f0dfbad1f84ea27cd.html","title":"Evaluating Relation Inference via Question Answering Supplementary Material","url":"http://scholar.google.com/scholar?cluster=10835016893165936010&hl=en&oi=scholarr","authors":["Omer Levy","Ido Dagan","Extracting Open IE Assertions"],"abstract":"We extracted over 63 million unique subjectrelation-object triplets from Google\u2019s Syntactic N-grams (Goldberg and Orwant, 2013), including the number of times each one appeared in the corpus. This collection represents over 1.5 billion distinct appearances. The assertions may include multiword phrases as relations or arguments, for example:(chocolate, is made from, the cocoa bean): 22"},{"id":"6907fcfb38f94e6dee6dde5c78874822.html","title":"Findings of the First WMT Shared Task on Sign Language Translation","url":"https://www.statmt.org/wmt22/pdf/2022.wmt-1.71.pdf","authors":["Mathias M\\\\xc3\\\\xbcller","Sarah Ebling","Eleftherios Avramidis","Alessia Battisti","Mich\\\\xc3\\\\xa8le Berger","HfH Zurich","Richard Bowden","Annelies Braffort","Necati Cihan Camg\\\\xc3\\\\xb6z","Cristina Espa\\\\xc3\\\\xb1a-Bonet","Roman Grundkiewicz","Zifan Jiang","Oscar Koller","Amit Moryossef","Regula Perrollaz","Sabine Reinhard","Annette Rios","Dimitar Shterionov","Sandra Sidler-Miserez","Katja Tissi","Davy Van Landuyt"],"abstract":"This paper presents the results of the First WMT Shared Task on Sign Language Translation (WMT-SLT22) 1. This shared task is concerned with automatic translation between signed and spoken 2 languages. The task is novel in the sense that it requires processing visual information (such as video frames or human pose estimation) beyond the wellknown paradigm of text-to-text machine translation (MT). The task featured two tracks, translating from Swiss German Sign Language (DSGS) to German and vice versa. Seven teams participated in this first edition of the task, all submitting to the DSGS-to-German track. Besides a system ranking and system papers describing state-of-the-art techniques, this shared task makes the following scientific contributions: novel corpora, reproducible baseline systems and new protocols and software for human evaluation. Finally, the task also resulted in the first publicly available set of system outputs and human evaluation scores for sign language translation."},{"id":"70d48ea580d8e75ea3821f1cd052fdff.html","title":"Dialog Natural Language Understanding using a Generic Textual Inference System","url":"http://events.eventact.com/afeka/aclp2012/Dialogue%20Natural%20Language%20Understanding_Segal-halevi%20et%20al.pdf","authors":["Erel Segal-haLevi","Ido Dagan"],"abstract":"One of the components of a dialog system is the Natural Language Understanding (NLU) component. This component accepts natural language text, and returns the meaning of that text, in some formal application-specific meaning representation. One of the difficulties in building NLU components is the variability in natural language-the many different ways by which a human can express the same meaning. We propose to tackle this difficulty by using a generic Textual Entailment (TE) system-a system that can calculate, for each pair of texts, whether the meaning of one of them can be inferred from the other. A single TE system can be used for various NLU components in various domains."},{"id":"7386c9bc4926e78c16ccef0a03ca472d.html","title":"Publications of last four years","url":"http://www.coli.uni-saarland.de/~hansu/bio.pdf","authors":["Georg Rehm","Hans Uszkoreit","Ido Dagan","Vartkes Goetcherian","Mehmet Ugur Dogan","Coskun Mermer","Tam\\\\xe1s V\\\\xe1radi","Sabine Kirchmeier-Andersen","Gerhard Stickel","Meirion Prys Jones","Stefan Oeter","Sigve Gramstad"],"abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"74e3d00a3965638acadf295ef50e9363.html","title":"Razvan Bunescu (Ohio University, USA) Evgeniy Gabrilovich (Yahoo! Research, USA)","url":"https://www.aaai.org/Papers/Workshops/2008/WS-08-15/WS08-15-014.pdf","authors":["Rada Mihalcea","Eugene Agichtein","Einat Amitay","Mikhail Bilenko","Chris Brew","Timothy Chklovski","Massimiliano Ciaramita","Andras Csomai","Silviu Cucerzan","Ido Dagan","Ravi Kumar","Oren Kurland","Lillian Lee","Elizabeth Liddy","Daniel Marcu","Shaul Markovitch","Raymond Mooney","Vivi Nastase","Bo Pang","Marius Pasca","Ted Pedersen","Simone Paolo Ponzetto","Dragomir Radev","Dan Roth","Peter Turney"],"abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"7a1224ccfe886c2efe568e3105d2cbaf.html","title":"Agreement Matters: Challenges of Translating into a Morphologically Rich Language, and the Advantages of a Syntax-Based System","url":"http://cl.haifa.ac.il/MT/abstracts/goldberg.pdf","authors":["Yoav Goldberg"],"abstract":"Consider the following (simple) English sentences:\u201cI drive a car.\u201d,\u201cI don\u2019t know how to drive\u201d,\u201cI wash the car\u201d,\u201cI wash the floor\u201d. Translating them to Hebrew using Google\u2019s statistical MT system, yields: \u043e \u0434 \u0432 \u0434 \u0434 (I drive (masculine) a car); \u0434\u0430 \u043e\u0436 \u0430 \u0434 (I don\u2019t know (feminine) how to drive); \u0439 \u043c \u0434 \u043e \u0434 \u0432 \u043e (I wash (masculine) the car); and \u0438\u043a\u043c \u043e \u043e\u0438 \u043d \u0434 (I wash (feminine) the floor). While amusing and not quite politically correct, these are all arguably very good translations: without explicit gender marking, the translator can not know if the speaker is masculine or feminine, and he (she?) resorts to deciding based on her (his?) cultural knowledge."},{"id":"83786244456cea14dac19af8426c49c8.html","title":"Transition-Based Morphological Disambiguation","url":"https://www.openu.ac.il/iscol2015/downloads/ISCOL2015_submission_31_d_1.pdf","authors":["Amir More","Reut Tsarfaty"],"abstract":"In Morphologically Rich Languages (MRLs), sentences are composed of ambiguous space-delimited tokens that ought to be disambiguated with respect to their constituent morphemes. Previous work on Morphological Disambiguation (MD) of MRLs has had variable success, with Semitic languages having sub-par results for downstream applications. Here we propose novel MD transition-based systems, both word-based and morphemebased, and tackle the challenge introduced by the variable length of hypothesized morpheme sequences. Our experiments show that transition-based morphemebased MD consistently outperforms the word-based variant, while providing new state of the art results on Hebrew MD."},{"id":"89414bf78ecc707ea93ae764e39ff979.html","title":"Remote Participants","url":"https://openreview.net/pdf?id=Ju3H1n2XHch#page=49","authors":["Timothy Baldwin","Verginica Barbu Mititelu","Emily M Bender","Archna Bhatia","IHMC Florida","US Bernd Bohnet","Francis Bond","TU Nanyang","SG Cem Bozsahin","TR Ankara","Ryan Cotterell","William Croft","US Alburquerque","Miryam de Lhoneux","Marie-Catherine de Marneffe","US Columbus","Jamie Findlay","Daniel Flickinger","Kim Gerdes","FR Orsay","Voula Giouli","Tunga Gungor","Jan Hajic","Dag Haug","Uxoa I\\\\xc3\\\\xb1urrieta","ES Donostia","Laura Kallmeyer","Christo Kirov","Maria Koptjevskaja Tamm","Artur Kulmizev","Lori Levin","Natalia Levshina","NL Psycholinguistics\\\\xe2\\\\x80\\\\x93Nijmegen","Teresa Lynn","Stella Markantonatou","Nurit Melnik","Paola Merlo","Yusuke Miyao","Kadri Muischnek","Joakim Nivre","Petya Osenova","BG Sofia","Stephen Pepper","James Pustejovsky","US Waltham","Alexandre Rademaker","Carlos Ramisch","Manfred Sailer","DE Main","Agata Savary","Emmanuel Schang","Nathan Schneider","Ivelina Stoyanova","Sara Stymne","Reut Tsarfaty","Francis M Tyers","Meagan Vigus","Aline Villavicencio","Veronika Vincze","Ekaterina Vylomova","Nianwen Xue","David Yarowsky","US Baltimore","Amir Zeldes","Daniel Zeman","Tim Zingler"],"journal":"Universals of Linguistic Idiosyncrasy in Multilingual Computational Linguistics","abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_oci_field\\">Scholar articles"},{"id":"aa0a10562bda6e66044ed770b1e29c62.html","title":"Supplementary Material-Extracting Automata from Recurrent Neural Networks Using Queries and Counterexamples","url":"http://proceedings.mlr.press/v80/weiss18a/weiss18a-supp.pdf","authors":["Gail Weiss","Yoav Goldberg","Eran Yahav"],"abstract":"The algorithm maintains an observation table (S, E, T) that records whether strings belong to U. In Algorithm 1, this table is represented by the two-dimensional array T, with dimensions| S|\\\\xd7| E|, where, informally, we can view S as a set of words that lead from the initial state to states of the hypothesized automaton, and E as a set of words serving as experiments to separate states. The table T itself maps a word w\u2208(S\u222a S\\\\xb7 \u03a3)\\\\xb7 E to True if w\u2208 U and False otherwise."},{"id":"ae4a99f691a8e74575a160aa824b1c13.html","title":"Index of Subjects and Terms 11","url":"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.295.2659&rep=rep1&type=pdf","authors":["Oren Glickman","Ido Dagan"],"abstract":"This paper studies the potential of extracting lexical paraphrases from a single corpus, focusing on the extraction of verb paraphrases. Most previous approaches detect individual paraphrase instances within a pair (or set) of comparable corpora, each of them containing roughly the same information, and rely on the substantial level of correspondence of such corpora. We present a novel method that successfully detects isolated paraphrase instances within a single corpus without relying on any a-priori structure and information."},{"id":"de643c74ed6d9c622c2d54d311623faf.html","title":"Learning to Exploit Structured Resources for Lexical Inference","url":"https://pdfs.semanticscholar.org/cee9/4959cf360f86587a7aea2106d29d525d6bc5.pdf","authors":["Vered Shwartz Omer Levy","Ido Dagan","Jacob Goldberger"],"abstract":"Massive knowledge resources, such as Wikidata, can provide valuable information for lexical inference, especially for proper-names. Prior resource-based approaches typically select the subset of each resource\u2019s relations which are relevant for a particular given task. The selection process is done manually, limiting these approaches to smaller resources such as WordNet, which lacks coverage of propernames and recent terminology. This paper presents a supervised framework for automatically selecting an optimized subset of resource relations for a given target inference task. Our approach enables the use of large-scale knowledge resources, thus providing a rich source of high-precision inferences over proper-names."},{"id":"bfa74531b8ebc7edf02b82719f6a33c2.html","title":"Be principled! A Probabilistic Model for Lexical Entailment","url":"https://www.cs.bgu.ac.il/~adlerm/iscol11/bisfai11_submission_4.pdf","authors":["Eyal Shnarch","Jacob Goldberger","Ido Dagan"],"abstract":"Recognizing lexical entailment is a prominent task addressed by most textual entailment systems. Nevertheless, it is approached mostly by heuristic methods which do not address major aspects of the lexical entailment scenario. We present, for the first time, a principled probabilistic approach for this task. Our model covers prominent aspects such as integrating various resources with different reliability, taking into account the length of the entailed sentence, the number of its covered terms and the existence of multiple evidence for the entailment of a term. Evaluations validate the impact of our model components and show that its performance is in line with the best published entailment systems."},{"id":"c5fd579e186300e4057f4743d25713ea.html","title":"Larraitz Uria, Viktor Varga, Veronika Vincze, Zdenek \u02c7Zabokrtsk\\\\xfd, Daniel Zeman, and Hanzhi Zhu. 2015","url":"http://scholar.google.com/scholar?cluster=1847268529356725851&hl=en&oi=scholarr","authors":["Joakim Nivre","Maria Jesus Aranzabe \u02c7Zeljko Agic","Masayuki Asahara","Aitziber Atutxa","Miguel Ballesteros","John Bauer","Kepa Bengoetxea","Riyaz Ahmad Bhat","Cristina Bosco","Sam Bowman","Giuseppe GA Celano","Miriam Connor","Marie-Catherine de Marneffe","Arantza Diaz de Ilarraza","Kaja Dobrovoljc","Timothy Dozat","Tomaz Erjavec","Rich\\\\xe1rd Farkas","Jennifer Foster","Daniel Galbraith","Filip Ginter","Iakes Goenaga","Koldo Gojenola","Yoav Goldberg","Berta Gonzales","Bruno Guillaume","Jan Hajic","Dag Haug","Radu Ion","Elena Irimia","Anders Johannsen","Hiroshi Kanayama","Jenna Kanerva","Simon Krek","Veronika Laippala","Alessandro Lenci","Nikola Ljube\u0161ic","Teresa Lynn","Christopher Manning","Catalina Maranduc","David Marecek","H\\\\xe9ctor Mart\u0131nez Alonso","Jan Ma\u0161ek","Yuji Matsumoto","Ryan McDonald","Anna Missil\\\\xe4","Verginica Mititelu","Yusuke Miyao","Simonetta Montemagni","Shunsuke Mori","Hanna Nurmi","Petya Osenova","Lilja \\\\xd8vrelid","Elena Pascual","Marco Passarotti","Cenel-Augusto Perez","Slav Petrov","Jussi Piitulainen","Barbara Plank","Martin Popel","Prokopis Prokopidis","Sampo Pyysalo","Rudolf Rosa Loganathan Ramasamy","Shadi Saleh","Sebastian Schuster","Wolfgang Seeker","Mojgan Seraji","Natalia Silveira","Maria Simi","Radu Simionescu","Katalin Simk\\\\xf3","Kiril Simov","Aaron Smith","Jan \u0160tep\\\\xe1nek","Alane Suhr","Zsolt Sz\\\\xe1nt\\\\xf3","Takaaki Tanaka","Reut Tsarfaty","Sumire Uematsu"],"journal":"Universal dependencies"},{"id":"d158e7a5a2044e54734a6b17a7222245.html","title":"Symposium on Foundations of Artificial Intelligence","url":"https://www.aaai.org/Papers/BISFAI/1995/BISFAI95-028.pdf","authors":["Mat\\\\xedas Alvarado","Ofer Arieli","Arnon Avron","Consistent Data from Inconsistent","A Knowledge-Bases","Chad Burkey","Charles B Callaway","Jacques Calmet","Valery Cherniaev","Ido Dagan","Jonathan Ginzburg","Dan Givoli","John Grant","Jaroslaw Gryz","Lawrence Henschen","Chuen-Hsuen Jeff Ho","Karsten Homann"],"abstract":"<div class=\\"gs_scl\\"><div class=\\"gsc_vcd_field\\">Scholar articles"},{"id":"d3c7f03e12e765196aa72e2f9f7044a0.html","title":"B-56: Modeling Word Meaning in Context with Substitute Vectors","url":"http://scholar.google.com/scholar?cluster=12103993865900108166&hl=en&oi=scholarr","authors":["Oren Melamud","Ido Dagan","Jacob Goldberger"]}]')},zUnb:function(e,t,a){"use strict";function n(e){return"function"==typeof e}a.r(t);let i=!1;const r={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else i&&console.log("RxJS: Back to a better error behavior. Thank you. <3");i=e},get useDeprecatedSynchronousErrorHandling(){return i}};function s(e){setTimeout(()=>{throw e},0)}const o={closed:!0,next(e){},error(e){if(r.useDeprecatedSynchronousErrorHandling)throw e;s(e)},complete(){}},l=(()=>Array.isArray||(e=>e&&"number"==typeof e.length))();function c(e){return null!==e&&"object"==typeof e}const h=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();let d=(()=>{class e{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._ctorUnsubscribe=!0,this._unsubscribe=e)}unsubscribe(){let t;if(this.closed)return;let{_parentOrParents:a,_ctorUnsubscribe:i,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,a instanceof e)a.remove(this);else if(null!==a)for(let e=0;e<a.length;++e)a[e].remove(this);if(n(r)){i&&(this._unsubscribe=void 0);try{r.call(this)}catch(o){t=o instanceof h?u(o.errors):[o]}}if(l(s)){let e=-1,a=s.length;for(;++e<a;){const a=s[e];if(c(a))try{a.unsubscribe()}catch(o){t=t||[],o instanceof h?t=t.concat(u(o.errors)):t.push(o)}}}if(t)throw new h(t)}add(t){let a=t;if(!t)return e.EMPTY;switch(typeof t){case"function":a=new e(t);case"object":if(a===this||a.closed||"function"!=typeof a.unsubscribe)return a;if(this.closed)return a.unsubscribe(),a;if(!(a instanceof e)){const t=a;a=new e,a._subscriptions=[t]}break;default:throw new Error("unrecognized teardown "+t+" added to Subscription.")}let{_parentOrParents:n}=a;if(null===n)a._parentOrParents=this;else if(n instanceof e){if(n===this)return a;a._parentOrParents=[n,this]}else{if(-1!==n.indexOf(this))return a;n.push(this)}const i=this._subscriptions;return null===i?this._subscriptions=[a]:i.push(a),a}remove(e){const t=this._subscriptions;if(t){const a=t.indexOf(e);-1!==a&&t.splice(a,1)}}}return e.EMPTY=function(e){return e.closed=!0,e}(new e),e})();function u(e){return e.reduce((e,t)=>e.concat(t instanceof h?t.errors:t),[])}const p=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class m extends d{constructor(e,t,a){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=o;break;case 1:if(!e){this.destination=o;break}if("object"==typeof e){e instanceof m?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new g(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new g(this,e,t,a)}}[p](){return this}static create(e,t,a){const n=new m(e,t,a);return n.syncErrorThrowable=!1,n}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class g extends m{constructor(e,t,a,i){let r;super(),this._parentSubscriber=e;let s=this;n(t)?r=t:t&&(r=t.next,a=t.error,i=t.complete,t!==o&&(s=Object.create(t),n(s.unsubscribe)&&this.add(s.unsubscribe.bind(s)),s.unsubscribe=this.unsubscribe.bind(this))),this._context=s,this._next=r,this._error=a,this._complete=i}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;r.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:a}=r;if(this._error)a&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)a?(t.syncErrorValue=e,t.syncErrorThrown=!0):s(e),this.unsubscribe();else{if(this.unsubscribe(),a)throw e;s(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);r.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(a){if(this.unsubscribe(),r.useDeprecatedSynchronousErrorHandling)throw a;s(a)}}__tryOrSetError(e,t,a){if(!r.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,a)}catch(n){return r.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=n,e.syncErrorThrown=!0,!0):(s(n),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const f=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function b(e){return e}let y=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const a=new e;return a.source=this,a.operator=t,a}subscribe(e,t,a){const{operator:n}=this,i=function(e,t,a){if(e){if(e instanceof m)return e;if(e[p])return e[p]()}return e||t||a?new m(e,t,a):new m(o)}(e,t,a);if(i.add(n?n.call(i,this.source):this.source||r.useDeprecatedSynchronousErrorHandling&&!i.syncErrorThrowable?this._subscribe(i):this._trySubscribe(i)),r.useDeprecatedSynchronousErrorHandling&&i.syncErrorThrowable&&(i.syncErrorThrowable=!1,i.syncErrorThrown))throw i.syncErrorValue;return i}_trySubscribe(e){try{return this._subscribe(e)}catch(t){r.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:a,isStopped:n}=e;if(t||n)return!1;e=a&&a instanceof m?a:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=w(t))((t,a)=>{let n;n=this.subscribe(t=>{try{e(t)}catch(i){a(i),n&&n.unsubscribe()}},a,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[f](){return this}pipe(...e){return 0===e.length?this:(0===(t=e).length?b:1===t.length?t[0]:function(e){return t.reduce((e,t)=>t(e),e)})(this);var t}toPromise(e){return new(e=w(e))((e,t)=>{let a;this.subscribe(e=>a=e,e=>t(e),()=>e(a))})}}return e.create=t=>new e(t),e})();function w(e){if(e||(e=r.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const v=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class _ extends d{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const a=t.indexOf(this.subscriber);-1!==a&&t.splice(a,1)}}class x extends m{constructor(e){super(e),this.destination=e}}let k=(()=>{class e extends y{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[p](){return new x(this)}lift(e){const t=new S(this,this);return t.operator=e,t}next(e){if(this.closed)throw new v;if(!this.isStopped){const{observers:t}=this,a=t.length,n=t.slice();for(let i=0;i<a;i++)n[i].next(e)}}error(e){if(this.closed)throw new v;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,a=t.length,n=t.slice();for(let i=0;i<a;i++)n[i].error(e);this.observers.length=0}complete(){if(this.closed)throw new v;this.isStopped=!0;const{observers:e}=this,t=e.length,a=e.slice();for(let n=0;n<t;n++)a[n].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new v;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new v;return this.hasError?(e.error(this.thrownError),d.EMPTY):this.isStopped?(e.complete(),d.EMPTY):(this.observers.push(e),new _(this,e))}asObservable(){const e=new y;return e.source=this,e}}return e.create=(e,t)=>new S(e,t),e})();class S extends k{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):d.EMPTY}}function T(e){return e&&"function"==typeof e.schedule}function C(e,t){return function(a){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return a.lift(new E(e,t))}}class E{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new A(e,this.project,this.thisArg))}}class A extends m{constructor(e,t,a){super(e),this.project=t,this.count=0,this.thisArg=a||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(a){return void this.destination.error(a)}this.destination.next(t)}}const I=e=>t=>{for(let a=0,n=e.length;a<n&&!t.closed;a++)t.next(e[a]);t.complete()};function R(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const M=R(),P=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function D(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const L=e=>{if(e&&"function"==typeof e[f])return n=e,e=>{const t=n[f]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(P(e))return I(e);if(D(e))return a=e,e=>(a.then(t=>{e.closed||(e.next(t),e.complete())},t=>e.error(t)).then(null,s),e);if(e&&"function"==typeof e[M])return t=e,e=>{const a=t[M]();for(;;){let t;try{t=a.next()}catch(n){return e.error(n),e}if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof a.return&&e.add(()=>{a.return&&a.return()}),e};{const t=c(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,a,n};function N(e,t){return new y(a=>{const n=new d;let i=0;return n.add(t.schedule(function(){i!==e.length?(a.next(e[i++]),a.closed||n.add(this.schedule())):a.complete()})),n})}function O(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[f]}(e))return function(e,t){return new y(a=>{const n=new d;return n.add(t.schedule(()=>{const i=e[f]();n.add(i.subscribe({next(e){n.add(t.schedule(()=>a.next(e)))},error(e){n.add(t.schedule(()=>a.error(e)))},complete(){n.add(t.schedule(()=>a.complete()))}}))})),n})}(e,t);if(D(e))return function(e,t){return new y(a=>{const n=new d;return n.add(t.schedule(()=>e.then(e=>{n.add(t.schedule(()=>{a.next(e),n.add(t.schedule(()=>a.complete()))}))},e=>{n.add(t.schedule(()=>a.error(e)))}))),n})}(e,t);if(P(e))return N(e,t);if(function(e){return e&&"function"==typeof e[M]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new y(a=>{const n=new d;let i;return n.add(()=>{i&&"function"==typeof i.return&&i.return()}),n.add(t.schedule(()=>{i=e[M](),n.add(t.schedule(function(){if(a.closed)return;let e,t;try{const a=i.next();e=a.value,t=a.done}catch(n){return void a.error(n)}t?a.complete():(a.next(e),this.schedule())}))})),n})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof y?e:new y(L(e))}class j extends m{constructor(e){super(),this.parent=e}_next(e){this.parent.notifyNext(e)}_error(e){this.parent.notifyError(e),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class W extends m{notifyNext(e){this.destination.next(e)}notifyError(e){this.destination.error(e)}notifyComplete(){this.destination.complete()}}function z(e,t){if(!t.closed)return e instanceof y?e.subscribe(t):L(e)(t)}function B(e,t,a=Number.POSITIVE_INFINITY){return"function"==typeof t?n=>n.pipe(B((a,n)=>O(e(a,n)).pipe(C((e,i)=>t(a,e,n,i))),a)):("number"==typeof t&&(a=t),t=>t.lift(new G(e,a)))}class G{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new H(e,this.project,this.concurrent))}}class H extends W{constructor(e,t,a=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=a,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const a=this.index++;try{t=this.project(e,a)}catch(n){return void this.destination.error(n)}this.active++,this._innerSub(t)}_innerSub(e){const t=new j(this),a=this.destination;a.add(t);const n=z(e,t);n!==t&&a.add(n)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e){this.destination.next(e)}notifyComplete(){const e=this.buffer;this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function F(e=Number.POSITIVE_INFINITY){return B(b,e)}function q(e,t){return t?N(e,t):new y(I(e))}function Q(...e){let t=Number.POSITIVE_INFINITY,a=null,n=e[e.length-1];return T(n)?(a=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof n&&(t=e.pop()),null===a&&1===e.length&&e[0]instanceof y?e[0]:F(t)(q(e,a))}function Y(){return function(e){return e.lift(new U(e))}}class U{constructor(e){this.connectable=e}call(e,t){const{connectable:a}=this;a._refCount++;const n=new V(e,a),i=t.subscribe(n);return n.closed||(n.connection=a.connect()),i}}class V extends m{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:a}=this,n=e._connection;this.connection=null,!n||a&&n!==a||n.unsubscribe()}}class K extends y{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new d,e.add(this.source.subscribe(new J(this.getSubject(),this))),e.closed&&(this._connection=null,e=d.EMPTY)),e}refCount(){return Y()(this)}}const X=(()=>{const e=K.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class J extends x{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function Z(){return new k}function $(e){return{toString:e}.toString()}const ee="__parameters__";function te(e,t,a){return $(()=>{const n=function(e){return function(...t){if(e){const a=e(...t);for(const e in a)this[e]=a[e]}}}(t);function i(...e){if(this instanceof i)return n.apply(this,e),this;const t=new i(...e);return a.annotation=t,a;function a(e,a,n){const i=e.hasOwnProperty(ee)?e[ee]:Object.defineProperty(e,ee,{value:[]})[ee];for(;i.length<=n;)i.push(null);return(i[n]=i[n]||[]).push(t),e}}return a&&(i.prototype=Object.create(a.prototype)),i.prototype.ngMetadataName=e,i.annotationCls=i,i})}const ae=te("Inject",e=>({token:e})),ne=te("Optional"),ie=te("Self"),re=te("SkipSelf");var se=function(e){return e[e.Default=0]="Default",e[e.Host=1]="Host",e[e.Self=2]="Self",e[e.SkipSelf=4]="SkipSelf",e[e.Optional=8]="Optional",e}({});function oe(e){for(let t in e)if(e[t]===oe)return t;throw Error("Could not find renamed property on target object.")}function le(e,t){for(const a in t)t.hasOwnProperty(a)&&!e.hasOwnProperty(a)&&(e[a]=t[a])}function ce(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function he(e){return{factory:e.factory,providers:e.providers||[],imports:e.imports||[]}}function de(e){return ue(e,me)||ue(e,fe)}function ue(e,t){return e.hasOwnProperty(t)?e[t]:null}function pe(e){return e&&(e.hasOwnProperty(ge)||e.hasOwnProperty(be))?e[ge]:null}const me=oe({"\u0275prov":oe}),ge=oe({"\u0275inj":oe}),fe=oe({ngInjectableDef:oe}),be=oe({ngInjectorDef:oe});function ye(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(ye).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return""+e.overriddenName;if(e.name)return""+e.name;const t=e.toString();if(null==t)return""+t;const a=t.indexOf("\n");return-1===a?t:t.substring(0,a)}function we(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const ve=oe({__forward_ref__:oe});function _e(e){return e.__forward_ref__=_e,e.toString=function(){return ye(this())},e}function xe(e){return"function"==typeof(t=e)&&t.hasOwnProperty(ve)&&t.__forward_ref__===_e?e():e;var t}const ke="undefined"!=typeof globalThis&&globalThis,Se="undefined"!=typeof window&&window,Te="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Ce="undefined"!=typeof global&&global,Ee=ke||Ce||Se||Te,Ae=oe({"\u0275cmp":oe}),Ie=oe({"\u0275dir":oe}),Re=oe({"\u0275pipe":oe}),Me=oe({"\u0275mod":oe}),Pe=oe({"\u0275loc":oe}),De=oe({"\u0275fac":oe}),Le=oe({__NG_ELEMENT_ID__:oe});class Ne{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=ce({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return"InjectionToken "+this._desc}}const Oe=new Ne("INJECTOR",-1),je={},We=/\n/gm,ze="__source",Be=oe({provide:String,useValue:oe});let Ge,He=void 0;function Fe(e){const t=He;return He=e,t}function qe(e){const t=Ge;return Ge=e,t}function Qe(e,t=se.Default){if(void 0===He)throw new Error("inject() must be called from an injection context");return null===He?Ve(e,void 0,t):He.get(e,t&se.Optional?null:void 0,t)}function Ye(e,t=se.Default){return(Ge||Qe)(xe(e),t)}const Ue=Ye;function Ve(e,t,a){const n=de(e);if(n&&"root"==n.providedIn)return void 0===n.value?n.value=n.factory():n.value;if(a&se.Optional)return null;if(void 0!==t)return t;throw new Error(`Injector: NOT_FOUND [${ye(e)}]`)}function Ke(e){const t=[];for(let a=0;a<e.length;a++){const n=xe(e[a]);if(Array.isArray(n)){if(0===n.length)throw new Error("Arguments array must have arguments.");let e=void 0,a=se.Default;for(let t=0;t<n.length;t++){const i=n[t];i instanceof ne||"Optional"===i.ngMetadataName||i===ne?a|=se.Optional:i instanceof re||"SkipSelf"===i.ngMetadataName||i===re?a|=se.SkipSelf:i instanceof ie||"Self"===i.ngMetadataName||i===ie?a|=se.Self:e=i instanceof ae||i===ae?i.token:i}t.push(Ye(e,a))}else t.push(Ye(n))}return t}class Xe{get(e,t=je){if(t===je){const t=new Error(`NullInjectorError: No provider for ${ye(e)}!`);throw t.name="NullInjectorError",t}return t}}class Je{}class Ze{}function $e(e,t){void 0===t&&(t=e);for(let a=0;a<e.length;a++){let n=e[a];Array.isArray(n)?(t===e&&(t=e.slice(0,a)),$e(n,t)):t!==e&&t.push(n)}return t}function et(e,t){e.forEach(e=>Array.isArray(e)?et(e,t):t(e))}function tt(e,t,a){t>=e.length?e.push(a):e.splice(t,0,a)}function at(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}function nt(e,t){const a=[];for(let n=0;n<e;n++)a.push(t);return a}function it(e,t,a){let n=st(e,t);return n>=0?e[1|n]=a:(n=~n,function(e,t,a,n){let i=e.length;if(i==t)e.push(a,n);else if(1===i)e.push(n,e[0]),e[0]=a;else{for(i--,e.push(e[i-1],e[i]);i>t;)e[i]=e[i-2],i--;e[t]=a,e[t+1]=n}}(e,n,t,a)),n}function rt(e,t){const a=st(e,t);if(a>=0)return e[1|a]}function st(e,t){return function(e,t,a){let n=0,i=e.length>>1;for(;i!==n;){const a=n+(i-n>>1),r=e[a<<1];if(t===r)return a<<1;r>t?i=a:n=a+1}return~(i<<1)}(e,t)}var ot=function(e){return e[e.OnPush=0]="OnPush",e[e.Default=1]="Default",e}({}),lt=function(e){return e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",e}({});const ct={},ht=[];let dt=0;function ut(e){return $(()=>{const t={},a={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===ot.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||ht,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||lt.Emulated,id:"c",styles:e.styles||ht,_:null,setInput:null,schemas:e.schemas||null,tView:null},n=e.directives,i=e.features,r=e.pipes;return a.id+=dt++,a.inputs=bt(e.inputs,t),a.outputs=bt(e.outputs),i&&i.forEach(e=>e(a)),a.directiveDefs=n?()=>("function"==typeof n?n():n).map(pt):null,a.pipeDefs=r?()=>("function"==typeof r?r():r).map(mt):null,a})}function pt(e){return vt(e)||function(e){return e[Ie]||null}(e)}function mt(e){return function(e){return e[Re]||null}(e)}const gt={};function ft(e){const t={type:e.type,bootstrap:e.bootstrap||ht,declarations:e.declarations||ht,imports:e.imports||ht,exports:e.exports||ht,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&$(()=>{gt[e.id]=e.type}),t}function bt(e,t){if(null==e)return ct;const a={};for(const n in e)if(e.hasOwnProperty(n)){let i=e[n],r=i;Array.isArray(i)&&(r=i[1],i=i[0]),a[i]=n,t&&(t[i]=r)}return a}const yt=ut;function wt(e){return{type:e.type,name:e.name,factory:null,pure:!1!==e.pure,onDestroy:e.type.prototype.ngOnDestroy||null}}function vt(e){return e[Ae]||null}function _t(e,t){return e.hasOwnProperty(De)?e[De]:null}function xt(e,t){const a=e[Me]||null;if(!a&&!0===t)throw new Error(`Type ${ye(e)} does not have '\u0275mod' property.`);return a}const kt=20,St=10;function Tt(e){return Array.isArray(e)&&"object"==typeof e[1]}function Ct(e){return Array.isArray(e)&&!0===e[1]}function Et(e){return 0!=(8&e.flags)}function At(e){return 2==(2&e.flags)}function It(e){return 1==(1&e.flags)}function Rt(e){return null!==e.template}function Mt(e){return 0!=(512&e[2])}class Pt extends Error{constructor(e,t){super(function(e,t){return`${e?`NG0${e}: `:""}${t}`}(e,t)),this.code=e}}function Dt(e){return"string"==typeof e?e:null==e?"":""+e}function Lt(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():Dt(e)}const Nt=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(Ee))();function Ot(e){return{name:"body",target:e.ownerDocument.body}}function jt(e){return e instanceof Function?e():e}function Wt(e,t){const a=t?" in "+t:"";throw new Pt("201",`No provider for ${Lt(e)} found${a}`)}class zt{constructor(e,t,a){this.previousValue=e,this.currentValue=t,this.firstChange=a}isFirstChange(){return this.firstChange}}function Bt(){return Gt}function Gt(e){return e.type.prototype.ngOnChanges&&(e.setInput=Ft),Ht}function Ht(){const e=qt(this),t=null==e?void 0:e.current;if(t){const a=e.previous;if(a===ct)e.previous=t;else for(let e in t)a[e]=t[e];e.current=null,this.ngOnChanges(t)}}function Ft(e,t,a,n){const i=qt(e)||function(e,t){return e.__ngSimpleChanges__=t}(e,{previous:ct,current:null}),r=i.current||(i.current={}),s=i.previous,o=this.declaredInputs[a],l=s[o];r[o]=new zt(l&&l.currentValue,t,s===ct),e[n]=t}function qt(e){return e.__ngSimpleChanges__||null}Bt.ngInherit=!0;let Qt=void 0;function Yt(e){return!!e.listen}const Ut={createRenderer:(e,t)=>void 0!==Qt?Qt:"undefined"!=typeof document?document:void 0};function Vt(e){for(;Array.isArray(e);)e=e[0];return e}function Kt(e,t){return Vt(t[e])}function Xt(e,t){return Vt(t[e.index])}function Jt(e,t){return e.data[t]}function Zt(e,t){const a=t[e];return Tt(a)?a:a[0]}function $t(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function ea(e){return 4==(4&e[2])}function ta(e){return 128==(128&e[2])}function aa(e,t){return null==t?null:e[t]}function na(e){e[18]=0}function ia(e,t){e[5]+=t;let a=e,n=e[3];for(;null!==n&&(1===t&&1===a[5]||-1===t&&0===a[5]);)n[5]+=t,a=n,n=n[3]}const ra={lFrame:Ea(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function sa(){return ra.bindingsEnabled}function oa(){return ra.lFrame.lView}function la(){return ra.lFrame.tView}function ca(){let e=ha();for(;null!==e&&64===e.type;)e=e.parent;return e}function ha(){return ra.lFrame.currentTNode}function da(e,t){const a=ra.lFrame;a.currentTNode=e,a.isParent=t}function ua(){return ra.lFrame.isParent}function pa(){ra.lFrame.isParent=!1}function ma(){return ra.isInCheckNoChangesMode}function ga(e){ra.isInCheckNoChangesMode=e}function fa(){const e=ra.lFrame;let t=e.bindingRootIndex;return-1===t&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}function ba(){return ra.lFrame.bindingIndex}function ya(){return ra.lFrame.bindingIndex++}function wa(e){const t=ra.lFrame,a=t.bindingIndex;return t.bindingIndex=t.bindingIndex+e,a}function va(e,t){const a=ra.lFrame;a.bindingIndex=a.bindingRootIndex=e,_a(t)}function _a(e){ra.lFrame.currentDirectiveIndex=e}function xa(){return ra.lFrame.currentQueryIndex}function ka(e){ra.lFrame.currentQueryIndex=e}function Sa(e,t){const a=Ca();ra.lFrame=a,a.currentTNode=t,a.lView=e}function Ta(e){const t=Ca(),a=e[1];ra.lFrame=t,t.currentTNode=a.firstChild,t.lView=e,t.tView=a,t.contextLView=e,t.bindingIndex=a.bindingStartIndex,t.inI18n=!1}function Ca(){const e=ra.lFrame,t=null===e?null:e.child;return null===t?Ea(e):t}function Ea(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function Aa(){const e=ra.lFrame;return ra.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const Ia=Aa;function Ra(){const e=Aa();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function Ma(){return ra.lFrame.selectedIndex}function Pa(e){ra.lFrame.selectedIndex=e}function Da(){const e=ra.lFrame;return Jt(e.tView,e.selectedIndex)}function La(e,t){for(let a=t.directiveStart,n=t.directiveEnd;a<n;a++){const t=e.data[a].type.prototype,{ngAfterContentInit:n,ngAfterContentChecked:i,ngAfterViewInit:r,ngAfterViewChecked:s,ngOnDestroy:o}=t;n&&(e.contentHooks||(e.contentHooks=[])).push(-a,n),i&&((e.contentHooks||(e.contentHooks=[])).push(a,i),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(a,i)),r&&(e.viewHooks||(e.viewHooks=[])).push(-a,r),s&&((e.viewHooks||(e.viewHooks=[])).push(a,s),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(a,s)),null!=o&&(e.destroyHooks||(e.destroyHooks=[])).push(a,o)}}function Na(e,t,a){Wa(e,t,3,a)}function Oa(e,t,a,n){(3&e[2])===a&&Wa(e,t,a,n)}function ja(e,t){let a=e[2];(3&a)===t&&(a&=2047,a+=1,e[2]=a)}function Wa(e,t,a,n){const i=null!=n?n:-1;let r=0;for(let s=void 0!==n?65535&e[18]:0;s<t.length;s++)if("number"==typeof t[s+1]){if(r=t[s],null!=n&&r>=n)break}else t[s]<0&&(e[18]+=65536),(r<i||-1==i)&&(za(e,a,t,s),e[18]=(4294901760&e[18])+s+2),s++}function za(e,t,a,n){const i=a[n]<0,r=a[n+1],s=e[i?-a[n]:a[n]];i?e[2]>>11<e[18]>>16&&(3&e[2])===t&&(e[2]+=2048,r.call(s)):r.call(s)}const Ba=-1;class Ga{constructor(e,t,a){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=a}}function Ha(e,t,a){const n=Yt(e);let i=0;for(;i<a.length;){const r=a[i];if("number"==typeof r){if(0!==r)break;i++;const s=a[i++],o=a[i++],l=a[i++];n?e.setAttribute(t,o,l,s):t.setAttributeNS(s,o,l)}else{const s=r,o=a[++i];qa(s)?n&&e.setProperty(t,s,o):n?e.setAttribute(t,s,o):t.setAttribute(s,o),i++}}return i}function Fa(e){return 3===e||4===e||6===e}function qa(e){return 64===e.charCodeAt(0)}function Qa(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let a=-1;for(let n=0;n<t.length;n++){const i=t[n];"number"==typeof i?a=i:0===a||Ya(e,a,i,null,-1===a||2===a?t[++n]:null)}}return e}function Ya(e,t,a,n,i){let r=0,s=e.length;if(-1===t)s=-1;else for(;r<e.length;){const a=e[r++];if("number"==typeof a){if(a===t){s=-1;break}if(a>t){s=r-1;break}}}for(;r<e.length;){const t=e[r];if("number"==typeof t)break;if(t===a){if(null===n)return void(null!==i&&(e[r+1]=i));if(n===e[r+1])return void(e[r+2]=i)}r++,null!==n&&r++,null!==i&&r++}-1!==s&&(e.splice(s,0,t),r=s+1),e.splice(r++,0,a),null!==n&&e.splice(r++,0,n),null!==i&&e.splice(r++,0,i)}function Ua(e){return e!==Ba}function Va(e){return 32767&e}function Ka(e,t){let a=e>>16,n=t;for(;a>0;)n=n[15],a--;return n}let Xa=!0;function Ja(e){const t=Xa;return Xa=e,t}let Za=0;function $a(e,t){const a=tn(e,t);if(-1!==a)return a;const n=t[1];n.firstCreatePass&&(e.injectorIndex=t.length,en(n.data,e),en(t,null),en(n.blueprint,null));const i=an(e,t),r=e.injectorIndex;if(Ua(i)){const e=Va(i),a=Ka(i,t),n=a[1].data;for(let i=0;i<8;i++)t[r+i]=a[e+i]|n[e+i]}return t[r+8]=i,r}function en(e,t){e.push(0,0,0,0,0,0,0,0,t)}function tn(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function an(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let a=0,n=null,i=t;for(;null!==i;){const e=i[1],t=e.type;if(n=2===t?e.declTNode:1===t?i[6]:null,null===n)return Ba;if(a++,i=i[15],-1!==n.injectorIndex)return n.injectorIndex|a<<16}return Ba}function nn(e,t,a){!function(e,t,a){let n;"string"==typeof a?n=a.charCodeAt(0)||0:a.hasOwnProperty(Le)&&(n=a[Le]),null==n&&(n=a[Le]=Za++);const i=255&n,r=1<<i,s=64&i,o=32&i,l=t.data;128&i?s?o?l[e+7]|=r:l[e+6]|=r:o?l[e+5]|=r:l[e+4]|=r:s?o?l[e+3]|=r:l[e+2]|=r:o?l[e+1]|=r:l[e]|=r}(e,t,a)}function rn(e,t,a,n=se.Default,i){if(null!==e){const i=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(Le)?e[Le]:void 0;return"number"==typeof t&&t>0?255&t:t}(a);if("function"==typeof i){Sa(t,e);try{const e=i();if(null!=e||n&se.Optional)return e;Wt(a)}finally{Ia()}}else if("number"==typeof i){if(-1===i)return new un(e,t);let r=null,s=tn(e,t),o=Ba,l=n&se.Host?t[16][6]:null;for((-1===s||n&se.SkipSelf)&&(o=-1===s?an(e,t):t[s+8],o!==Ba&&dn(n,!1)?(r=t[1],s=Va(o),t=Ka(o,t)):s=-1);-1!==s;){const e=t[1];if(hn(i,s,e.data)){const e=on(s,t,a,r,n,l);if(e!==sn)return e}o=t[s+8],o!==Ba&&dn(n,t[1].data[s+8]===l)&&hn(i,s,t)?(r=e,s=Va(o),t=Ka(o,t)):s=-1}}}if(n&se.Optional&&void 0===i&&(i=null),0==(n&(se.Self|se.Host))){const e=t[9],r=qe(void 0);try{return e?e.get(a,i,n&se.Optional):Ve(a,i,n&se.Optional)}finally{qe(r)}}if(n&se.Optional)return i;Wt(a,"NodeInjector")}const sn={};function on(e,t,a,n,i,r){const s=t[1],o=s.data[e+8],l=ln(o,s,a,null==n?At(o)&&Xa:n!=s&&0!=(3&o.type),i&se.Host&&r===o);return null!==l?cn(t,s,l,o):sn}function ln(e,t,a,n,i){const r=e.providerIndexes,s=t.data,o=1048575&r,l=e.directiveStart,c=r>>20,h=i?o+c:e.directiveEnd;for(let d=n?o:o+c;d<h;d++){const e=s[d];if(d<l&&a===e||d>=l&&e.type===a)return d}if(i){const e=s[l];if(e&&Rt(e)&&e.type===a)return l}return null}function cn(e,t,a,n){let i=e[a];const r=t.data;if(i instanceof Ga){const s=i;s.resolving&&function(e,t){throw new Pt("200","Circular dependency in DI detected for "+e)}(Lt(r[a]));const o=Ja(s.canSeeViewProviders);s.resolving=!0;const l=s.injectImpl?qe(s.injectImpl):null;Sa(e,n);try{i=e[a]=s.factory(void 0,r,e,n),t.firstCreatePass&&a>=n.directiveStart&&function(e,t,a){const{ngOnChanges:n,ngOnInit:i,ngDoCheck:r}=t.type.prototype;if(n){const n=Gt(t);(a.preOrderHooks||(a.preOrderHooks=[])).push(e,n),(a.preOrderCheckHooks||(a.preOrderCheckHooks=[])).push(e,n)}i&&(a.preOrderHooks||(a.preOrderHooks=[])).push(0-e,i),r&&((a.preOrderHooks||(a.preOrderHooks=[])).push(e,r),(a.preOrderCheckHooks||(a.preOrderCheckHooks=[])).push(e,r))}(a,r[a],t)}finally{null!==l&&qe(l),Ja(o),s.resolving=!1,Ia()}}return i}function hn(e,t,a){const n=64&e,i=32&e;let r;return r=128&e?n?i?a[t+7]:a[t+6]:i?a[t+5]:a[t+4]:n?i?a[t+3]:a[t+2]:i?a[t+1]:a[t],!!(r&1<<e)}function dn(e,t){return!(e&se.Self||e&se.Host&&t)}class un{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return rn(this._tNode,this._lView,e,void 0,t)}}function pn(e){return e.ngDebugContext}function mn(e){return e.ngOriginalError}function gn(e,...t){e.error(...t)}class fn{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),a=this._findContext(e),n=function(e){return e.ngErrorLogger||gn}(e);n(this._console,"ERROR",e),t&&n(this._console,"ORIGINAL ERROR",t),a&&n(this._console,"ERROR CONTEXT",a)}_findContext(e){return e?pn(e)?pn(e):this._findContext(mn(e)):null}_findOriginalError(e){let t=mn(e);for(;t&&mn(t);)t=mn(t);return t}}class bn{constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return"SafeValue must use [property]=binding: "+this.changingThisBreaksApplicationSecurity+" (see http://g.co/ng/security#xss)"}}function yn(e){return e instanceof bn?e.changingThisBreaksApplicationSecurity:e}let wn=!0,vn=!1;function _n(){return vn=!0,wn}const xn=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,kn=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;var Sn=function(e){return e[e.NONE=0]="NONE",e[e.HTML=1]="HTML",e[e.STYLE=2]="STYLE",e[e.SCRIPT=3]="SCRIPT",e[e.URL=4]="URL",e[e.RESOURCE_URL=5]="RESOURCE_URL",e}({});function Tn(e){const t=function(){const e=oa();return e&&e[12]}();return t?t.sanitize(Sn.URL,e)||"":function(e,t){const a=function(e){return e instanceof bn&&e.getTypeName()||null}(e);if(null!=a&&a!==t){if("ResourceURL"===a&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${a} (see http://g.co/ng/security#xss)`)}return a===t}(e,"URL")?yn(e):(a=Dt(e),(a=String(a)).match(xn)||a.match(kn)?a:(_n()&&console.warn(`WARNING: sanitizing unsafe URL value ${a} (see http://g.co/ng/security#xss)`),"unsafe:"+a));var a}function Cn(e,t){e.__ngContext__=t}function En(e,t){return(void 0)(e,t)}function An(e){const t=e[3];return Ct(t)?t[3]:t}function In(e){return Mn(e[13])}function Rn(e){return Mn(e[4])}function Mn(e){for(;null!==e&&!Ct(e);)e=e[4];return e}function Pn(e,t,a,n,i){if(null!=n){let r,s=!1;Ct(n)?r=n:Tt(n)&&(s=!0,n=n[0]);const o=Vt(n);0===e&&null!==a?null==i?Bn(t,a,o):zn(t,a,o,i||null,!0):1===e&&null!==a?zn(t,a,o,i||null,!0):2===e?function(e,t,a){const n=Hn(e,t);n&&function(e,t,a,n){Yt(e)?e.removeChild(t,a,n):t.removeChild(a)}(e,n,t,a)}(t,o,s):3===e&&t.destroyNode(o),null!=r&&function(e,t,a,n,i){const r=a[7];r!==Vt(a)&&Pn(t,e,n,r,i);for(let s=St;s<a.length;s++){const i=a[s];Kn(i[1],i,e,t,n,r)}}(t,e,r,a,i)}}function Dn(e,t,a){return Yt(e)?e.createElement(t,a):null===a?e.createElement(t):e.createElementNS(a,t)}function Ln(e,t){const a=e[9],n=a.indexOf(t),i=t[3];1024&t[2]&&(t[2]&=-1025,ia(i,-1)),a.splice(n,1)}function Nn(e,t){if(e.length<=St)return;const a=St+t,n=e[a];if(n){const r=n[17];null!==r&&r!==e&&Ln(r,n),t>0&&(e[a-1][4]=n[4]);const s=at(e,St+t);Kn(n[1],i=n,i[11],2,null,null),i[0]=null,i[6]=null;const o=s[19];null!==o&&o.detachView(s[1]),n[3]=null,n[4]=null,n[2]&=-129}var i;return n}function On(e,t){if(!(256&t[2])){const a=t[11];Yt(a)&&a.destroyNode&&Kn(e,t,a,3,null,null),function(e){let t=e[13];if(!t)return jn(e[1],e);for(;t;){let a=null;if(Tt(t))a=t[13];else{const e=t[10];e&&(a=e)}if(!a){for(;t&&!t[4]&&t!==e;)Tt(t)&&jn(t[1],t),t=t[3];null===t&&(t=e),Tt(t)&&jn(t[1],t),a=t&&t[4]}t=a}}(t)}}function jn(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let a;if(null!=e&&null!=(a=e.destroyHooks))for(let n=0;n<a.length;n+=2){const e=t[a[n]];if(!(e instanceof Ga)){const t=a[n+1];if(Array.isArray(t))for(let a=0;a<t.length;a+=2)t[a+1].call(e[t[a]]);else t.call(e)}}}(e,t),function(e,t){const a=e.cleanup;if(null!==a){const e=t[7];for(let n=0;n<a.length-1;n+=2)if("string"==typeof a[n]){const i=a[n+1],r="function"==typeof i?i(t):Vt(t[i]),s=e[a[n+2]],o=a[n+3];"boolean"==typeof o?r.removeEventListener(a[n],s,o):o>=0?e[o]():e[-o].unsubscribe(),n+=2}else a[n].call(e[a[n+1]]);t[7]=null}}(e,t),1===t[1].type&&Yt(t[11])&&t[11].destroy();const a=t[17];if(null!==a&&Ct(t[3])){a!==t[3]&&Ln(a,t);const n=t[19];null!==n&&n.detachView(e)}}}function Wn(e,t,a){return function(e,t,a){let n=t;for(;null!==n&&40&n.type;)n=(t=n).parent;if(null===n)return a[0];if(2&n.flags){const t=e.data,a=t[t[n.index].directiveStart].encapsulation;if(a===lt.None||a===lt.Emulated)return null}return Xt(n,a)}(e,t.parent,a)}function zn(e,t,a,n,i){Yt(e)?e.insertBefore(t,a,n,i):t.insertBefore(a,n,i)}function Bn(e,t,a){Yt(e)?e.appendChild(t,a):t.appendChild(a)}function Gn(e,t,a,n,i){null!==n?zn(e,t,a,n,i):Bn(e,t,a)}function Hn(e,t){return Yt(e)?e.parentNode(t):t.parentNode}function Fn(e,t,a){return qn(e,t,a)}let qn=function(e,t,a){return 40&e.type?Xt(e,a):null};function Qn(e,t,a,n){const i=Wn(e,n,t),r=t[11],s=Fn(n.parent||t[6],n,t);if(null!=i)if(Array.isArray(a))for(let o=0;o<a.length;o++)Gn(r,i,a[o],s,!1);else Gn(r,i,a,s,!1)}function Yn(e,t){if(null!==t){const a=t.type;if(3&a)return Xt(t,e);if(4&a)return Un(-1,e[t.index]);if(8&a){const a=t.child;if(null!==a)return Yn(e,a);{const a=e[t.index];return Ct(a)?Un(-1,a):Vt(a)}}if(32&a)return En(t,e)()||Vt(e[t.index]);{const a=e[16],n=a[6],i=An(a),r=n.projection[t.projection];return null!=r?Yn(i,r):Yn(e,t.next)}}return null}function Un(e,t){const a=St+e+1;if(a<t.length){const e=t[a],n=e[1].firstChild;if(null!==n)return Yn(e,n)}return t[7]}function Vn(e,t,a,n,i,r,s){for(;null!=a;){const o=n[a.index],l=a.type;if(s&&0===t&&(o&&Cn(Vt(o),n),a.flags|=4),64!=(64&a.flags))if(8&l)Vn(e,t,a.child,n,i,r,!1),Pn(t,e,i,o,r);else if(32&l){const s=En(a,n);let l;for(;l=s();)Pn(t,e,i,l,r);Pn(t,e,i,o,r)}else 16&l?Xn(e,t,n,a,i,r):Pn(t,e,i,o,r);a=s?a.projectionNext:a.next}}function Kn(e,t,a,n,i,r){Vn(a,n,e.firstChild,t,i,r,!1)}function Xn(e,t,a,n,i,r){const s=a[16],o=s[6].projection[n.projection];if(Array.isArray(o))for(let l=0;l<o.length;l++)Pn(t,e,i,o[l],r);else Vn(e,t,o,s[3],i,r,!0)}function Jn(e,t,a){Yt(e)?e.setAttribute(t,"style",a):t.style.cssText=a}function Zn(e,t,a){Yt(e)?""===a?e.removeAttribute(t,"class"):e.setAttribute(t,"class",a):t.className=a}function $n(e,t,a){let n=e.length;for(;;){const i=e.indexOf(t,a);if(-1===i)return i;if(0===i||e.charCodeAt(i-1)<=32){const a=t.length;if(i+a===n||e.charCodeAt(i+a)<=32)return i}a=i+1}}const ei="ng-template";function ti(e,t,a){let n=0;for(;n<e.length;){let i=e[n++];if(a&&"class"===i){if(i=e[n],-1!==$n(i.toLowerCase(),t,0))return!0}else if(1===i){for(;n<e.length&&"string"==typeof(i=e[n++]);)if(i.toLowerCase()===t)return!0;return!1}}return!1}function ai(e){return 4===e.type&&e.value!==ei}function ni(e,t,a){return t===(4!==e.type||a?e.value:ei)}function ii(e,t,a){let n=4;const i=e.attrs||[],r=function(e){for(let t=0;t<e.length;t++)if(Fa(e[t]))return t;return e.length}(i);let s=!1;for(let o=0;o<t.length;o++){const l=t[o];if("number"!=typeof l){if(!s)if(4&n){if(n=2|1&n,""!==l&&!ni(e,l,a)||""===l&&1===t.length){if(ri(n))return!1;s=!0}}else{const c=8&n?l:t[++o];if(8&n&&null!==e.attrs){if(!ti(e.attrs,c,a)){if(ri(n))return!1;s=!0}continue}const h=si(8&n?"class":l,i,ai(e),a);if(-1===h){if(ri(n))return!1;s=!0;continue}if(""!==c){let e;e=h>r?"":i[h+1].toLowerCase();const t=8&n?e:null;if(t&&-1!==$n(t,c,0)||2&n&&c!==e){if(ri(n))return!1;s=!0}}}}else{if(!s&&!ri(n)&&!ri(l))return!1;if(s&&ri(l))continue;s=!1,n=l|1&n}}return ri(n)||s}function ri(e){return 0==(1&e)}function si(e,t,a,n){if(null===t)return-1;let i=0;if(n||!a){let a=!1;for(;i<t.length;){const n=t[i];if(n===e)return i;if(3===n||6===n)a=!0;else{if(1===n||2===n){let e=t[++i];for(;"string"==typeof e;)e=t[++i];continue}if(4===n)break;if(0===n){i+=4;continue}}i+=a?1:2}return-1}return function(e,t){let a=e.indexOf(4);if(a>-1)for(a++;a<e.length;){const n=e[a];if("number"==typeof n)return-1;if(n===t)return a;a++}return-1}(t,e)}function oi(e,t,a=!1){for(let n=0;n<t.length;n++)if(ii(e,t[n],a))return!0;return!1}function li(e,t){e:for(let a=0;a<t.length;a++){const n=t[a];if(e.length===n.length){for(let t=0;t<e.length;t++)if(e[t]!==n[t])continue e;return!0}}return!1}function ci(e,t){return e?":not("+t.trim()+")":t}function hi(e){let t=e[0],a=1,n=2,i="",r=!1;for(;a<e.length;){let s=e[a];if("string"==typeof s)if(2&n){const t=e[++a];i+="["+s+(t.length>0?'="'+t+'"':"")+"]"}else 8&n?i+="."+s:4&n&&(i+=" "+s);else""===i||ri(s)||(t+=ci(r,i),i=""),n=s,r=r||!ri(n);a++}return""!==i&&(t+=ci(r,i)),t}const di={};function ui(e){pi(la(),oa(),Ma()+e,ma())}function pi(e,t,a,n){if(!n)if(3==(3&t[2])){const n=e.preOrderCheckHooks;null!==n&&Na(t,n,a)}else{const n=e.preOrderHooks;null!==n&&Oa(t,n,0,a)}Pa(a)}function mi(e,t){return e<<17|t<<2}function gi(e){return e>>17&32767}function fi(e){return 2|e}function bi(e){return(131068&e)>>2}function yi(e,t){return-131069&e|t<<2}function wi(e){return 1|e}function vi(e,t){const a=e.contentQueries;if(null!==a)for(let n=0;n<a.length;n+=2){const i=a[n],r=a[n+1];if(-1!==r){const a=e.data[r];ka(i),a.contentQueries(2,t[r],r)}}}function _i(e,t,a,n,i,r,s,o,l,c){const h=t.blueprint.slice();return h[0]=i,h[2]=140|n,na(h),h[3]=h[15]=e,h[8]=a,h[10]=s||e&&e[10],h[11]=o||e&&e[11],h[12]=l||e&&e[12]||null,h[9]=c||e&&e[9]||null,h[6]=r,h[16]=2==t.type?e[16]:h,h}function xi(e,t,a,n,i){let r=e.data[t];if(null===r)r=function(e,t,a,n,i){const r=ha(),s=ua(),o=e.data[t]=Li(0,s?r:r&&r.parent,a,t,n,i);return null===e.firstChild&&(e.firstChild=o),null!==r&&(s?null==r.child&&null!==o.parent&&(r.child=o):null===r.next&&(r.next=o)),o}(e,t,a,n,i),ra.lFrame.inI18n&&(r.flags|=64);else if(64&r.type){r.type=a,r.value=n,r.attrs=i;const e=function(){const e=ra.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();r.injectorIndex=null===e?-1:e.injectorIndex}return da(r,!0),r}function ki(e,t,a,n){if(0===a)return-1;const i=t.length;for(let r=0;r<a;r++)t.push(n),e.blueprint.push(n),e.data.push(null);return i}function Si(e,t,a){Ta(t);try{const n=e.viewQuery;null!==n&&tr(1,n,a);const i=e.template;null!==i&&Ei(e,t,i,1,a),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&vi(e,t),e.staticViewQueries&&tr(2,e.viewQuery,a);const r=e.components;null!==r&&function(e,t){for(let a=0;a<t.length;a++)Xi(e,t[a])}(t,r)}catch(n){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),n}finally{t[2]&=-5,Ra()}}function Ti(e,t,a,n){const i=t[2];if(256==(256&i))return;Ta(t);const r=ma();try{na(t),ra.lFrame.bindingIndex=e.bindingStartIndex,null!==a&&Ei(e,t,a,2,n);const s=3==(3&i);if(!r)if(s){const a=e.preOrderCheckHooks;null!==a&&Na(t,a,null)}else{const a=e.preOrderHooks;null!==a&&Oa(t,a,0,null),ja(t,0)}if(function(e){for(let t=In(e);null!==t;t=Rn(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const a=e[t],n=a[3];0==(1024&a[2])&&ia(n,1),a[2]|=1024}}}(t),function(e){for(let t=In(e);null!==t;t=Rn(t))for(let e=St;e<t.length;e++){const a=t[e],n=a[1];ta(a)&&Ti(n,a,n.template,a[8])}}(t),null!==e.contentQueries&&vi(e,t),!r)if(s){const a=e.contentCheckHooks;null!==a&&Na(t,a)}else{const a=e.contentHooks;null!==a&&Oa(t,a,1),ja(t,1)}!function(e,t){const a=e.hostBindingOpCodes;if(null!==a)try{for(let e=0;e<a.length;e++){const n=a[e];if(n<0)Pa(~n);else{const i=n,r=a[++e],s=a[++e];va(r,i),s(2,t[i])}}}finally{Pa(-1)}}(e,t);const o=e.components;null!==o&&function(e,t){for(let a=0;a<t.length;a++)Vi(e,t[a])}(t,o);const l=e.viewQuery;if(null!==l&&tr(2,l,n),!r)if(s){const a=e.viewCheckHooks;null!==a&&Na(t,a)}else{const a=e.viewHooks;null!==a&&Oa(t,a,2),ja(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),r||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,ia(t[3],-1))}finally{Ra()}}function Ci(e,t,a,n){const i=t[10],r=!ma(),s=ea(t);try{r&&!s&&i.begin&&i.begin(),s&&Si(e,t,n),Ti(e,t,a,n)}finally{r&&!s&&i.end&&i.end()}}function Ei(e,t,a,n,i){const r=Ma();try{Pa(-1),2&n&&t.length>kt&&pi(e,t,kt,ma()),a(n,i)}finally{Pa(r)}}function Ai(e,t,a){if(Et(t)){const n=t.directiveEnd;for(let i=t.directiveStart;i<n;i++){const t=e.data[i];t.contentQueries&&t.contentQueries(1,a[i],i)}}}function Ii(e,t,a){sa()&&(function(e,t,a,n){const i=a.directiveStart,r=a.directiveEnd;e.firstCreatePass||$a(a,t),Cn(n,t);const s=a.initialInputs;for(let o=i;o<r;o++){const n=e.data[o],r=Rt(n);r&&qi(t,a,n);const l=cn(t,e,o,a);Cn(l,t),null!==s&&Qi(0,o-i,l,n,0,s),r&&(Zt(a.index,t)[8]=l)}}(e,t,a,Xt(a,t)),128==(128&a.flags)&&function(e,t,a){const n=a.directiveStart,i=a.directiveEnd,r=a.index,s=ra.lFrame.currentDirectiveIndex;try{Pa(r);for(let a=n;a<i;a++){const n=e.data[a],i=t[a];_a(a),null===n.hostBindings&&0===n.hostVars&&null===n.hostAttrs||zi(n,i)}}finally{Pa(-1),_a(s)}}(e,t,a))}function Ri(e,t,a=Xt){const n=t.localNames;if(null!==n){let i=t.index+1;for(let r=0;r<n.length;r+=2){const s=n[r+1],o=-1===s?a(t,e):e[s];e[i++]=o}}}function Mi(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=Pi(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function Pi(e,t,a,n,i,r,s,o,l,c){const h=kt+n,d=h+i,u=function(e,t){const a=[];for(let n=0;n<t;n++)a.push(n<e?null:di);return a}(h,d),p="function"==typeof c?c():c;return u[1]={type:e,blueprint:u,template:a,queries:null,viewQuery:o,declTNode:t,data:u.slice().fill(null,h),bindingStartIndex:h,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof r?r():r,pipeRegistry:"function"==typeof s?s():s,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1}}function Di(e,t,a,n){const i=nr(t);i.push(a),e.firstCreatePass&&function(e){return e.cleanup||(e.cleanup=[])}(e).push(n,i.length-1)}function Li(e,t,a,n,i,r){return{type:a,index:n,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:i,attrs:r,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function Ni(e,t,a){for(let n in e)if(e.hasOwnProperty(n)){const i=e[n];(a=null===a?{}:a).hasOwnProperty(n)?a[n].push(t,i):a[n]=[t,i]}return a}function Oi(e,t,a,n,i,r,s,o){const l=Xt(t,a);let c,h=t.inputs;var d;!o&&null!=h&&(c=h[n])?(rr(e,a,c,n,i),At(t)&&function(e,t){const a=Zt(t,e);16&a[2]||(a[2]|=64)}(a,t.index)):3&t.type&&(n="class"===(d=n)?"className":"for"===d?"htmlFor":"formaction"===d?"formAction":"innerHtml"===d?"innerHTML":"readonly"===d?"readOnly":"tabindex"===d?"tabIndex":d,i=null!=s?s(i,t.value||"",n):i,Yt(r)?r.setProperty(l,n,i):qa(n)||(l.setProperty?l.setProperty(n,i):l[n]=i))}function ji(e,t,a,n){let i=!1;if(sa()){const r=function(e,t,a){const n=e.directiveRegistry;let i=null;if(n)for(let r=0;r<n.length;r++){const s=n[r];oi(a,s.selectors,!1)&&(i||(i=[]),nn($a(a,t),e,s.type),Rt(s)?(Bi(e,a),i.unshift(s)):i.push(s))}return i}(e,t,a),s=null===n?null:{"":-1};if(null!==r){i=!0,Hi(a,e.data.length,r.length);for(let e=0;e<r.length;e++){const t=r[e];t.providersResolver&&t.providersResolver(t)}let n=!1,o=!1,l=ki(e,t,r.length,null);for(let i=0;i<r.length;i++){const c=r[i];a.mergedAttrs=Qa(a.mergedAttrs,c.hostAttrs),Fi(e,a,t,l,c),Gi(l,c,s),null!==c.contentQueries&&(a.flags|=8),null===c.hostBindings&&null===c.hostAttrs&&0===c.hostVars||(a.flags|=128);const h=c.type.prototype;!n&&(h.ngOnChanges||h.ngOnInit||h.ngDoCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(a.index),n=!0),o||!h.ngOnChanges&&!h.ngDoCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(a.index),o=!0),l++}!function(e,t){const a=t.directiveEnd,n=e.data,i=t.attrs,r=[];let s=null,o=null;for(let l=t.directiveStart;l<a;l++){const e=n[l],a=e.inputs,c=null===i||ai(t)?null:Yi(a,i);r.push(c),s=Ni(a,l,s),o=Ni(e.outputs,l,o)}null!==s&&(s.hasOwnProperty("class")&&(t.flags|=16),s.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=r,t.inputs=s,t.outputs=o}(e,a)}s&&function(e,t,a){if(t){const n=e.localNames=[];for(let e=0;e<t.length;e+=2){const i=a[t[e+1]];if(null==i)throw new Pt("301",`Export of name '${t[e+1]}' not found!`);n.push(t[e],i)}}}(a,n,s)}return a.mergedAttrs=Qa(a.mergedAttrs,a.attrs),i}function Wi(e,t,a,n,i,r){const s=r.hostBindings;if(s){let a=e.hostBindingOpCodes;null===a&&(a=e.hostBindingOpCodes=[]);const r=~t.index;(function(e){let t=e.length;for(;t>0;){const a=e[--t];if("number"==typeof a&&a<0)return a}return 0})(a)!=r&&a.push(r),a.push(n,i,s)}}function zi(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function Bi(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function Gi(e,t,a){if(a){if(t.exportAs)for(let n=0;n<t.exportAs.length;n++)a[t.exportAs[n]]=e;Rt(t)&&(a[""]=e)}}function Hi(e,t,a){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+a,e.providerIndexes=t}function Fi(e,t,a,n,i){e.data[n]=i;const r=i.factory||(i.factory=_t(i.type)),s=new Ga(r,Rt(i),null);e.blueprint[n]=s,a[n]=s,Wi(e,t,0,n,ki(e,a,i.hostVars,di),i)}function qi(e,t,a){const n=Xt(t,e),i=Mi(a),r=e[10],s=Ji(e,_i(e,i,null,a.onPush?64:16,n,t,r,r.createRenderer(n,a),null,null));e[t.index]=s}function Qi(e,t,a,n,i,r){const s=r[t];if(null!==s){const e=n.setInput;for(let t=0;t<s.length;){const i=s[t++],r=s[t++],o=s[t++];null!==e?n.setInput(a,o,i,r):a[r]=o}}}function Yi(e,t){let a=null,n=0;for(;n<t.length;){const i=t[n];if(0!==i)if(5!==i){if("number"==typeof i)break;e.hasOwnProperty(i)&&(null===a&&(a=[]),a.push(i,e[i],t[n+1])),n+=2}else n+=2;else n+=4}return a}function Ui(e,t,a,n){return new Array(e,!0,!1,t,null,0,n,a,null,null)}function Vi(e,t){const a=Zt(t,e);if(ta(a)){const e=a[1];80&a[2]?Ti(e,a,e.template,a[8]):a[5]>0&&Ki(a)}}function Ki(e){for(let a=In(e);null!==a;a=Rn(a))for(let e=St;e<a.length;e++){const t=a[e];if(1024&t[2]){const e=t[1];Ti(e,t,e.template,t[8])}else t[5]>0&&Ki(t)}const t=e[1].components;if(null!==t)for(let a=0;a<t.length;a++){const n=Zt(t[a],e);ta(n)&&n[5]>0&&Ki(n)}}function Xi(e,t){const a=Zt(t,e),n=a[1];!function(e,t){for(let a=t.length;a<e.blueprint.length;a++)t.push(e.blueprint[a])}(n,a),Si(n,a,a[8])}function Ji(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function Zi(e){for(;e;){e[2]|=64;const t=An(e);if(Mt(e)&&!t)return e;e=t}return null}function $i(e,t,a){const n=t[10];n.begin&&n.begin();try{Ti(e,t,e.template,a)}catch(i){throw ir(t,i),i}finally{n.end&&n.end()}}function er(e){!function(e){for(let t=0;t<e.components.length;t++){const a=e.components[t],n=$t(a),i=n[1];Ci(i,n,i.template,a)}}(e[8])}function tr(e,t,a){ka(0),t(e,a)}const ar=(()=>Promise.resolve(null))();function nr(e){return e[7]||(e[7]=[])}function ir(e,t){const a=e[9],n=a?a.get(fn,null):null;n&&n.handleError(t)}function rr(e,t,a,n,i){for(let r=0;r<a.length;){const s=a[r++],o=a[r++],l=t[s],c=e.data[s];null!==c.setInput?c.setInput(l,i,n,o):l[o]=i}}function sr(e,t,a){const n=Kt(t,e);!function(e,t,a){Yt(e)?e.setValue(t,a):t.textContent=a}(e[11],n,a)}class or{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._viewContainerRef=null}get rootNodes(){const e=this._lView,t=e[1];return cr(t,e,t.firstChild,[])}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._viewContainerRef){const e=this._viewContainerRef.indexOf(this);e>-1&&this._viewContainerRef.detach(e),this._viewContainerRef=null}On(this._lView[1],this._lView)}onDestroy(e){Di(this._lView[1],this._lView,null,e)}markForCheck(){Zi(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){$i(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,a){ga(!0);try{$i(e,t,a)}finally{ga(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(e){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._viewContainerRef=e}detachFromAppRef(){var e;this._appRef=null,Kn(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._viewContainerRef)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class lr extends or{constructor(e){super(e),this._view=e}detectChanges(){er(this._view)}checkNoChanges(){!function(e){ga(!0);try{er(e)}finally{ga(!1)}}(this._view)}get context(){return null}}function cr(e,t,a,n,i=!1){for(;null!==a;){const r=t[a.index];if(null!==r&&n.push(Vt(r)),Ct(r))for(let e=St;e<r.length;e++){const t=r[e],a=t[1].firstChild;null!==a&&cr(t[1],t,a,n)}const s=a.type;if(8&s)cr(e,t,a.child,n);else if(32&s){const e=En(a,t);let i;for(;i=e();)n.push(i)}else if(16&s){const e=t[16],i=e[6].projection[a.projection];if(Array.isArray(i))n.push(...i);else{const t=An(e);cr(t[1],t,i,n,!0)}}a=i?a.projectionNext:a.next}return n}let hr,dr,ur;function pr(e,t,a){return hr||(hr=class extends e{}),new hr(Xt(t,a))}function mr(e,t,a,n){return dr||(dr=class extends e{constructor(e,t,a){super(),this._declarationView=e,this._declarationTContainer=t,this.elementRef=a}createEmbeddedView(e){const t=this._declarationTContainer.tViews,a=_i(this._declarationView,t,e,16,null,t.declTNode,null,null,null,null);a[17]=this._declarationView[this._declarationTContainer.index];const n=this._declarationView[19];return null!==n&&(a[19]=n.createEmbeddedView(t)),Si(t,a,e),new or(a)}}),4&a.type?new dr(n,a,pr(t,a,n)):null}function gr(e,t,a,n){let i;ur||(ur=class extends e{constructor(e,t,a){super(),this._lContainer=e,this._hostTNode=t,this._hostView=a}get element(){return pr(t,this._hostTNode,this._hostView)}get injector(){return new un(this._hostTNode,this._hostView)}get parentInjector(){const e=an(this._hostTNode,this._hostView);if(Ua(e)){const t=Ka(e,this._hostView),a=Va(e);return new un(t[1].data[a+8],t)}return new un(null,this._hostView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){return null!==this._lContainer[8]&&this._lContainer[8][e]||null}get length(){return this._lContainer.length-St}createEmbeddedView(e,t,a){const n=e.createEmbeddedView(t||{});return this.insert(n,a),n}createComponent(e,t,a,n,i){const r=a||this.parentInjector;if(!i&&null==e.ngModule&&r){const e=r.get(Je,null);e&&(i=e)}const s=e.create(r,n,void 0,i);return this.insert(s.hostView,t),s}insert(e,t){const a=e._lView,n=a[1];if(e.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(this.allocateContainerIfNeeded(),Ct(a[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=a[3],n=new ur(t,t[6],t[3]);n.detach(n.indexOf(e))}}const i=this._adjustIndex(t),r=this._lContainer;!function(e,t,a,n){const i=St+n,r=a.length;n>0&&(a[i-1][4]=t),n<r-St?(t[4]=a[i],tt(a,St+n,t)):(a.push(t),t[4]=null),t[3]=a;const s=t[17];null!==s&&a!==s&&function(e,t){const a=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===a?e[9]=[t]:a.push(t)}(s,t);const o=t[19];null!==o&&o.insertView(e),t[2]|=128}(n,a,r,i);const s=Un(i,r),o=a[11],l=Hn(o,r[7]);return null!==l&&function(e,t,a,n,i,r){n[0]=i,n[6]=t,Kn(e,n,a,1,i,r)}(n,r[6],o,a,l,s),e.attachToViewContainerRef(this),tt(r[8],i,e),e}move(e,t){if(e.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(e,t)}indexOf(e){const t=this._lContainer[8];return null!==t?t.indexOf(e):-1}remove(e){this.allocateContainerIfNeeded();const t=this._adjustIndex(e,-1),a=Nn(this._lContainer,t);a&&(at(this._lContainer[8],t),On(a[1],a))}detach(e){this.allocateContainerIfNeeded();const t=this._adjustIndex(e,-1),a=Nn(this._lContainer,t);return a&&null!=at(this._lContainer[8],t)?new or(a):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}allocateContainerIfNeeded(){null===this._lContainer[8]&&(this._lContainer[8]=[])}});const r=n[a.index];if(Ct(r))i=r;else{let e;if(8&a.type)e=Vt(r);else if(e=n[11].createComment(""),Mt(n)){const t=n[11],i=Xt(a,n);zn(t,Hn(t,i),e,function(e,t){return Yt(e)?e.nextSibling(t):t.nextSibling}(t,i),!1)}else{const t=Li(0,a.parent,4,0,null,null);Qn(n[1],n,e,t)}n[a.index]=i=Ui(r,n,e,a),Ji(n,i)}return new ur(i,a,n)}function fr(e=!1){return function(e,t,a){if(!a&&At(e)){const a=Zt(e.index,t);return new or(a,a)}return 47&e.type?new or(t[16],t):null}(ca(),oa(),e)}let br=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>yr(),e})();const yr=fr,wr=Function,vr=new Ne("Set Injector scope."),_r={},xr={},kr=[];let Sr=void 0;function Tr(){return void 0===Sr&&(Sr=new Xe),Sr}function Cr(e,t=null,a=null,n){return new Er(e,a,t||Tr(),n)}class Er{constructor(e,t,a,n=null){this.parent=a,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const i=[];t&&et(t,a=>this.processProvider(a,e,t)),et([e],e=>this.processInjectorType(e,[],i)),this.records.set(Oe,Ir(void 0,this));const r=this.records.get(vr);this.scope=null!=r?r.value:null,this.source=n||("object"==typeof e?null:ye(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=je,a=se.Default){this.assertNotDestroyed();const n=Fe(this);try{if(!(a&se.SkipSelf)){let t=this.records.get(e);if(void 0===t){const a=("function"==typeof(i=e)||"object"==typeof i&&i instanceof Ne)&&de(e);t=a&&this.injectableDefInScope(a)?Ir(Ar(e),_r):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(a&se.Self?Tr():this.parent).get(e,t=a&se.Optional&&t===je?null:t)}catch(r){if("NullInjectorError"===r.name){if((r.ngTempTokenPath=r.ngTempTokenPath||[]).unshift(ye(e)),n)throw r;return function(e,t,a,n){const i=e.ngTempTokenPath;throw t[ze]&&i.unshift(t[ze]),e.message=function(e,t,a,n=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let i=ye(t);if(Array.isArray(t))i=t.map(ye).join(" -> ");else if("object"==typeof t){let e=[];for(let a in t)if(t.hasOwnProperty(a)){let n=t[a];e.push(a+":"+("string"==typeof n?JSON.stringify(n):ye(n)))}i=`{${e.join(", ")}}`}return`${a}${n?"("+n+")":""}[${i}]: ${e.replace(We,"\n  ")}`}("\n"+e.message,i,a,n),e.ngTokenPath=i,e.ngTempTokenPath=null,e}(r,e,"R3InjectorError",this.source)}throw r}finally{Fe(n)}var i}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,a)=>e.push(ye(a))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,a){if(!(e=xe(e)))return!1;let n=pe(e);const i=null==n&&e.ngModule||void 0,r=void 0===i?e:i,s=-1!==a.indexOf(r);if(void 0!==i&&(n=pe(i)),null==n)return!1;if(null!=n.imports&&!s){let e;a.push(r);try{et(n.imports,n=>{this.processInjectorType(n,t,a)&&(void 0===e&&(e=[]),e.push(n))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:a,providers:n}=e[t];et(n,e=>this.processProvider(e,a,n||kr))}}this.injectorDefTypes.add(r),this.records.set(r,Ir(n.factory,_r));const o=n.providers;if(null!=o&&!s){const t=e;et(o,e=>this.processProvider(e,t,o))}return void 0!==i&&void 0!==e.providers}processProvider(e,t,a){let n=Mr(e=xe(e))?e:xe(e&&e.provide);const i=function(e,t,a){return Rr(e)?Ir(void 0,e.useValue):Ir(function(e,t,a){let n=void 0;if(Mr(e)){const t=xe(e);return _t(t)||Ar(t)}if(Rr(e))n=()=>xe(e.useValue);else if((i=e)&&i.useFactory)n=()=>e.useFactory(...Ke(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))n=()=>Ye(xe(e.useExisting));else{const t=xe(e&&(e.useClass||e.provide));if(!function(e){return!!e.deps}(e))return _t(t)||Ar(t);n=()=>new t(...Ke(e.deps))}var i;return n}(e),_r)}(e);if(Mr(e)||!0!==e.multi)this.records.get(n);else{let t=this.records.get(n);t||(t=Ir(void 0,_r,!0),t.factory=()=>Ke(t.multi),this.records.set(n,t)),n=e,t.multi.push(e)}this.records.set(n,i)}hydrate(e,t){var a;return t.value===_r&&(t.value=xr,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(a=t.value)&&"object"==typeof a&&"function"==typeof a.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){return!!e.providedIn&&("string"==typeof e.providedIn?"any"===e.providedIn||e.providedIn===this.scope:this.injectorDefTypes.has(e.providedIn))}}function Ar(e){const t=de(e),a=null!==t?t.factory:_t(e);if(null!==a)return a;const n=pe(e);if(null!==n)return n.factory;if(e instanceof Ne)throw new Error(`Token ${ye(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const a=nt(t,"?");throw new Error(`Can't resolve all parameters for ${ye(e)}: (${a.join(", ")}).`)}const a=function(e){const t=e&&(e[me]||e[fe]);if(t){const a=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${a}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${a}" class.`),t}return null}(e);return null!==a?()=>a.factory(e):()=>new e}(e);throw new Error("unreachable")}function Ir(e,t,a=!1){return{factory:e,value:t,multi:a?[]:void 0}}function Rr(e){return null!==e&&"object"==typeof e&&Be in e}function Mr(e){return"function"==typeof e}const Pr=function(e,t,a){return function(e,t=null,a=null,n){const i=Cr(e,t,a,n);return i._resolveInjectorDefTypes(),i}({name:a},t,e,a)};let Dr=(()=>{class e{static create(e,t){return Array.isArray(e)?Pr(e,t,""):Pr(e.providers,e.parent,e.name||"")}}return e.THROW_IF_NOT_FOUND=je,e.NULL=new Xe,e.\u0275prov=ce({token:e,providedIn:"any",factory:()=>Ye(Oe)}),e.__NG_ELEMENT_ID__=-1,e})();const Lr=new Ne("AnalyzeForEntryComponents");function Nr(e,t,a){let n=a?e.styles:null,i=a?e.classes:null,r=0;if(null!==t)for(let s=0;s<t.length;s++){const e=t[s];"number"==typeof e?r=e:1==r?i=we(i,e):2==r&&(n=we(n,e+": "+t[++s]+";"))}a?e.styles=n:e.stylesWithoutHost=n,a?e.classes=i:e.classesWithoutHost=i}function Or(e,t){La($t(e)[1],ca())}function jr(e){let t=Object.getPrototypeOf(e.type.prototype).constructor,a=!0;const n=[e];for(;t;){let i=void 0;if(Rt(e))i=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Error("Directives cannot inherit Components");i=t.\u0275dir}if(i){if(a){n.push(i);const t=e;t.inputs=Wr(e.inputs),t.declaredInputs=Wr(e.declaredInputs),t.outputs=Wr(e.outputs);const a=i.hostBindings;a&&Gr(e,a);const r=i.viewQuery,s=i.contentQueries;if(r&&zr(e,r),s&&Br(e,s),le(e.inputs,i.inputs),le(e.declaredInputs,i.declaredInputs),le(e.outputs,i.outputs),Rt(i)&&i.data.animation){const t=e.data;t.animation=(t.animation||[]).concat(i.data.animation)}}const t=i.features;if(t)for(let n=0;n<t.length;n++){const i=t[n];i&&i.ngInherit&&i(e),i===jr&&(a=!1)}}t=Object.getPrototypeOf(t)}!function(e){let t=0,a=null;for(let n=e.length-1;n>=0;n--){const i=e[n];i.hostVars=t+=i.hostVars,i.hostAttrs=Qa(i.hostAttrs,a=Qa(a,i.hostAttrs))}}(n)}function Wr(e){return e===ct?{}:e===ht?[]:e}function zr(e,t){const a=e.viewQuery;e.viewQuery=a?(e,n)=>{t(e,n),a(e,n)}:t}function Br(e,t){const a=e.contentQueries;e.contentQueries=a?(e,n,i)=>{t(e,n,i),a(e,n,i)}:t}function Gr(e,t){const a=e.hostBindings;e.hostBindings=a?(e,n)=>{t(e,n),a(e,n)}:t}let Hr=null;function Fr(){if(!Hr){const e=Ee.Symbol;if(e&&e.iterator)Hr=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const a=e[t];"entries"!==a&&"size"!==a&&Map.prototype[a]===Map.prototype.entries&&(Hr=a)}}}return Hr}class qr{constructor(e){this.wrapped=e}static wrap(e){return new qr(e)}static unwrap(e){return qr.isWrapped(e)?e.wrapped:e}static isWrapped(e){return e instanceof qr}}function Qr(e){return!!Yr(e)&&(Array.isArray(e)||!(e instanceof Map)&&Fr()in e)}function Yr(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function Ur(e,t,a){return!Object.is(e[t],a)&&(e[t]=a,!0)}function Vr(e,t,a,n){const i=oa();return Ur(i,ya(),t)&&(la(),function(e,t,a,n,i,r){const s=Xt(e,t);!function(e,t,a,n,i,r,s){if(null==r)Yt(e)?e.removeAttribute(t,i,a):t.removeAttribute(i);else{const o=null==s?Dt(r):s(r,n||"",i);Yt(e)?e.setAttribute(t,i,o,a):a?t.setAttributeNS(a,i,o):t.setAttribute(i,o)}}(t[11],s,r,e.value,a,n,i)}(Da(),i,e,t,a,n)),Vr}function Kr(e,t,a,n,i,r,s,o){const l=oa(),c=la(),h=e+kt,d=c.firstCreatePass?function(e,t,a,n,i,r,s,o,l){const c=t.consts,h=xi(t,e,4,s||null,aa(c,o));ji(t,a,h,aa(c,l)),La(t,h);const d=h.tViews=Pi(2,h,n,i,r,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c);return null!==t.queries&&(t.queries.template(t,h),d.queries=t.queries.embeddedTView(h)),h}(h,c,l,t,a,n,i,r,s):c.data[h];da(d,!1);const u=l[11].createComment("");Qn(c,l,u,d),Cn(u,l),Ji(l,l[h]=Ui(u,l,u,d)),It(d)&&Ii(c,l,d),null!=s&&Ri(l,d,o)}function Xr(e,t=se.Default){const a=oa();return null===a?Ye(e,t):rn(ca(),a,xe(e),t)}function Jr(e){return function(e,t){if("class"===t)return e.classes;if("style"===t)return e.styles;const a=e.attrs;if(a){const e=a.length;let n=0;for(;n<e;){const i=a[n];if(Fa(i))break;if(0===i)n+=2;else if("number"==typeof i)for(n++;n<e&&"string"==typeof a[n];)n++;else{if(i===t)return a[n+1];n+=2}}}return null}(ca(),e)}function Zr(e,t,a){const n=oa();return Ur(n,ya(),t)&&Oi(la(),Da(),n,e,t,n[11],a,!1),Zr}function $r(e,t,a,n,i){const r=i?"class":"style";rr(e,a,t.inputs[r],r,n)}function es(e,t,a,n){const i=oa(),r=la(),s=kt+e,o=i[11],l=i[s]=Dn(o,t,ra.lFrame.currentNamespace),c=r.firstCreatePass?function(e,t,a,n,i,r,s){const o=t.consts,l=xi(t,e,2,i,aa(o,r));return ji(t,a,l,aa(o,s)),null!==l.attrs&&Nr(l,l.attrs,!1),null!==l.mergedAttrs&&Nr(l,l.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,l),l}(s,r,i,0,t,a,n):r.data[s];da(c,!0);const h=c.mergedAttrs;null!==h&&Ha(o,l,h);const d=c.classes;null!==d&&Zn(o,l,d);const u=c.styles;null!==u&&Jn(o,l,u),64!=(64&c.flags)&&Qn(r,i,l,c),0===ra.lFrame.elementDepthCount&&Cn(l,i),ra.lFrame.elementDepthCount++,It(c)&&(Ii(r,i,c),Ai(r,c,i)),null!==n&&Ri(i,c)}function ts(){let e=ca();ua()?pa():(e=e.parent,da(e,!1));const t=e;ra.lFrame.elementDepthCount--;const a=la();a.firstCreatePass&&(La(a,e),Et(e)&&a.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&$r(a,t,oa(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&$r(a,t,oa(),t.stylesWithoutHost,!1)}function as(e,t,a,n){es(e,t,a,n),ts()}function ns(e,t,a){const n=oa(),i=la(),r=e+kt,s=i.firstCreatePass?function(e,t,a,n,i){const r=t.consts,s=aa(r,n),o=xi(t,e,8,"ng-container",s);return null!==s&&Nr(o,s,!0),ji(t,a,o,aa(r,i)),null!==t.queries&&t.queries.elementStart(t,o),o}(r,i,n,t,a):i.data[r];da(s,!0);const o=n[r]=n[11].createComment("");Qn(i,n,o,s),Cn(o,n),It(s)&&(Ii(i,n,s),Ai(i,s,n)),null!=a&&Ri(n,s)}function is(){let e=ca();const t=la();ua()?pa():(e=e.parent,da(e,!1)),t.firstCreatePass&&(La(t,e),Et(e)&&t.queries.elementEnd(e))}function rs(e){return!!e&&"function"==typeof e.then}function ss(e){return!!e&&"function"==typeof e.subscribe}function os(e,t,a=!1,n){const i=oa(),r=la(),s=ca();return function(e,t,a,n,i,r,s=!1,o){const l=It(n),c=e.firstCreatePass&&(e.cleanup||(e.cleanup=[])),h=nr(t);let d=!0;if(3&n.type){const u=Xt(n,t),p=o?o(u):ct,m=p.target||u,g=h.length,f=o?e=>o(Vt(e[n.index])).target:n.index;if(Yt(a)){let s=null;if(!o&&l&&(s=function(e,t,a,n){const i=e.cleanup;if(null!=i)for(let r=0;r<i.length-1;r+=2){const e=i[r];if(e===a&&i[r+1]===n){const e=t[7],a=i[r+2];return e.length>a?e[a]:null}"string"==typeof e&&(r+=2)}return null}(e,t,i,n.index)),null!==s)(s.__ngLastListenerFn__||s).__ngNextListenerFn__=r,s.__ngLastListenerFn__=r,d=!1;else{r=cs(n,t,r,!1);const e=a.listen(p.name||m,i,r);h.push(r,e),c&&c.push(i,f,g,g+1)}}else r=cs(n,t,r,!0),m.addEventListener(i,r,s),h.push(r),c&&c.push(i,f,g,s)}const u=n.outputs;let p;if(d&&null!==u&&(p=u[i])){const e=p.length;if(e)for(let a=0;a<e;a+=2){const e=t[p[a]][p[a+1]].subscribe(r),s=h.length;h.push(r,e),c&&c.push(i,n.index,s,-(s+1))}}}(r,i,i[11],s,e,t,a,n),os}function ls(e,t,a){try{return!1!==t(a)}catch(n){return ir(e,n),!1}}function cs(e,t,a,n){return function i(r){if(r===Function)return a;const s=2&e.flags?Zt(e.index,t):t;0==(32&t[2])&&Zi(s);let o=ls(t,a,r),l=i.__ngNextListenerFn__;for(;l;)o=ls(t,l,r)&&o,l=l.__ngNextListenerFn__;return n&&!1===o&&(r.preventDefault(),r.returnValue=!1),o}}function hs(e=1){return function(e){return(ra.lFrame.contextLView=function(e,t){for(;e>0;)t=t[15],e--;return t}(e,ra.lFrame.contextLView))[8]}(e)}function ds(e,t){let a=null;const n=function(e){const t=e.attrs;if(null!=t){const e=t.indexOf(5);if(0==(1&e))return t[e+1]}return null}(e);for(let i=0;i<t.length;i++){const r=t[i];if("*"!==r){if(null===n?oi(e,r,!0):li(n,r))return i}else a=i}return a}function us(e){const t=oa()[16][6];if(!t.projection){const a=t.projection=nt(e?e.length:1,null),n=a.slice();let i=t.child;for(;null!==i;){const t=e?ds(i,e):0;null!==t&&(n[t]?n[t].projectionNext=i:a[t]=i,n[t]=i),i=i.next}}}function ps(e,t=0,a){const n=oa(),i=la(),r=xi(i,kt+e,16,null,a||null);null===r.projection&&(r.projection=t),pa(),64!=(64&r.flags)&&function(e,t,a){Xn(t[11],0,t,a,Wn(e,a,t),Fn(a.parent||t[6],a,t))}(i,n,r)}const ms=[];function gs(e,t,a,n,i){const r=e[a+1],s=null===t;let o=n?gi(r):bi(r),l=!1;for(;0!==o&&(!1===l||s);){const a=e[o+1];fs(e[o],t)&&(l=!0,e[o+1]=n?wi(a):fi(a)),o=n?gi(a):bi(a)}l&&(e[a+1]=n?fi(r):wi(r))}function fs(e,t){return null===e||null==t||(Array.isArray(e)?e[1]:e)===t||!(!Array.isArray(e)||"string"!=typeof t)&&st(e,t)>=0}function bs(e,t,a){return ws(e,t,a,!1),bs}function ys(e,t){return ws(e,t,null,!0),ys}function ws(e,t,a,n){const i=oa(),r=la(),s=wa(2);r.firstUpdatePass&&function(e,t,a,n){const i=e.data;if(null===i[a+1]){const r=i[Ma()],s=function(e,t){return t>=e.expandoStartIndex}(e,a);(function(e,t){return 0!=(e.flags&(t?16:32))})(r,n)&&null===t&&!s&&(t=!1),t=function(e,t,a,n){const i=function(e){const t=ra.lFrame.currentDirectiveIndex;return-1===t?null:e[t]}(e);let r=n?t.residualClasses:t.residualStyles;if(null===i)0===(n?t.classBindings:t.styleBindings)&&(a=_s(a=vs(null,e,t,a,n),t.attrs,n),r=null);else{const s=t.directiveStylingLast;if(-1===s||e[s]!==i)if(a=vs(i,e,t,a,n),null===r){let a=function(e,t,a){const n=a?t.classBindings:t.styleBindings;if(0!==bi(n))return e[gi(n)]}(e,t,n);void 0!==a&&Array.isArray(a)&&(a=vs(null,e,t,a[1],n),a=_s(a,t.attrs,n),function(e,t,a,n){e[gi(a?t.classBindings:t.styleBindings)]=n}(e,t,n,a))}else r=function(e,t,a){let n=void 0;const i=t.directiveEnd;for(let r=1+t.directiveStylingLast;r<i;r++)n=_s(n,e[r].hostAttrs,a);return _s(n,t.attrs,a)}(e,t,n)}return void 0!==r&&(n?t.residualClasses=r:t.residualStyles=r),a}(i,r,t,n),function(e,t,a,n,i,r){let s=r?t.classBindings:t.styleBindings,o=gi(s),l=bi(s);e[n]=a;let c,h=!1;if(Array.isArray(a)){const e=a;c=e[1],(null===c||st(e,c)>0)&&(h=!0)}else c=a;if(i)if(0!==l){const t=gi(e[o+1]);e[n+1]=mi(t,o),0!==t&&(e[t+1]=yi(e[t+1],n)),e[o+1]=131071&e[o+1]|n<<17}else e[n+1]=mi(o,0),0!==o&&(e[o+1]=yi(e[o+1],n)),o=n;else e[n+1]=mi(l,0),0===o?o=n:e[l+1]=yi(e[l+1],n),l=n;h&&(e[n+1]=fi(e[n+1])),gs(e,c,n,!0),gs(e,c,n,!1),function(e,t,a,n,i){const r=i?e.residualClasses:e.residualStyles;null!=r&&"string"==typeof t&&st(r,t)>=0&&(a[n+1]=wi(a[n+1]))}(t,c,e,n,r),s=mi(o,l),r?t.classBindings=s:t.styleBindings=s}(i,r,t,a,s,n)}}(r,e,s,n),t!==di&&Ur(i,s,t)&&function(e,t,a,n,i,r,s,o){if(!(3&t.type))return;const l=e.data,c=l[o+1];ks(1==(1&c)?xs(l,t,a,i,bi(c),s):void 0)||(ks(r)||function(e){return 2==(2&e)}(c)&&(r=xs(l,null,a,i,o,s)),function(e,t,a,n,i){const r=Yt(e);if(t)i?r?e.addClass(a,n):a.classList.add(n):r?e.removeClass(a,n):a.classList.remove(n);else{const t=-1==n.indexOf("-")?void 0:2;null==i?r?e.removeStyle(a,n,t):a.style.removeProperty(n):r?e.setStyle(a,n,i,t):a.style.setProperty(n,i)}}(n,s,Kt(Ma(),a),i,r))}(r,r.data[Ma()],i,i[11],e,i[s+1]=function(e,t){return null==e||("string"==typeof t?e+=t:"object"==typeof e&&(e=ye(yn(e)))),e}(t,a),n,s)}function vs(e,t,a,n,i){let r=null;const s=a.directiveEnd;let o=a.directiveStylingLast;for(-1===o?o=a.directiveStart:o++;o<s&&(r=t[o],n=_s(n,r.hostAttrs,i),r!==e);)o++;return null!==e&&(a.directiveStylingLast=o),n}function _s(e,t,a){const n=a?1:2;let i=-1;if(null!==t)for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?i=s:i===n&&(Array.isArray(e)||(e=void 0===e?[]:["",e]),it(e,s,!!a||t[++r]))}return void 0===e?null:e}function xs(e,t,a,n,i,r){const s=null===t;let o=void 0;for(;i>0;){const t=e[i],r=Array.isArray(t),l=r?t[1]:t,c=null===l;let h=a[i+1];h===di&&(h=c?ms:void 0);let d=c?rt(h,n):l===n?h:void 0;if(r&&!ks(d)&&(d=rt(t,n)),ks(d)&&(o=d,s))return o;const u=e[i+1];i=s?gi(u):bi(u)}if(null!==t){let e=r?t.residualClasses:t.residualStyles;null!=e&&(o=rt(e,n))}return o}function ks(e){return void 0!==e}function Ss(e,t=""){const a=oa(),n=la(),i=e+kt,r=n.firstCreatePass?xi(n,i,1,t,null):n.data[i],s=a[i]=function(e,t){return Yt(e)?e.createText(t):e.createTextNode(t)}(a[11],t);Qn(n,a,s,r),da(r,!1)}function Ts(e){return Cs("",e,""),Ts}function Cs(e,t,a){const n=oa(),i=function(e,t,a,n){return Ur(e,ya(),a)?t+Dt(a)+n:di}(n,e,t,a);return i!==di&&sr(n,Ma(),i),Cs}function Es(e,t,a,n,i){const r=oa(),s=function(e,t,a,n,i,r){const s=function(e,t,a,n){const i=Ur(e,t,a);return Ur(e,t+1,n)||i}(e,ba(),a,i);return wa(2),s?t+Dt(a)+n+Dt(i)+r:di}(r,e,t,a,n,i);return s!==di&&sr(r,Ma(),s),Es}function As(e,t,a){const n=oa();return Ur(n,ya(),t)&&Oi(la(),Da(),n,e,t,n[11],a,!0),As}const Is=void 0;var Rs=["en",[["a","p"],["AM","PM"],Is],[["AM","PM"],Is,Is],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Is,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Is,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Is,"{1} 'at' {0}",Is],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),a=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===a?1:5}];let Ms={};function Ps(e){return e in Ms||(Ms[e]=Ee.ng&&Ee.ng.common&&Ee.ng.common.locales&&Ee.ng.common.locales[e]),Ms[e]}var Ds=function(e){return e[e.LocaleId=0]="LocaleId",e[e.DayPeriodsFormat=1]="DayPeriodsFormat",e[e.DayPeriodsStandalone=2]="DayPeriodsStandalone",e[e.DaysFormat=3]="DaysFormat",e[e.DaysStandalone=4]="DaysStandalone",e[e.MonthsFormat=5]="MonthsFormat",e[e.MonthsStandalone=6]="MonthsStandalone",e[e.Eras=7]="Eras",e[e.FirstDayOfWeek=8]="FirstDayOfWeek",e[e.WeekendRange=9]="WeekendRange",e[e.DateFormat=10]="DateFormat",e[e.TimeFormat=11]="TimeFormat",e[e.DateTimeFormat=12]="DateTimeFormat",e[e.NumberSymbols=13]="NumberSymbols",e[e.NumberFormats=14]="NumberFormats",e[e.CurrencyCode=15]="CurrencyCode",e[e.CurrencySymbol=16]="CurrencySymbol",e[e.CurrencyName=17]="CurrencyName",e[e.Currencies=18]="Currencies",e[e.Directionality=19]="Directionality",e[e.PluralCase=20]="PluralCase",e[e.ExtraData=21]="ExtraData",e}({});const Ls="en-US";let Ns=Ls;function Os(e){var t,a;a="Expected localeId to be defined",null==(t=e)&&function(e,t,a,n){throw new Error("ASSERTION ERROR: "+e+` [Expected=> null != ${t} <=Actual]`)}(a,t),"string"==typeof e&&(Ns=e.toLowerCase().replace(/_/g,"-"))}class js{}class Ws{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${ye(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}let zs=(()=>{class e{}return e.NULL=new Ws,e})(),Bs=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=()=>Gs(e),e})();const Gs=function(e){return pr(e,ca(),oa())};class Hs{}var Fs=function(e){return e[e.Important=1]="Important",e[e.DashCase=2]="DashCase",e}({});let qs=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>Qs(),e})();const Qs=function(){const e=oa(),t=Zt(ca().index,e);return function(e){const t=e[11];if(Yt(t))return t;throw new Error("Cannot inject Renderer2 when the application uses Renderer3!")}(Tt(t)?t:e)};let Ys=(()=>{class e{}return e.\u0275prov=ce({token:e,providedIn:"root",factory:()=>null}),e})();class Us{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const Vs=new Us("11.0.0-rc.2");class Ks{constructor(){}supports(e){return Qr(e)}create(e){return new Js(e)}}const Xs=(e,t)=>t;class Js{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||Xs}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,a=this._removalsHead,n=0,i=null;for(;t||a;){const r=!a||t&&t.currentIndex<to(a,n,i)?t:a,s=to(r,n,i),o=r.currentIndex;if(r===a)n--,a=a._nextRemoved;else if(t=t._next,null==r.previousIndex)n++;else{i||(i=[]);const e=s-n,t=o-n;if(e!=t){for(let a=0;a<e;a++){const n=a<i.length?i[a]:i[a]=0,r=n+a;t<=r&&r<e&&(i[a]=n+1)}i[r.previousIndex]=t-e}}s!==o&&e(r,s,o)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!Qr(e))throw new Error(`Error trying to diff '${ye(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,a,n,i=this._itHead,r=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)a=e[t],n=this._trackByFn(t,a),null!==i&&Object.is(i.trackById,n)?(r&&(i=this._verifyReinsertion(i,a,n,t)),Object.is(i.item,a)||this._addIdentityChange(i,a)):(i=this._mismatch(i,a,n,t),r=!0),i=i._next}else t=0,function(e,t){if(Array.isArray(e))for(let a=0;a<e.length;a++)t(e[a]);else{const a=e[Fr()]();let n;for(;!(n=a.next()).done;)t(n.value)}}(e,e=>{n=this._trackByFn(t,e),null!==i&&Object.is(i.trackById,n)?(r&&(i=this._verifyReinsertion(i,e,n,t)),Object.is(i.item,e)||this._addIdentityChange(i,e)):(i=this._mismatch(i,e,n,t),r=!0),i=i._next,t++}),this.length=t;return this._truncate(i),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,a,n){let i;return null===e?i=this._itTail:(i=e._prev,this._remove(e)),null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(a,n))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,i,n)):null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(a,null))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,i,n)):e=this._addAfter(new Zs(t,a),i,n),e}_verifyReinsertion(e,t,a,n){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(a,null);return null!==i?e=this._reinsertAfter(i,e._prev,n):e.currentIndex!=n&&(e.currentIndex=n,this._addToMoves(e,n)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,a){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const n=e._prevRemoved,i=e._nextRemoved;return null===n?this._removalsHead=i:n._nextRemoved=i,null===i?this._removalsTail=n:i._prevRemoved=n,this._insertAfter(e,t,a),this._addToMoves(e,a),e}_moveAfter(e,t,a){return this._unlink(e),this._insertAfter(e,t,a),this._addToMoves(e,a),e}_addAfter(e,t,a){return this._insertAfter(e,t,a),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,a){const n=null===t?this._itHead:t._next;return e._next=n,e._prev=t,null===n?this._itTail=e:n._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new eo),this._linkedRecords.put(e),e.currentIndex=a,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,a=e._next;return null===t?this._itHead=a:t._next=a,null===a?this._itTail=t:a._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new eo),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class Zs{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class $s{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let a;for(a=this._head;null!==a;a=a._nextDup)if((null===t||t<=a.currentIndex)&&Object.is(a.trackById,e))return a;return null}remove(e){const t=e._prevDup,a=e._nextDup;return null===t?this._head=a:t._nextDup=a,null===a?this._tail=t:a._prevDup=t,null===this._head}}class eo{constructor(){this.map=new Map}put(e){const t=e.trackById;let a=this.map.get(t);a||(a=new $s,this.map.set(t,a)),a.add(e)}get(e,t){const a=this.map.get(e);return a?a.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function to(e,t,a){const n=e.previousIndex;if(null===n)return n;let i=0;return a&&n<a.length&&(i=a[n]),n+t+i}class ao{constructor(){}supports(e){return e instanceof Map||Yr(e)}create(){return new no}}class no{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||Yr(e)))throw new Error(`Error trying to diff '${ye(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,a)=>{if(t&&t.key===a)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const n=this._getOrCreateRecordForKey(a,e);t=this._insertBeforeOrAppend(t,n)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const a=e._prev;return t._next=e,t._prev=a,e._prev=t,a&&(a._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const a=this._records.get(e);this._maybeAddToChanges(a,t);const n=a._prev,i=a._next;return n&&(n._next=i),i&&(i._prev=n),a._next=null,a._prev=null,a}const a=new io(e);return this._records.set(e,a),a.currentValue=t,this._addToAdditions(a),a}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){Object.is(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(a=>t(e[a],a))}}class io{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}let ro=(()=>{class e{constructor(e){this.factories=e}static create(t,a){if(null!=a){const e=a.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:a=>{if(!a)throw new Error("Cannot extend IterableDiffers without a parent injector");return e.create(t,a)},deps:[[e,new re,new ne]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${a=e,a.name||typeof a}'`);var a}}return e.\u0275prov=ce({token:e,providedIn:"root",factory:()=>new e([new Ks])}),e})(),so=(()=>{class e{constructor(e){this.factories=e}static create(t,a){if(a){const e=a.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:a=>{if(!a)throw new Error("Cannot extend KeyValueDiffers without a parent injector");return e.create(t,a)},deps:[[e,new re,new ne]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=ce({token:e,providedIn:"root",factory:()=>new e([new ao])}),e})();const oo=[new ao],lo=new ro([new Ks]),co=new so(oo);let ho=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>uo(e,Bs),e})();const uo=function(e,t){return mr(e,t,ca(),oa())};let po=(()=>{class e{}return e.__NG_ELEMENT_ID__=()=>mo(e,Bs),e})();const mo=function(e,t){return gr(e,t,ca(),oa())},go={};class fo extends zs{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=vt(e);return new wo(t,this.ngModule)}}function bo(e){const t=[];for(let a in e)e.hasOwnProperty(a)&&t.push({propName:e[a],templateName:a});return t}const yo=new Ne("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Nt});class wo extends js{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(hi).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return bo(this.componentDef.inputs)}get outputs(){return bo(this.componentDef.outputs)}create(e,t,a,n){const i=(n=n||this.ngModule)?function(e,t){return{get:(a,n,i)=>{const r=e.get(a,go,i);return r!==go||n===go?r:t.get(a,n,i)}}}(e,n.injector):e,r=i.get(Hs,Ut),s=i.get(Ys,null),o=r.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",c=a?function(e,t,a){if(Yt(e))return e.selectRootElement(t,a===lt.ShadowDom);let n="string"==typeof t?e.querySelector(t):t;return n.textContent="",n}(o,a,this.componentDef.encapsulation):Dn(r.createRenderer(null,this.componentDef),l,function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(l)),h=this.componentDef.onPush?576:528,d={components:[],scheduler:Nt,clean:ar,playerHandler:null,flags:0},u=Pi(0,null,null,1,0,null,null,null,null,null),p=_i(null,u,d,h,null,null,r,o,s,i);let m,g;Ta(p);try{const e=function(e,t,a,n,i,r){const s=a[1];a[20]=e;const o=xi(s,20,2,"#host",null),l=o.mergedAttrs=t.hostAttrs;null!==l&&(Nr(o,l,!0),null!==e&&(Ha(i,e,l),null!==o.classes&&Zn(i,e,o.classes),null!==o.styles&&Jn(i,e,o.styles)));const c=n.createRenderer(e,t),h=_i(a,Mi(t),null,t.onPush?64:16,a[20],o,n,c,null,null);return s.firstCreatePass&&(nn($a(o,a),s,t.type),Bi(s,o),Hi(o,a.length,1)),Ji(a,h),a[20]=h}(c,this.componentDef,p,r,o);if(c)if(a)Ha(o,c,["ng-version",Vs.full]);else{const{attrs:e,classes:t}=function(e){const t=[],a=[];let n=1,i=2;for(;n<e.length;){let r=e[n];if("string"==typeof r)2===i?""!==r&&t.push(r,e[++n]):8===i&&a.push(r);else{if(!ri(i))break;i=r}n++}return{attrs:t,classes:a}}(this.componentDef.selectors[0]);e&&Ha(o,c,e),t&&t.length>0&&Zn(o,c,t.join(" "))}if(g=Jt(u,kt),void 0!==t){const e=g.projection=[];for(let a=0;a<this.ngContentSelectors.length;a++){const n=t[a];e.push(null!=n?Array.from(n):null)}}m=function(e,t,a,n,i){const r=a[1],s=function(e,t,a){const n=ca();e.firstCreatePass&&(a.providersResolver&&a.providersResolver(a),Fi(e,n,t,ki(e,t,1,null),a));const i=cn(t,e,n.directiveStart,n);Cn(i,t);const r=Xt(n,t);return r&&Cn(r,t),i}(r,a,t);if(n.components.push(s),e[8]=s,i&&i.forEach(e=>e(s,t)),t.contentQueries){const e=ca();t.contentQueries(1,s,e.directiveStart)}const o=ca();return!r.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(Pa(o.index),Wi(a[1],o,0,o.directiveStart,o.directiveEnd,t),zi(t,s)),s}(e,this.componentDef,p,d,[Or]),Si(u,p,null)}finally{Ra()}return new vo(this.componentType,m,pr(Bs,g,p),p,g)}}class vo extends class{}{constructor(e,t,a,n,i){super(),this.location=a,this._rootLView=n,this._tNode=i,this.destroyCbs=[],this.instance=t,this.hostView=this.changeDetectorRef=new lr(n),this.componentType=e}get injector(){return new un(this._tNode,this._rootLView)}destroy(){this.destroyCbs&&(this.destroyCbs.forEach(e=>e()),this.destroyCbs=null,!this.hostView.destroyed&&this.hostView.destroy())}onDestroy(e){this.destroyCbs&&this.destroyCbs.push(e)}}const _o=new Map;class xo extends Je{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new fo(this);const a=xt(e),n=e[Pe]||null;n&&Os(n),this._bootstrapComponents=jt(a.bootstrap),this._r3Injector=Cr(e,t,[{provide:Je,useValue:this},{provide:zs,useValue:this.componentFactoryResolver}],ye(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=Dr.THROW_IF_NOT_FOUND,a=se.Default){return e===Dr||e===Je||e===Oe?this:this._r3Injector.get(e,t,a)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class ko extends Ze{constructor(e){super(),this.moduleType=e,null!==xt(e)&&function(e){const t=new Set;!function e(a){const n=xt(a,!0),i=n.id;null!==i&&(function(e,t,a){if(t&&t!==a)throw new Error(`Duplicate module registered for ${e} - ${ye(t)} vs ${ye(t.name)}`)}(i,_o.get(i),a),_o.set(i,a));const r=jt(n.imports);for(const s of r)t.has(s)||(t.add(s),e(s))}(e)}(e)}create(e){return new xo(this.moduleType,e)}}function So(e,t,a,n,i,r){const s=t+a;return Ur(e,s,i)?function(e,t,a){return e[t]=a}(e,s+1,r?n.call(r,i):n(i)):function(e,t){const a=e[t];return a===di?void 0:a}(e,s+1)}const To=class extends k{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,a){let n,i=e=>null,r=()=>null;e&&"object"==typeof e?(n=this.__isAsync?t=>{setTimeout(()=>e.next(t))}:t=>{e.next(t)},e.error&&(i=this.__isAsync?t=>{setTimeout(()=>e.error(t))}:t=>{e.error(t)}),e.complete&&(r=this.__isAsync?()=>{setTimeout(()=>e.complete())}:()=>{e.complete()})):(n=this.__isAsync?t=>{setTimeout(()=>e(t))}:t=>{e(t)},t&&(i=this.__isAsync?e=>{setTimeout(()=>t(e))}:e=>{t(e)}),a&&(r=this.__isAsync?()=>{setTimeout(()=>a())}:()=>{a()}));const s=super.subscribe(n,i,r);return e instanceof d&&e.add(s),s}};function Co(){return this._results[Fr()]()}class Eo{constructor(){this.dirty=!0,this._results=[],this.changes=new To,this.length=0;const e=Fr(),t=Eo.prototype;t[e]||(t[e]=Co)}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e){this._results=$e(e),this.dirty=!1,this.length=this._results.length,this.last=this._results[this.length-1],this.first=this._results[0]}notifyOnChanges(){this.changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class Ao{constructor(e){this.queryList=e,this.matches=null}clone(){return new Ao(this.queryList)}setDirty(){this.queryList.setDirty()}}class Io{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const a=null!==e.contentQueries?e.contentQueries[0]:t.length,n=[];for(let e=0;e<a;e++){const a=t.getByIndex(e);n.push(this.queries[a.indexInDeclarationView].clone())}return new Io(n)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==Go(e,t).matches&&this.queries[t].setDirty()}}class Ro{constructor(e,t,a,n=null){this.predicate=e,this.descendants=t,this.isStatic=a,this.read=n}}class Mo{constructor(e=[]){this.queries=e}elementStart(e,t){for(let a=0;a<this.queries.length;a++)this.queries[a].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let a=0;a<this.length;a++){const n=null!==t?t.length:0,i=this.getByIndex(a).embeddedTView(e,n);i&&(i.indexInDeclarationView=a,null!==t?t.push(i):t=[i])}return null!==t?new Mo(t):null}template(e,t){for(let a=0;a<this.queries.length;a++)this.queries[a].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class Po{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new Po(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&!1===this.metadata.descendants){const t=this._declarationNodeIndex;let a=e.parent;for(;null!==a&&8&a.type&&a.index!==t;)a=a.parent;return t===(null!==a?a.index:-1)}return this._appliesToNextNode}matchTNode(e,t){const a=this.metadata.predicate;if(Array.isArray(a))for(let n=0;n<a.length;n++){const i=a[n];this.matchTNodeWithReadOption(e,t,Do(t,i)),this.matchTNodeWithReadOption(e,t,ln(t,e,i,!1,!1))}else a===ho?4&t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,ln(t,e,a,!1,!1))}matchTNodeWithReadOption(e,t,a){if(null!==a){const n=this.metadata.read;if(null!==n)if(n===Bs||n===po||n===ho&&4&t.type)this.addMatch(t.index,-2);else{const a=ln(t,e,n,!1,!1);null!==a&&this.addMatch(t.index,a)}else this.addMatch(t.index,a)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function Do(e,t){const a=e.localNames;if(null!==a)for(let n=0;n<a.length;n+=2)if(a[n]===t)return a[n+1];return null}function Lo(e,t,a,n){return-1===a?function(e,t){return 11&e.type?pr(Bs,e,t):4&e.type?mr(ho,Bs,e,t):null}(t,e):-2===a?function(e,t,a){return a===Bs?pr(Bs,t,e):a===ho?mr(ho,Bs,t,e):a===po?gr(po,Bs,t,e):void 0}(e,t,n):cn(e,e[1],a,t)}function No(e,t,a,n){const i=t[19].queries[n];if(null===i.matches){const n=e.data,r=a.matches,s=[];for(let e=0;e<r.length;e+=2){const i=r[e];s.push(i<0?null:Lo(t,n[i],r[e+1],a.metadata.read))}i.matches=s}return i.matches}function Oo(e,t,a,n){const i=e.queries.getByIndex(a),r=i.matches;if(null!==r){const s=No(e,t,i,a);for(let e=0;e<r.length;e+=2){const a=r[e];if(a>0)n.push(s[e/2]);else{const i=r[e+1],s=t[-a];for(let e=St;e<s.length;e++){const t=s[e];t[17]===t[3]&&Oo(t[1],t,i,n)}if(null!==s[9]){const e=s[9];for(let t=0;t<e.length;t++){const a=e[t];Oo(a[1],a,i,n)}}}}}return n}function jo(e){const t=oa(),a=la(),n=xa();ka(n+1);const i=Go(a,n);if(e.dirty&&ea(t)===i.metadata.isStatic){if(null===i.matches)e.reset([]);else{const r=i.crossesNgTemplate?Oo(a,t,n,[]):No(a,t,i,n);e.reset(r),e.notifyOnChanges()}return!0}return!1}function Wo(){return e=oa(),t=xa(),e[19].queries[t].queryList;var e,t}function zo(e,t){const a=new Eo;Di(e,t,a,a.destroy),null===t[19]&&(t[19]=new Io),t[19].queries.push(new Ao(a))}function Bo(e,t,a){null===e.queries&&(e.queries=new Mo),e.queries.track(new Po(t,a))}function Go(e,t){return e.queries.getByIndex(t)}const Ho=new Ne("Application Initializer");let Fo=(()=>{class e{constructor(e){this.appInits=e,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let a=0;a<this.appInits.length;a++){const t=this.appInits[a]();rs(t)&&e.push(t)}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(Ye(Ho,8))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const qo=new Ne("AppId"),Qo={provide:qo,useFactory:function(){return`${Yo()}${Yo()}${Yo()}`},deps:[]};function Yo(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Uo=new Ne("Platform Initializer"),Vo=new Ne("Platform ID"),Ko=new Ne("appBootstrapListener");let Xo=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const Jo=new Ne("LocaleId"),Zo=new Ne("DefaultCurrencyCode");class $o{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const el=function(e){return new ko(e)},tl=el,al=function(e){return Promise.resolve(el(e))},nl=function(e){const t=el(e),a=jt(xt(e).declarations).reduce((e,t)=>{const a=vt(t);return a&&e.push(new wo(a)),e},[]);return new $o(t,a)},il=nl,rl=function(e){return Promise.resolve(nl(e))};let sl=(()=>{class e{constructor(){this.compileModuleSync=tl,this.compileModuleAsync=al,this.compileModuleAndAllComponentsSync=il,this.compileModuleAndAllComponentsAsync=rl}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const ol=(()=>Promise.resolve(0))();function ll(e){"undefined"==typeof Zone?ol.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class cl{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new To(!1),this.onMicrotaskEmpty=new To(!1),this.onStable=new To(!1),this.onError=new To(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const a=this;a._nesting=0,a._outer=a._inner=Zone.current,Zone.wtfZoneSpec&&(a._inner=a._inner.fork(Zone.wtfZoneSpec)),Zone.TaskTrackingZoneSpec&&(a._inner=a._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(a._inner=a._inner.fork(Zone.longStackTraceZoneSpec)),a.shouldCoalesceEventChangeDetection=t,a.lastRequestAnimationFrameId=-1,a.nativeRequestAnimationFrame=function(){let e=Ee.requestAnimationFrame,t=Ee.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const a=e[Zone.__symbol__("OriginalDelegate")];a&&(e=a);const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=!!e.shouldCoalesceEventChangeDetection&&e.nativeRequestAnimationFrame&&(()=>{!function(e){-1===e.lastRequestAnimationFrameId&&(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(Ee,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,pl(e),ul(e)},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),pl(e))}(e)});e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0,maybeDelayChangeDetection:t},onInvokeTask:(a,n,i,r,s,o)=>{try{return ml(e),a.invokeTask(i,r,s,o)}finally{t&&"eventTask"===r.type&&t(),gl(e)}},onInvoke:(t,a,n,i,r,s,o)=>{try{return ml(e),t.invoke(n,i,r,s,o)}finally{gl(e)}},onHasTask:(t,a,n,i)=>{t.hasTask(n,i),a===n&&("microTask"==i.change?(e._hasPendingMicrotasks=i.microTask,pl(e),ul(e)):"macroTask"==i.change&&(e.hasPendingMacrotasks=i.macroTask))},onHandleError:(t,a,n,i)=>(t.handleError(n,i),e.runOutsideAngular(()=>e.onError.emit(i)),!1)})}(a)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!cl.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(cl.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,a){return this._inner.run(e,t,a)}runTask(e,t,a,n){const i=this._inner,r=i.scheduleEventTask("NgZoneEvent: "+n,e,dl,hl,hl);try{return i.runTask(r,t,a)}finally{i.cancelTask(r)}}runGuarded(e,t,a){return this._inner.runGuarded(e,t,a)}runOutsideAngular(e){return this._outer.run(e)}}function hl(){}const dl={};function ul(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function pl(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||e.shouldCoalesceEventChangeDetection&&-1!==e.lastRequestAnimationFrameId)}function ml(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function gl(e){e._nesting--,ul(e)}class fl{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new To,this.onMicrotaskEmpty=new To,this.onStable=new To,this.onError=new To}run(e,t,a){return e.apply(t,a)}runGuarded(e,t,a){return e.apply(t,a)}runOutsideAngular(e){return e()}runTask(e,t,a,n){return e.apply(t,a)}}let bl=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{cl.assertNotInAngularZone(),ll(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())ll(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,a){let n=-1;t&&t>0&&(n=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==n),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:n,updateCb:a})}whenStable(e,t,a){if(a&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(e,t,a),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,a){return[]}}return e.\u0275fac=function(t){return new(t||e)(Ye(cl))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),yl=(()=>{class e{constructor(){this._applications=new Map,_l.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return _l.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();class wl{addToWindow(e){}findTestabilityInTree(e,t,a){return null}}let vl,_l=new wl;const xl=new Ne("AllowMultipleToken");class kl{constructor(e,t){this.name=e,this.token=t}}function Sl(e,t,a=[]){const n="Platform: "+t,i=new Ne(n);return(t=[])=>{let r=Tl();if(!r||r.injector.get(xl,!1))if(e)e(a.concat(t).concat({provide:i,useValue:!0}));else{const e=a.concat(t).concat({provide:i,useValue:!0},{provide:vr,useValue:"platform"});!function(e){if(vl&&!vl.destroyed&&!vl.injector.get(xl,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");vl=e.get(Cl);const t=e.get(Uo,null);t&&t.forEach(e=>e())}(Dr.create({providers:e,name:n}))}return function(e){const t=Tl();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(i)}}function Tl(){return vl&&!vl.destroyed?vl:null}let Cl=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const a=function(e,t){let a;return a="noop"===e?new fl:("zone.js"===e?void 0:e)||new cl({enableLongStackTrace:_n(),shouldCoalesceEventChangeDetection:t}),a}(t?t.ngZone:void 0,t&&t.ngZoneEventCoalescing||!1),n=[{provide:cl,useValue:a}];return a.run(()=>{const t=Dr.create({providers:n,parent:this.injector,name:e.moduleType.name}),i=e.create(t),r=i.injector.get(fn,null);if(!r)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return i.onDestroy(()=>Il(this._modules,i)),a.runOutsideAngular(()=>a.onError.subscribe({next:e=>{r.handleError(e)}})),function(e,t,a){try{const n=a();return rs(n)?n.catch(a=>{throw t.runOutsideAngular(()=>e.handleError(a)),a}):n}catch(n){throw t.runOutsideAngular(()=>e.handleError(n)),n}}(r,a,()=>{const e=i.injector.get(Fo);return e.runInitializers(),e.donePromise.then(()=>(Os(i.injector.get(Jo,Ls)||Ls),this._moduleDoBootstrap(i),i))})})}bootstrapModule(e,t=[]){const a=El({},t);return function(e,t,a){const n=new ko(a);return Promise.resolve(n)}(0,0,e).then(e=>this.bootstrapModuleFactory(e,a))}_moduleDoBootstrap(e){const t=e.injector.get(Al);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${ye(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(Ye(Dr))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();function El(e,t){return Array.isArray(t)?t.reduce(El,e):Object.assign(Object.assign({},e),t)}let Al=(()=>{class e{constructor(e,t,a,n,i,r){this._zone=e,this._console=t,this._injector=a,this._exceptionHandler=n,this._componentFactoryResolver=i,this._initStatus=r,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._enforceNoNewChanges=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._enforceNoNewChanges=_n(),this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const s=new y(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),o=new y(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{cl.assertNotInAngularZone(),ll(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const a=this._zone.onUnstable.subscribe(()=>{cl.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),a.unsubscribe()}});this.isStable=Q(s,o.pipe(e=>{return Y()((t=Z,function(e){let a;a="function"==typeof t?t:function(){return t};const n=Object.create(e,X);return n.source=e,n.subjectFactory=a,n})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let a;a=e instanceof js?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(a.componentType);const n=a.isBoundToModule?void 0:this._injector.get(Je),i=a.create(Dr.NULL,[],t||a.selector,n);i.onDestroy(()=>{this._unloadComponent(i)});const r=i.injector.get(bl,null);return r&&i.injector.get(yl).registerApplication(i.location.nativeElement,r),this._loadComponent(i),_n()&&this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."),i}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges();if(this._enforceNoNewChanges)for(let e of this._views)e.checkNoChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;Il(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(Ko,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}_unloadComponent(e){this.detachView(e.hostView),Il(this.components,e)}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy())}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(Ye(cl),Ye(Xo),Ye(Dr),Ye(fn),Ye(zs),Ye(Fo))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();function Il(e,t){const a=e.indexOf(t);a>-1&&e.splice(a,1)}class Rl{}class Ml{}const Pl={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let Dl=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||Pl}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,n]=e.split("#");return void 0===n&&(n="default"),a("zn8P")(t).then(e=>e[n]).then(e=>Ll(e,t,n)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,n]=e.split("#"),i="NgFactory";return void 0===n&&(n="default",i=""),a("zn8P")(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[n+i]).then(e=>Ll(e,t,n))}}return e.\u0275fac=function(t){return new(t||e)(Ye(sl),Ye(Ml,8))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();function Ll(e,t,a){if(!e)throw new Error(`Cannot find '${a}' in '${t}'`);return e}const Nl=Sl(null,"core",[{provide:Vo,useValue:"unknown"},{provide:Cl,deps:[Dr]},{provide:yl,deps:[]},{provide:Xo,deps:[]}]),Ol=[{provide:Al,useClass:Al,deps:[cl,Xo,Dr,fn,zs,Fo]},{provide:yo,deps:[cl],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:Fo,useClass:Fo,deps:[[new ne,Ho]]},{provide:sl,useClass:sl,deps:[]},Qo,{provide:ro,useFactory:function(){return lo},deps:[]},{provide:so,useFactory:function(){return co},deps:[]},{provide:Jo,useFactory:function(e){return Os(e=e||"undefined"!=typeof $localize&&$localize.locale||Ls),e},deps:[[new ae(Jo),new ne,new re]]},{provide:Zo,useValue:"USD"}];let jl=(()=>{class e{constructor(e){}}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)(Ye(Al))},providers:Ol}),e})(),Wl=null;function zl(){return Wl}const Bl=new Ne("DocumentToken");let Gl=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({factory:Hl,token:e,providedIn:"platform"}),e})();function Hl(){return Ye(ql)}const Fl=new Ne("Location Initialized");let ql=(()=>{class e extends Gl{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=zl().getLocation(),this._history=zl().getHistory()}getBaseHrefFromDOM(){return zl().getBaseHref(this._doc)}onPopState(e){zl().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",e,!1)}onHashChange(e){zl().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",e,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,a){Ql()?this._history.pushState(e,t,a):this.location.hash=a}replaceState(e,t,a){Ql()?this._history.replaceState(e,t,a):this.location.hash=a}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl))},e.\u0275prov=ce({factory:Yl,token:e,providedIn:"platform"}),e})();function Ql(){return!!window.history.pushState}function Yl(){return new ql(Ye(Bl))}function Ul(e,t){if(0==e.length)return t;if(0==t.length)return e;let a=0;return e.endsWith("/")&&a++,t.startsWith("/")&&a++,2==a?e+t.substring(1):1==a?e+t:e+"/"+t}function Vl(e){const t=e.match(/#|\?|$/),a=t&&t.index||e.length;return e.slice(0,a-("/"===e[a-1]?1:0))+e.slice(a)}function Kl(e){return e&&"?"!==e[0]?"?"+e:e}let Xl=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({factory:Jl,token:e,providedIn:"root"}),e})();function Jl(e){const t=Ye(Bl).location;return new $l(Ye(Gl),t&&t.origin||"")}const Zl=new Ne("appBaseHref");let $l=(()=>{class e extends Xl{constructor(e,t){if(super(),this._platformLocation=e,null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}onPopState(e){this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e)}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Ul(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+Kl(this._platformLocation.search),a=this._platformLocation.hash;return a&&e?`${t}${a}`:t}pushState(e,t,a,n){const i=this.prepareExternalUrl(a+Kl(n));this._platformLocation.pushState(e,t,i)}replaceState(e,t,a,n){const i=this.prepareExternalUrl(a+Kl(n));this._platformLocation.replaceState(e,t,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return e.\u0275fac=function(t){return new(t||e)(Ye(Gl),Ye(Zl,8))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),ec=(()=>{class e extends Xl{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",null!=t&&(this._baseHref=t)}onPopState(e){this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e)}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=Ul(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,a,n){let i=this.prepareExternalUrl(a+Kl(n));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,t,i)}replaceState(e,t,a,n){let i=this.prepareExternalUrl(a+Kl(n));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return e.\u0275fac=function(t){return new(t||e)(Ye(Gl),Ye(Zl,8))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),tc=(()=>{class e{constructor(e,t){this._subject=new To,this._urlChangeListeners=[],this._platformStrategy=e;const a=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=Vl(nc(a)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+Kl(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,nc(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",a=null){this._platformStrategy.pushState(a,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Kl(t)),a)}replaceState(e,t="",a=null){this._platformStrategy.replaceState(a,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Kl(t)),a)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)}))}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(a=>a(e,t))}subscribe(e,t,a){return this._subject.subscribe({next:e,error:t,complete:a})}}return e.\u0275fac=function(t){return new(t||e)(Ye(Xl),Ye(Gl))},e.normalizeQueryParams=Kl,e.joinWithSlash=Ul,e.stripTrailingSlash=Vl,e.\u0275prov=ce({factory:ac,token:e,providedIn:"root"}),e})();function ac(){return new tc(Ye(Xl),Ye(Gl))}function nc(e){return e.replace(/\/index.html$/,"")}var ic=function(e){return e[e.Zero=0]="Zero",e[e.One=1]="One",e[e.Two=2]="Two",e[e.Few=3]="Few",e[e.Many=4]="Many",e[e.Other=5]="Other",e}({});class rc{}let sc=(()=>{class e extends rc{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return function(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let a=Ps(t);if(a)return a;const n=t.split("-")[0];if(a=Ps(n),a)return a;if("en"===n)return Rs;throw new Error(`Missing locale data for the locale "${e}".`)}(e)[Ds.PluralCase]}(t||this.locale)(e)){case ic.Zero:return"zero";case ic.One:return"one";case ic.Two:return"two";case ic.Few:return"few";case ic.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(Ye(Jo))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),oc=(()=>{class e{constructor(e,t,a,n){this._iterableDiffers=e,this._keyValueDiffers=t,this._ngEl=a,this._renderer=n,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(Qr(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachChangedItem(e=>this._toggleClass(e.key,e.currentValue)),e.forEachRemovedItem(e=>{e.previousValue&&this._toggleClass(e.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(e=>{if("string"!=typeof e.item)throw new Error("NgClass can only toggle CSS classes expressed as strings, got "+ye(e.item));this._toggleClass(e.item,!0)}),e.forEachRemovedItem(e=>this._toggleClass(e.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!0)):Object.keys(e).forEach(t=>this._toggleClass(t,!!e[t])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(e=>this._toggleClass(e,!1)):Object.keys(e).forEach(e=>this._toggleClass(e,!1)))}_toggleClass(e,t){(e=e.trim())&&e.split(/\s+/g).forEach(e=>{t?this._renderer.addClass(this._ngEl.nativeElement,e):this._renderer.removeClass(this._ngEl.nativeElement,e)})}}return e.\u0275fac=function(t){return new(t||e)(Xr(ro),Xr(so),Xr(Bs),Xr(qs))},e.\u0275dir=yt({type:e,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),e})();class lc{constructor(e,t,a,n){this.$implicit=e,this.ngForOf=t,this.index=a,this.count=n}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let cc=(()=>{class e{constructor(e,t,a){this._viewContainer=e,this._template=t,this._differs=a,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){_n()&&null!=e&&"function"!=typeof e&&console&&console.warn&&console.warn(`trackBy must be a function, but received ${JSON.stringify(e)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`),this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const a=this._ngForOf;if(!this._differ&&a)try{this._differ=this._differs.find(a).create(this.ngForTrackBy)}catch(t){throw new Error(`Cannot find a differ supporting object '${a}' of type '${e=a,e.name||typeof e}'. NgFor only supports binding to Iterables such as Arrays.`)}}var e;if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const t=[];e.forEachOperation((e,a,n)=>{if(null==e.previousIndex){const a=this._viewContainer.createEmbeddedView(this._template,new lc(null,this._ngForOf,-1,-1),null===n?void 0:n),i=new hc(e,a);t.push(i)}else if(null==n)this._viewContainer.remove(null===a?void 0:a);else if(null!==a){const i=this._viewContainer.get(a);this._viewContainer.move(i,n);const r=new hc(e,i);t.push(r)}});for(let a=0;a<t.length;a++)this._perViewChange(t[a].view,t[a].record);for(let a=0,n=this._viewContainer.length;a<n;a++){const e=this._viewContainer.get(a);e.context.index=a,e.context.count=n,e.context.ngForOf=this._ngForOf}e.forEachIdentityChange(e=>{this._viewContainer.get(e.currentIndex).context.$implicit=e.item})}_perViewChange(e,t){e.context.$implicit=t.item}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(Xr(po),Xr(ho),Xr(ro))},e.\u0275dir=yt({type:e,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),e})();class hc{constructor(e,t){this.record=e,this.view=t}}let dc=(()=>{class e{constructor(e,t){this._viewContainer=e,this._context=new uc,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=t}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){pc("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){pc("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(Xr(po),Xr(ho))},e.\u0275dir=yt({type:e,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),e})();class uc{constructor(){this.$implicit=null,this.ngIf=null}}function pc(e,t){if(t&&!t.createEmbeddedView)throw new Error(`${e} must be a TemplateRef, but received '${ye(t)}'.`)}class mc{createSubscription(e,t){return e.subscribe({next:t,error:e=>{throw e}})}dispose(e){e.unsubscribe()}onDestroy(e){e.unsubscribe()}}class gc{createSubscription(e,t){return e.then(t,e=>{throw e})}dispose(e){}onDestroy(e){}}const fc=new gc,bc=new mc;let yc=(()=>{class e{constructor(e){this._ref=e,this._latestValue=null,this._subscription=null,this._obj=null,this._strategy=null}ngOnDestroy(){this._subscription&&this._dispose()}transform(e){return this._obj?e!==this._obj?(this._dispose(),this.transform(e)):this._latestValue:(e&&this._subscribe(e),this._latestValue)}_subscribe(e){this._obj=e,this._strategy=this._selectStrategy(e),this._subscription=this._strategy.createSubscription(e,t=>this._updateLatestValue(e,t))}_selectStrategy(t){if(rs(t))return fc;if(ss(t))return bc;throw Error(`InvalidPipeArgument: '${t}' for pipe '${ye(e)}'`)}_dispose(){this._strategy.dispose(this._subscription),this._latestValue=null,this._subscription=null,this._obj=null}_updateLatestValue(e,t){e===this._obj&&(this._latestValue=t,this._ref.markForCheck())}}return e.\u0275fac=function(t){return new(t||e)(function(e=se.Default){const t=fr(!0);if(null!=t||e&se.Optional)return t;Wt("ChangeDetectorRef")}())},e.\u0275pipe=wt({name:"async",type:e,pure:!1}),e})(),wc=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},providers:[{provide:rc,useClass:sc}]}),e})(),vc=(()=>{class e{}return e.\u0275prov=ce({token:e,providedIn:"root",factory:()=>new _c(Ye(Bl),window,Ye(fn))}),e})();class _c{constructor(e,t,a){this.document=e,this.window=t,this.errorHandler=a,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.scrollX,this.window.scrollY]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(this.supportsScrolling()){const t=this.document.getElementById(e)||this.document.getElementsByName(e)[0];t&&this.scrollToElement(t)}}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),a=t.left+this.window.pageXOffset,n=t.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(a-i[0],n-i[1])}supportScrollRestoration(){try{if(!this.window||!this.window.scrollTo)return!1;const e=xc(this.window.history)||xc(Object.getPrototypeOf(this.window.history));return!(!e||!e.writable&&!e.set)}catch(e){return!1}}supportsScrolling(){try{return!!this.window.scrollTo}catch(e){return!1}}}function xc(e){return Object.getOwnPropertyDescriptor(e,"scrollRestoration")}class kc extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var e;e=new kc,Wl||(Wl=e)}getProperty(e,t){return e[t]}log(e){window.console&&window.console.log&&window.console.log(e)}logGroup(e){window.console&&window.console.group&&window.console.group(e)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(e,t,a){return e.addEventListener(t,a,!1),()=>{e.removeEventListener(t,a,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){return e.parentNode&&e.parentNode.removeChild(e),e}getValue(e){return e.value}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(e){const t=Tc||(Tc=document.querySelector("base"),Tc)?Tc.getAttribute("href"):null;return null==t?null:(a=t,Sc||(Sc=document.createElement("a")),Sc.setAttribute("href",a),"/"===Sc.pathname.charAt(0)?Sc.pathname:"/"+Sc.pathname);var a}resetBaseElement(){Tc=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(e){return function(e,t){t=encodeURIComponent(t);for(const a of e.split(";")){const e=a.indexOf("="),[n,i]=-1==e?[a,""]:[a.slice(0,e),a.slice(e+1)];if(n.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,e)}}let Sc,Tc=null;const Cc=new Ne("TRANSITION_ID"),Ec=[{provide:Ho,useFactory:function(e,t,a){return()=>{a.get(Fo).donePromise.then(()=>{const a=zl();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>a.remove(e))})}},deps:[Cc,Bl,Dr],multi:!0}];class Ac{static init(){var e;e=new Ac,_l=e}addToWindow(e){Ee.getAngularTestability=(t,a=!0)=>{const n=e.findTestabilityInTree(t,a);if(null==n)throw new Error("Could not find testability for element.");return n},Ee.getAllAngularTestabilities=()=>e.getAllTestabilities(),Ee.getAllAngularRootElements=()=>e.getAllRootElements(),Ee.frameworkStabilizers||(Ee.frameworkStabilizers=[]),Ee.frameworkStabilizers.push(e=>{const t=Ee.getAllAngularTestabilities();let a=t.length,n=!1;const i=function(t){n=n||t,a--,0==a&&e(n)};t.forEach(function(e){e.whenStable(i)})})}findTestabilityInTree(e,t,a){if(null==t)return null;const n=e.getTestability(t);return null!=n?n:a?zl().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}const Ic=new Ne("EventManagerPlugins");let Rc=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,a){return this._findPluginFor(t).addEventListener(e,t,a)}addGlobalEventListener(e,t,a){return this._findPluginFor(t).addGlobalEventListener(e,t,a)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const a=this._plugins;for(let n=0;n<a.length;n++){const t=a[n];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error("No event manager plugin found for event "+e)}}return e.\u0275fac=function(t){return new(t||e)(Ye(Ic),Ye(cl))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();class Mc{constructor(e){this._doc=e}addGlobalEventListener(e,t,a){const n=zl().getGlobalEventTarget(this._doc,e);if(!n)throw new Error(`Unsupported event target ${n} for event ${t}`);return this.addEventListener(n,t,a)}}let Pc=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),Dc=(()=>{class e extends Pc{constructor(e){super(),this._doc=e,this._hostNodes=new Set,this._styleNodes=new Set,this._hostNodes.add(e.head)}_addStylesToHost(e,t){e.forEach(e=>{const a=this._doc.createElement("style");a.textContent=e,this._styleNodes.add(t.appendChild(a))})}addHost(e){this._addStylesToHost(this._stylesSet,e),this._hostNodes.add(e)}removeHost(e){this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach(t=>this._addStylesToHost(e,t))}ngOnDestroy(){this._styleNodes.forEach(e=>zl().remove(e))}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const Lc={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},Nc=/%COMP%/g;function Oc(e,t,a){for(let n=0;n<t.length;n++){let i=t[n];Array.isArray(i)?Oc(e,i,a):(i=i.replace(Nc,e),a.push(i))}return a}function jc(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let Wc=(()=>{class e{constructor(e,t,a){this.eventManager=e,this.sharedStylesHost=t,this.appId=a,this.rendererByCompId=new Map,this.defaultRenderer=new zc(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case lt.Emulated:{let a=this.rendererByCompId.get(t.id);return a||(a=new Bc(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,a)),a.applyToHost(e),a}case 1:case lt.ShadowDom:return new Gc(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=Oc(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(Ye(Rc),Ye(Dc),Ye(qo))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();class zc{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(Lc[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,a){e&&e.insertBefore(t,a)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let a="string"==typeof e?document.querySelector(e):e;if(!a)throw new Error(`The selector "${e}" did not match any elements`);return t||(a.textContent=""),a}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,a,n){if(n){t=n+":"+t;const i=Lc[n];i?e.setAttributeNS(i,t,a):e.setAttribute(t,a)}else e.setAttribute(t,a)}removeAttribute(e,t,a){if(a){const n=Lc[a];n?e.removeAttributeNS(n,t):e.removeAttribute(`${a}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,a,n){n&Fs.DashCase?e.style.setProperty(t,a,n&Fs.Important?"important":""):e.style[t]=a}removeStyle(e,t,a){a&Fs.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,a){e[t]=a}setValue(e,t){e.nodeValue=t}listen(e,t,a){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,jc(a)):this.eventManager.addEventListener(e,t,jc(a))}}class Bc extends zc{constructor(e,t,a,n){super(e),this.component=a;const i=Oc(n+"-"+a.id,a.styles,[]);t.addStyles(i),this.contentAttr="_ngcontent-%COMP%".replace(Nc,n+"-"+a.id),this.hostAttr="_nghost-%COMP%".replace(Nc,n+"-"+a.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const a=super.createElement(e,t);return super.setAttribute(a,this.contentAttr,""),a}}class Gc extends zc{constructor(e,t,a,n){super(e),this.sharedStylesHost=t,this.hostEl=a,this.shadowRoot=a.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const i=Oc(n.id,n.styles,[]);for(let r=0;r<i.length;r++){const e=document.createElement("style");e.textContent=i[r],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,a){return super.insertBefore(this.nodeOrShadowRoot(e),t,a)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let Hc=(()=>{class e extends Mc{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,a){return e.addEventListener(t,a,!1),()=>this.removeEventListener(e,t,a)}removeEventListener(e,t,a){return e.removeEventListener(t,a)}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const Fc=["alt","control","meta","shift"],qc={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Qc={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Yc={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let Uc=(()=>{class e extends Mc{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,a,n){const i=e.parseEventName(a),r=e.eventCallback(i.fullKey,n,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>zl().onAndCancel(t,i.domEventName,r))}static parseEventName(t){const a=t.toLowerCase().split("."),n=a.shift();if(0===a.length||"keydown"!==n&&"keyup"!==n)return null;const i=e._normalizeKey(a.pop());let r="";if(Fc.forEach(e=>{const t=a.indexOf(e);t>-1&&(a.splice(t,1),r+=e+".")}),r+=i,0!=a.length||0===i.length)return null;const s={};return s.domEventName=n,s.fullKey=r,s}static getEventFullKey(e){let t="",a=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&Qc.hasOwnProperty(t)&&(t=Qc[t]))}return qc[t]||t}(e);return a=a.toLowerCase()," "===a?a="space":"."===a&&(a="dot"),Fc.forEach(n=>{n!=a&&(0,Yc[n])(e)&&(t+=n+".")}),t+=a,t}static eventCallback(t,a,n){return i=>{e.getEventFullKey(i)===t&&n.runGuarded(()=>a(i))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const Vc=Sl(Nl,"browser",[{provide:Vo,useValue:"browser"},{provide:Uo,useValue:function(){kc.makeCurrent(),Ac.init()},multi:!0},{provide:Bl,useFactory:function(){return function(e){Qt=e}(document),document},deps:[]}]),Kc=[[],{provide:vr,useValue:"root"},{provide:fn,useFactory:function(){return new fn},deps:[]},{provide:Ic,useClass:Hc,multi:!0,deps:[Bl,cl,Vo]},{provide:Ic,useClass:Uc,multi:!0,deps:[Bl]},[],{provide:Wc,useClass:Wc,deps:[Rc,Dc,qo]},{provide:Hs,useExisting:Wc},{provide:Pc,useExisting:Dc},{provide:Dc,useClass:Dc,deps:[Bl]},{provide:bl,useClass:bl,deps:[cl]},{provide:Rc,useClass:Rc,deps:[Ic,cl]},[]];let Xc=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:qo,useValue:t.appId},{provide:Cc,useExisting:qo},Ec]}}}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)(Ye(e,12))},providers:Kc,imports:[wc,jl]}),e})();function Jc(...e){let t=e[e.length-1];return T(t)?(e.pop(),N(e,t)):q(e)}"undefined"!=typeof window&&window;class Zc extends k{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new v;return this._value}next(e){super.next(this._value=e)}}class $c extends m{notifyNext(e,t,a,n,i){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}class eh extends m{constructor(e,t,a){super(),this.parent=e,this.outerValue=t,this.outerIndex=a,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function th(e,t,a,n,i=new eh(e,a,n)){if(!i.closed)return t instanceof y?t.subscribe(i):L(t)(i)}const ah={};function nh(...e){let t=void 0,a=void 0;return T(e[e.length-1])&&(a=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&l(e[0])&&(e=e[0]),q(e,a).lift(new ih(t))}class ih{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new rh(e,this.resultSelector))}}class rh extends $c{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(ah),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let a=0;a<t;a++)this.add(th(this,e[a],void 0,a))}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,a){const n=this.values,i=this.toRespond?n[a]===ah?--this.toRespond:this.toRespond:0;n[a]=t,0===i&&(this.resultSelector?this._tryResultSelector(n):this.destination.next(n.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(a){return void this.destination.error(a)}this.destination.next(t)}}const sh=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})(),oh=new y(e=>e.complete());function lh(e){return e?function(e){return new y(t=>e.schedule(()=>t.complete()))}(e):oh}function ch(e){return new y(t=>{let a;try{a=e()}catch(n){return void t.error(n)}return(a?O(a):lh()).subscribe(t)})}function hh(){return F(1)}function dh(e,t){return function(a){return a.lift(new uh(e,t))}}class uh{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new ph(e,this.predicate,this.thisArg))}}class ph extends m{constructor(e,t,a){super(e),this.predicate=t,this.thisArg=a,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(a){return void this.destination.error(a)}t&&this.destination.next(e)}}const mh=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function gh(e){return function(t){return 0===e?lh():t.lift(new fh(e))}}class fh{constructor(e){if(this.total=e,this.total<0)throw new mh}call(e,t){return t.subscribe(new bh(e,this.total))}}class bh extends m{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,a=this.total,n=this.count++;t.length<a?t.push(e):t[n%a]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const a=this.count>=this.total?this.total:this.count,n=this.ring;for(let i=0;i<a;i++){const i=t++%a;e.next(n[i])}}e.complete()}}function yh(e=_h){return t=>t.lift(new wh(e))}class wh{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new vh(e,this.errorFactory))}}class vh extends m{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function _h(){return new sh}function xh(e=null){return t=>t.lift(new kh(e))}class kh{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new Sh(e,this.defaultValue))}}class Sh extends m{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Th(e,t){return"function"==typeof t?a=>a.pipe(Th((a,n)=>O(e(a,n)).pipe(C((e,i)=>t(a,e,n,i))))):t=>t.lift(new Ch(e))}class Ch{constructor(e){this.project=e}call(e,t){return t.subscribe(new Eh(e,this.project))}}class Eh extends W{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const a=this.index++;try{t=this.project(e,a)}catch(n){return void this.destination.error(n)}this._innerSub(t)}_innerSub(e){const t=this.innerSubscription;t&&t.unsubscribe();const a=new j(this),n=this.destination;n.add(a),this.innerSubscription=z(e,a),this.innerSubscription!==a&&n.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(e){this.destination.next(e)}}function Ah(e){return t=>0===e?lh():t.lift(new Ih(e))}class Ih{constructor(e){if(this.total=e,this.total<0)throw new mh}call(e,t){return t.subscribe(new Rh(e,this.total))}}class Rh extends m{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,a=++this.count;a<=t&&(this.destination.next(e),a===t&&(this.destination.complete(),this.unsubscribe()))}}function Mh(...e){return hh()(Jc(...e))}function Ph(...e){const t=e[e.length-1];return T(t)?(e.pop(),a=>Mh(e,a,t)):t=>Mh(e,t)}class Dh{constructor(e,t,a=!1){this.accumulator=e,this.seed=t,this.hasSeed=a}call(e,t){return t.subscribe(new Lh(e,this.accumulator,this.seed,this.hasSeed))}}class Lh extends m{constructor(e,t,a,n){super(e),this.accumulator=t,this._seed=a,this.hasSeed=n,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let a;try{a=this.accumulator(this.seed,e,t)}catch(n){this.destination.error(n)}this.seed=a,this.destination.next(a)}}function Nh(e){return function(t){const a=new Oh(e),n=t.lift(a);return a.caught=n}}class Oh{constructor(e){this.selector=e}call(e,t){return t.subscribe(new jh(e,this.selector,this.caught))}}class jh extends W{constructor(e,t,a){super(e),this.selector=t,this.caught=a}error(e){if(!this.isStopped){let a;try{a=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const n=new j(this);this.add(n);const i=z(a,n);i!==n&&this.add(i)}}}function Wh(e,t){return B(e,t,1)}function zh(e,t){const a=arguments.length>=2;return n=>n.pipe(e?dh((t,a)=>e(t,a,n)):b,Ah(1),a?xh(t):yh(()=>new sh))}function Bh(){}function Gh(e,t,a){return function(n){return n.lift(new Hh(e,t,a))}}class Hh{constructor(e,t,a){this.nextOrObserver=e,this.error=t,this.complete=a}call(e,t){return t.subscribe(new Fh(e,this.nextOrObserver,this.error,this.complete))}}class Fh extends m{constructor(e,t,a,i){super(e),this._tapNext=Bh,this._tapError=Bh,this._tapComplete=Bh,this._tapError=a||Bh,this._tapComplete=i||Bh,n(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||Bh,this._tapError=t.error||Bh,this._tapComplete=t.complete||Bh)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class qh{constructor(e){this.callback=e}call(e,t){return t.subscribe(new Qh(e,this.callback))}}class Qh extends m{constructor(e,t){super(e),this.add(new d(t))}}class Yh{constructor(e,t){this.id=e,this.url=t}}class Uh extends Yh{constructor(e,t,a="imperative",n=null){super(e,t),this.navigationTrigger=a,this.restoredState=n}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Vh extends Yh{constructor(e,t,a){super(e,t),this.urlAfterRedirects=a}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Kh extends Yh{constructor(e,t,a){super(e,t),this.reason=a}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Xh extends Yh{constructor(e,t,a){super(e,t),this.error=a}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Jh extends Yh{constructor(e,t,a,n){super(e,t),this.urlAfterRedirects=a,this.state=n}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Zh extends Yh{constructor(e,t,a,n){super(e,t),this.urlAfterRedirects=a,this.state=n}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class $h extends Yh{constructor(e,t,a,n,i){super(e,t),this.urlAfterRedirects=a,this.state=n,this.shouldActivate=i}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class ed extends Yh{constructor(e,t,a,n){super(e,t),this.urlAfterRedirects=a,this.state=n}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class td extends Yh{constructor(e,t,a,n){super(e,t),this.urlAfterRedirects=a,this.state=n}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class ad{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class nd{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class id{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class rd{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class sd{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class od{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ld{constructor(e,t,a){this.routerEvent=e,this.position=t,this.anchor=a}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const cd="primary";class hd{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function dd(e){return new hd(e)}function ud(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function pd(e,t,a){const n=a.path.split("/");if(n.length>e.length)return null;if("full"===a.pathMatch&&(t.hasChildren()||n.length<e.length))return null;const i={};for(let r=0;r<n.length;r++){const t=n[r],a=e[r];if(t.startsWith(":"))i[t.substring(1)]=a;else if(t!==a.path)return null}return{consumed:e.slice(0,n.length),posParams:i}}function md(e,t){const a=Object.keys(e),n=Object.keys(t);if(!a||!n||a.length!=n.length)return!1;let i;for(let r=0;r<a.length;r++)if(i=a[r],!gd(e[i],t[i]))return!1;return!0}function gd(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const a=[...e].sort(),n=[...t].sort();return a.every((e,t)=>n[t]===e)}return e===t}function fd(e){return Array.prototype.concat.apply([],e)}function bd(e){return e.length>0?e[e.length-1]:null}function yd(e,t){for(const a in e)e.hasOwnProperty(a)&&t(e[a],a)}function wd(e){return ss(e)?e:rs(e)?O(Promise.resolve(e)):Jc(e)}function vd(e,t,a){return a?function(e,t){return md(e,t)}(e.queryParams,t.queryParams)&&_d(e.root,t.root):function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(a=>gd(e[a],t[a]))}(e.queryParams,t.queryParams)&&xd(e.root,t.root)}function _d(e,t){if(!Ed(e.segments,t.segments))return!1;if(e.numberOfChildren!==t.numberOfChildren)return!1;for(const a in t.children){if(!e.children[a])return!1;if(!_d(e.children[a],t.children[a]))return!1}return!0}function xd(e,t){return kd(e,t,t.segments)}function kd(e,t,a){if(e.segments.length>a.length)return!!Ed(e.segments.slice(0,a.length),a)&&!t.hasChildren();if(e.segments.length===a.length){if(!Ed(e.segments,a))return!1;for(const a in t.children){if(!e.children[a])return!1;if(!xd(e.children[a],t.children[a]))return!1}return!0}{const n=a.slice(0,e.segments.length),i=a.slice(e.segments.length);return!!Ed(e.segments,n)&&!!e.children.primary&&kd(e.children.primary,t,i)}}class Sd{constructor(e,t,a){this.root=e,this.queryParams=t,this.fragment=a}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=dd(this.queryParams)),this._queryParamMap}toString(){return Md.serialize(this)}}class Td{constructor(e,t){this.segments=e,this.children=t,this.parent=null,yd(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Pd(this)}}class Cd{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=dd(this.parameters)),this._parameterMap}toString(){return zd(this)}}function Ed(e,t){return e.length===t.length&&e.every((e,a)=>e.path===t[a].path)}function Ad(e,t){let a=[];return yd(e.children,(e,n)=>{n===cd&&(a=a.concat(t(e,n)))}),yd(e.children,(e,n)=>{n!==cd&&(a=a.concat(t(e,n)))}),a}class Id{}class Rd{parse(e){const t=new qd(e);return new Sd(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){return`${"/"+Dd(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const a=e[t];return Array.isArray(a)?a.map(e=>`${Nd(t)}=${Nd(e)}`).join("&"):`${Nd(t)}=${Nd(a)}`});return t.length?"?"+t.join("&"):""}(e.queryParams)}${"string"==typeof e.fragment?"#"+encodeURI(e.fragment):""}`}}const Md=new Rd;function Pd(e){return e.segments.map(e=>zd(e)).join("/")}function Dd(e,t){if(!e.hasChildren())return Pd(e);if(t){const t=e.children.primary?Dd(e.children.primary,!1):"",a=[];return yd(e.children,(e,t)=>{t!==cd&&a.push(`${t}:${Dd(e,!1)}`)}),a.length>0?`${t}(${a.join("//")})`:t}{const t=Ad(e,(t,a)=>a===cd?[Dd(e.children.primary,!1)]:[`${a}:${Dd(t,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children.primary?`${Pd(e)}/${t[0]}`:`${Pd(e)}/(${t.join("//")})`}}function Ld(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Nd(e){return Ld(e).replace(/%3B/gi,";")}function Od(e){return Ld(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function jd(e){return decodeURIComponent(e)}function Wd(e){return jd(e.replace(/\+/g,"%20"))}function zd(e){return`${Od(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${Od(e)}=${Od(t[e])}`).join("")}`;var t}const Bd=/^[^\/()?;=#]+/;function Gd(e){const t=e.match(Bd);return t?t[0]:""}const Hd=/^[^=?&#]+/,Fd=/^[^?&#]+/;class qd{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Td([],{}):new Td([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let a={};return this.peekStartsWith("(")&&(a=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(a.primary=new Td(e,t)),a}parseSegment(){const e=Gd(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new Cd(jd(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=Gd(this.remaining);if(!t)return;this.capture(t);let a="";if(this.consumeOptional("=")){const e=Gd(this.remaining);e&&(a=e,this.capture(a))}e[jd(t)]=jd(a)}parseQueryParam(e){const t=function(e){const t=e.match(Hd);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let a="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(Fd);return t?t[0]:""}(this.remaining);e&&(a=e,this.capture(a))}const n=Wd(t),i=Wd(a);if(e.hasOwnProperty(n)){let t=e[n];Array.isArray(t)||(t=[t],e[n]=t),t.push(i)}else e[n]=i}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const a=Gd(this.remaining),n=this.remaining[a.length];if("/"!==n&&")"!==n&&";"!==n)throw new Error(`Cannot parse url '${this.url}'`);let i=void 0;a.indexOf(":")>-1?(i=a.substr(0,a.indexOf(":")),this.capture(i),this.capture(":")):e&&(i=cd);const r=this.parseChildren();t[i]=1===Object.keys(r).length?r.primary:new Td([],r),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class Qd{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=Yd(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=Yd(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=Ud(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return Ud(e,this._root).map(e=>e.value)}}function Yd(e,t){if(e===t.value)return t;for(const a of t.children){const t=Yd(e,a);if(t)return t}return null}function Ud(e,t){if(e===t.value)return[t];for(const a of t.children){const n=Ud(e,a);if(n.length)return n.unshift(t),n}return[]}class Vd{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function Kd(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class Xd extends Qd{constructor(e,t){super(e),this.snapshot=t,au(this,e)}toString(){return this.snapshot.toString()}}function Jd(e,t){const a=function(e,t){const a=new eu([],{},{},"",{},cd,t,null,e.root,-1,{});return new tu("",new Vd(a,[]))}(e,t),n=new Zc([new Cd("",{})]),i=new Zc({}),r=new Zc({}),s=new Zc({}),o=new Zc(""),l=new Zd(n,i,s,o,r,cd,t,a.root);return l.snapshot=a.root,new Xd(new Vd(l,[]),a)}class Zd{constructor(e,t,a,n,i,r,s,o){this.url=e,this.params=t,this.queryParams=a,this.fragment=n,this.data=i,this.outlet=r,this.component=s,this._futureSnapshot=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(C(e=>dd(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(C(e=>dd(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function $d(e,t="emptyOnly"){const a=e.pathFromRoot;let n=0;if("always"!==t)for(n=a.length-1;n>=1;){const e=a[n],t=a[n-1];if(e.routeConfig&&""===e.routeConfig.path)n--;else{if(t.component)break;n--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(a.slice(n))}class eu{constructor(e,t,a,n,i,r,s,o,l,c,h){this.url=e,this.params=t,this.queryParams=a,this.fragment=n,this.data=i,this.outlet=r,this.component=s,this.routeConfig=o,this._urlSegment=l,this._lastPathIndex=c,this._resolve=h}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=dd(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=dd(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class tu extends Qd{constructor(e,t){super(t),this.url=e,au(this,t)}toString(){return nu(this._root)}}function au(e,t){t.value._routerState=e,t.children.forEach(t=>au(e,t))}function nu(e){const t=e.children.length>0?` { ${e.children.map(nu).join(", ")} } `:"";return`${e.value}${t}`}function iu(e){if(e.snapshot){const t=e.snapshot,a=e._futureSnapshot;e.snapshot=a,md(t.queryParams,a.queryParams)||e.queryParams.next(a.queryParams),t.fragment!==a.fragment&&e.fragment.next(a.fragment),md(t.params,a.params)||e.params.next(a.params),function(e,t){if(e.length!==t.length)return!1;for(let a=0;a<e.length;++a)if(!md(e[a],t[a]))return!1;return!0}(t.url,a.url)||e.url.next(a.url),md(t.data,a.data)||e.data.next(a.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function ru(e,t){var a,n;return md(e.params,t.params)&&Ed(a=e.url,n=t.url)&&a.every((e,t)=>md(e.parameters,n[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||ru(e.parent,t.parent))}function su(e,t,a){if(a&&e.shouldReuseRoute(t.value,a.value.snapshot)){const n=a.value;n._futureSnapshot=t.value;const i=function(e,t,a){return t.children.map(t=>{for(const n of a.children)if(e.shouldReuseRoute(t.value,n.value.snapshot))return su(e,t,n);return su(e,t)})}(e,t,a);return new Vd(n,i)}{const a=e.retrieve(t.value);if(a){const e=a.route;return ou(t,e),e}{const a=new Zd(new Zc((n=t.value).url),new Zc(n.params),new Zc(n.queryParams),new Zc(n.fragment),new Zc(n.data),n.outlet,n.component,n),i=t.children.map(t=>su(e,t));return new Vd(a,i)}}var n}function ou(e,t){if(e.value.routeConfig!==t.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==t.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");t.value._futureSnapshot=e.value;for(let a=0;a<e.children.length;++a)ou(e.children[a],t.children[a])}function lu(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function cu(e){return"object"==typeof e&&null!=e&&e.outlets}function hu(e,t,a,n,i){let r={};return n&&yd(n,(e,t)=>{r[t]=Array.isArray(e)?e.map(e=>""+e):""+e}),new Sd(a.root===e?t:du(a.root,e,t),r,i)}function du(e,t,a){const n={};return yd(e.children,(e,i)=>{n[i]=e===t?a:du(e,t,a)}),new Td(e.segments,n)}class uu{constructor(e,t,a){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=a,e&&a.length>0&&lu(a[0]))throw new Error("Root segment cannot have matrix parameters");const n=a.find(cu);if(n&&n!==bd(a))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class pu{constructor(e,t,a){this.segmentGroup=e,this.processChildren=t,this.index=a}}function mu(e,t,a){if(e||(e=new Td([],{})),0===e.segments.length&&e.hasChildren())return gu(e,t,a);const n=function(e,t,a){let n=0,i=t;const r={match:!1,pathIndex:0,commandIndex:0};for(;i<e.segments.length;){if(n>=a.length)return r;const t=e.segments[i],s=a[n];if(cu(s))break;const o=""+s,l=n<a.length-1?a[n+1]:null;if(i>0&&void 0===o)break;if(o&&l&&"object"==typeof l&&void 0===l.outlets){if(!wu(o,l,t))return r;n+=2}else{if(!wu(o,{},t))return r;n++}i++}return{match:!0,pathIndex:i,commandIndex:n}}(e,t,a),i=a.slice(n.commandIndex);if(n.match&&n.pathIndex<e.segments.length){const t=new Td(e.segments.slice(0,n.pathIndex),{});return t.children.primary=new Td(e.segments.slice(n.pathIndex),e.children),gu(t,0,i)}return n.match&&0===i.length?new Td(e.segments,{}):n.match&&!e.hasChildren()?fu(e,t,a):n.match?gu(e,0,i):fu(e,t,a)}function gu(e,t,a){if(0===a.length)return new Td(e.segments,{});{const n=function(e){return cu(e[0])?e[0].outlets:{[cd]:e}}(a),i={};return yd(n,(a,n)=>{null!==a&&(i[n]=mu(e.children[n],t,a))}),yd(e.children,(e,t)=>{void 0===n[t]&&(i[t]=e)}),new Td(e.segments,i)}}function fu(e,t,a){const n=e.segments.slice(0,t);let i=0;for(;i<a.length;){const r=a[i];if(cu(r)){const e=bu(r.outlets);return new Td(n,e)}if(0===i&&lu(a[0])){n.push(new Cd(e.segments[t].path,a[0])),i++;continue}const s=cu(r)?r.outlets.primary:""+r,o=i<a.length-1?a[i+1]:null;s&&o&&lu(o)?(n.push(new Cd(s,yu(o))),i+=2):(n.push(new Cd(s,{})),i++)}return new Td(n,{})}function bu(e){const t={};return yd(e,(e,a)=>{null!==e&&(t[a]=fu(new Td([],{}),0,e))}),t}function yu(e){const t={};return yd(e,(e,a)=>t[a]=""+e),t}function wu(e,t,a){return e==a.path&&md(t,a.parameters)}class vu{constructor(e,t,a,n){this.routeReuseStrategy=e,this.futureState=t,this.currState=a,this.forwardEvent=n}activate(e){const t=this.futureState._root,a=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,a,e),iu(this.futureState.root),this.activateChildRoutes(t,a,e)}deactivateChildRoutes(e,t,a){const n=Kd(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,n[t],a),delete n[t]}),yd(n,(e,t)=>{this.deactivateRouteAndItsChildren(e,a)})}deactivateRoutes(e,t,a){const n=e.value,i=t?t.value:null;if(n===i)if(n.component){const i=a.getContext(n.outlet);i&&this.deactivateChildRoutes(e,t,i.children)}else this.deactivateChildRoutes(e,t,a);else i&&this.deactivateRouteAndItsChildren(t,a)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const a=t.getContext(e.value.outlet);if(a&&a.outlet){const t=a.outlet.detach(),n=a.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:n})}}deactivateRouteAndOutlet(e,t){const a=t.getContext(e.value.outlet);if(a){const n=Kd(e),i=e.value.component?a.children:t;yd(n,(e,t)=>this.deactivateRouteAndItsChildren(e,i)),a.outlet&&(a.outlet.deactivate(),a.children.onOutletDeactivated())}}activateChildRoutes(e,t,a){const n=Kd(t);e.children.forEach(e=>{this.activateRoutes(e,n[e.value.outlet],a),this.forwardEvent(new od(e.value.snapshot))}),e.children.length&&this.forwardEvent(new rd(e.value.snapshot))}activateRoutes(e,t,a){const n=e.value,i=t?t.value:null;if(iu(n),n===i)if(n.component){const i=a.getOrCreateContext(n.outlet);this.activateChildRoutes(e,t,i.children)}else this.activateChildRoutes(e,t,a);else if(n.component){const t=a.getOrCreateContext(n.outlet);if(this.routeReuseStrategy.shouldAttach(n.snapshot)){const e=this.routeReuseStrategy.retrieve(n.snapshot);this.routeReuseStrategy.store(n.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),_u(e.route)}else{const a=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(n.snapshot),i=a?a.module.componentFactoryResolver:null;t.attachRef=null,t.route=n,t.resolver=i,t.outlet&&t.outlet.activateWith(n,i),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,a)}}function _u(e){iu(e.value),e.children.forEach(_u)}class xu{constructor(e,t){this.routes=e,this.module=t}}function ku(e){return"function"==typeof e}function Su(e){return e instanceof Sd}const Tu=Symbol("INITIAL_VALUE");function Cu(){return Th(e=>nh(...e.map(e=>e.pipe(Ah(1),Ph(Tu)))).pipe(function(e,t){let a=!1;return arguments.length>=2&&(a=!0),function(n){return n.lift(new Dh(e,t,a))}}((e,t)=>{let a=!1;return t.reduce((e,n,i)=>{if(e!==Tu)return e;if(n===Tu&&(a=!0),!a){if(!1===n)return n;if(i===t.length-1||Su(n))return n}return e},e)},Tu),dh(e=>e!==Tu),C(e=>Su(e)?e:!0===e),Ah(1)))}let Eu=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&as(0,"router-outlet")},directives:function(){return[_p]},encapsulation:2}),e})();function Au(e,t=""){for(let a=0;a<e.length;a++){const n=e[a];Iu(n,Ru(t,n))}}function Iu(e,t){e.children&&Au(e.children,t)}function Ru(e,t){return t?e||t.path?e&&!t.path?e+"/":!e&&t.path?t.path:`${e}/${t.path}`:"":e}function Mu(e){const t=e.children&&e.children.map(Mu),a=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!a.component&&(t||a.loadChildren)&&a.outlet&&a.outlet!==cd&&(a.component=Eu),a}function Pu(e){return e.outlet||cd}class Du{constructor(e){this.segmentGroup=e||null}}class Lu{constructor(e){this.urlTree=e}}function Nu(e){return new y(t=>t.error(new Du(e)))}function Ou(e){return new y(t=>t.error(new Lu(e)))}function ju(e){return new y(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class Wu{constructor(e,t,a,n,i){this.configLoader=t,this.urlSerializer=a,this.urlTree=n,this.config=i,this.allowRedirects=!0,this.ngModule=e.get(Je)}apply(){return this.expandSegmentGroup(this.ngModule,this.config,this.urlTree.root,cd).pipe(C(e=>this.createUrlTree(e,this.urlTree.queryParams,this.urlTree.fragment))).pipe(Nh(e=>{if(e instanceof Lu)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof Du)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,cd).pipe(C(t=>this.createUrlTree(t,e.queryParams,e.fragment))).pipe(Nh(e=>{if(e instanceof Du)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,a){const n=e.segments.length>0?new Td([],{[cd]:e}):e;return new Sd(n,t,a)}expandSegmentGroup(e,t,a,n){return 0===a.segments.length&&a.hasChildren()?this.expandChildren(e,t,a).pipe(C(e=>new Td([],e))):this.expandSegment(e,a,t,a.segments,n,!0)}expandChildren(e,t,a){return function(e,t){if(0===Object.keys(e).length)return Jc({});const a=[],n=[],i={};return yd(e,(e,r)=>{const s=t(r,e).pipe(C(e=>i[r]=e));r===cd?a.push(s):n.push(s)}),Jc.apply(null,a.concat(n)).pipe(hh(),function(e,t){const a=arguments.length>=2;return n=>n.pipe(e?dh((t,a)=>e(t,a,n)):b,gh(1),a?xh(t):yh(()=>new sh))}(),C(()=>i))}(a.children,(a,n)=>this.expandSegmentGroup(e,t,n,a))}expandSegment(e,t,a,n,i,r){const s=function(e){return e.reduce((e,t)=>{const a=Pu(t);return e.has(a)?e.get(a).push(t):e.set(a,[t]),e},new Map)}(a);s.has(i)||s.set(i,[]);const o=a=>O(a).pipe(Wh(s=>this.expandSegmentAgainstRoute(e,t,a,s,n,i,r).pipe(Nh(e=>{if(e instanceof Du)return Jc(null);throw e}))),zh(e=>null!==e),Nh(e=>{if(e instanceof sh||"EmptyError"===e.name){if(this.noLeftoversInUrl(t,n,i))return Jc(new Td([],{}));throw new Du(t)}throw e}));return O(Array.from(s.entries()).map(([e,t])=>{const a=o(t);return e===i?a:a.pipe(C(()=>null),Nh(()=>Jc(null)))})).pipe(e=>e.lift(new ih(void 0)),zh(),C(e=>e.find(e=>null!==e)))}noLeftoversInUrl(e,t,a){return 0===t.length&&!e.children[a]}expandSegmentAgainstRoute(e,t,a,n,i,r,s){return Pu(n)!==r&&""!==n.path?Nu(t):void 0===n.redirectTo?this.matchSegmentAgainstRoute(e,t,n,i):s&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,a,n,i,r):Nu(t)}expandSegmentAgainstRouteUsingRedirect(e,t,a,n,i,r){return"**"===n.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,a,n,r):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,a,n,i,r)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,a,n){const i=this.applyRedirectCommands([],a.redirectTo,{});return a.redirectTo.startsWith("/")?Ou(i):this.lineralizeSegments(a,i).pipe(B(a=>{const i=new Td(a,{});return this.expandSegment(e,i,t,a,n,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,a,n,i,r){const{matched:s,consumedSegments:o,lastChild:l,positionalParamSegments:c}=zu(t,n,i);if(!s)return Nu(t);const h=this.applyRedirectCommands(o,n.redirectTo,c);return n.redirectTo.startsWith("/")?Ou(h):this.lineralizeSegments(n,h).pipe(B(n=>this.expandSegment(e,t,a,n.concat(i.slice(l)),r,!1)))}matchSegmentAgainstRoute(e,t,a,n){if("**"===a.path)return a.loadChildren?this.configLoader.load(e.injector,a).pipe(C(e=>(a._loadedConfig=e,new Td(n,{})))):Jc(new Td(n,{}));const{matched:i,consumedSegments:r,lastChild:s}=zu(t,a,n);if(!i)return Nu(t);const o=n.slice(s);return this.getChildConfig(e,a,n).pipe(B(e=>{const a=e.module,n=e.routes,{segmentGroup:i,slicedSegments:s}=function(e,t,a,n){return a.length>0&&function(e,t,a){return a.some(a=>Gu(e,t,a)&&Pu(a)!==cd)}(e,a,n)?{segmentGroup:Bu(new Td(t,function(e,t){const a={};a.primary=t;for(const n of e)""===n.path&&Pu(n)!==cd&&(a[Pu(n)]=new Td([],{}));return a}(n,new Td(a,e.children)))),slicedSegments:[]}:0===a.length&&function(e,t,a){return a.some(a=>Gu(e,t,a))}(e,a,n)?{segmentGroup:Bu(new Td(e.segments,function(e,t,a,n){const i={};for(const r of a)Gu(e,t,r)&&!n[Pu(r)]&&(i[Pu(r)]=new Td([],{}));return Object.assign(Object.assign({},n),i)}(e,a,n,e.children))),slicedSegments:a}:{segmentGroup:e,slicedSegments:a}}(t,r,o,n);return 0===s.length&&i.hasChildren()?this.expandChildren(a,n,i).pipe(C(e=>new Td(r,e))):0===n.length&&0===s.length?Jc(new Td(r,{})):this.expandSegment(a,i,n,s,cd,!0).pipe(C(e=>new Td(r.concat(e.segments),e.children)))}))}getChildConfig(e,t,a){return t.children?Jc(new xu(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?Jc(t._loadedConfig):this.runCanLoadGuards(e.injector,t,a).pipe(B(a=>a?this.configLoader.load(e.injector,t).pipe(C(e=>(t._loadedConfig=e,e))):function(e){return new y(t=>t.error(ud(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):Jc(new xu([],e))}runCanLoadGuards(e,t,a){const n=t.canLoad;return n&&0!==n.length?Jc(n.map(n=>{const i=e.get(n);let r;if(function(e){return e&&ku(e.canLoad)}(i))r=i.canLoad(t,a);else{if(!ku(i))throw new Error("Invalid CanLoad guard");r=i(t,a)}return wd(r)})).pipe(Cu(),Gh(e=>{if(!Su(e))return;const t=ud(`Redirecting to "${this.urlSerializer.serialize(e)}"`);throw t.url=e,t}),C(e=>!0===e)):Jc(!0)}lineralizeSegments(e,t){let a=[],n=t.root;for(;;){if(a=a.concat(n.segments),0===n.numberOfChildren)return Jc(a);if(n.numberOfChildren>1||!n.children.primary)return ju(e.redirectTo);n=n.children.primary}}applyRedirectCommands(e,t,a){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,a)}applyRedirectCreatreUrlTree(e,t,a,n){const i=this.createSegmentGroup(e,t.root,a,n);return new Sd(i,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const a={};return yd(e,(e,n)=>{if("string"==typeof e&&e.startsWith(":")){const i=e.substring(1);a[n]=t[i]}else a[n]=e}),a}createSegmentGroup(e,t,a,n){const i=this.createSegments(e,t.segments,a,n);let r={};return yd(t.children,(t,i)=>{r[i]=this.createSegmentGroup(e,t,a,n)}),new Td(i,r)}createSegments(e,t,a,n){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,n):this.findOrReturn(t,a))}findPosParam(e,t,a){const n=a[t.path.substring(1)];if(!n)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return n}findOrReturn(e,t){let a=0;for(const n of t){if(n.path===e.path)return t.splice(a),n;a++}return e}}function zu(e,t,a){if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||a.length>0)?{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}:{matched:!0,consumedSegments:[],lastChild:0,positionalParamSegments:{}};const n=(t.matcher||pd)(a,e,t);return n?{matched:!0,consumedSegments:n.consumed,lastChild:n.consumed.length,positionalParamSegments:n.posParams}:{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}}function Bu(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new Td(e.segments.concat(t.segments),t.children)}return e}function Gu(e,t,a){return(!(e.hasChildren()||t.length>0)||"full"!==a.pathMatch)&&""===a.path&&void 0!==a.redirectTo}class Hu{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class Fu{constructor(e,t){this.component=e,this.route=t}}function qu(e,t,a){const n=e._root;return Yu(n,t?t._root:null,a,[n.value])}function Qu(e,t,a){const n=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(n?n.module.injector:a).get(e)}function Yu(e,t,a,n,i={canDeactivateChecks:[],canActivateChecks:[]}){const r=Kd(t);return e.children.forEach(e=>{!function(e,t,a,n,i={canDeactivateChecks:[],canActivateChecks:[]}){const r=e.value,s=t?t.value:null,o=a?a.getContext(e.value.outlet):null;if(s&&r.routeConfig===s.routeConfig){const l=function(e,t,a){if("function"==typeof a)return a(e,t);switch(a){case"pathParamsChange":return!Ed(e.url,t.url);case"pathParamsOrQueryParamsChange":return!Ed(e.url,t.url)||!md(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!ru(e,t)||!md(e.queryParams,t.queryParams);case"paramsChange":default:return!ru(e,t)}}(s,r,r.routeConfig.runGuardsAndResolvers);l?i.canActivateChecks.push(new Hu(n)):(r.data=s.data,r._resolvedData=s._resolvedData),Yu(e,t,r.component?o?o.children:null:a,n,i),l&&o&&o.outlet&&o.outlet.isActivated&&i.canDeactivateChecks.push(new Fu(o.outlet.component,s))}else s&&Uu(t,o,i),i.canActivateChecks.push(new Hu(n)),Yu(e,null,r.component?o?o.children:null:a,n,i)}(e,r[e.value.outlet],a,n.concat([e.value]),i),delete r[e.value.outlet]}),yd(r,(e,t)=>Uu(e,a.getContext(t),i)),i}function Uu(e,t,a){const n=Kd(e),i=e.value;yd(n,(e,n)=>{Uu(e,i.component?t?t.children.getContext(n):null:t,a)}),a.canDeactivateChecks.push(new Fu(i.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,i))}function Vu(e,t){return null!==e&&t&&t(new sd(e)),Jc(!0)}function Ku(e,t){return null!==e&&t&&t(new id(e)),Jc(!0)}function Xu(e,t,a){const n=t.routeConfig?t.routeConfig.canActivate:null;return n&&0!==n.length?Jc(n.map(n=>ch(()=>{const i=Qu(n,t,a);let r;if(function(e){return e&&ku(e.canActivate)}(i))r=wd(i.canActivate(t,e));else{if(!ku(i))throw new Error("Invalid CanActivate guard");r=wd(i(t,e))}return r.pipe(zh())}))).pipe(Cu()):Jc(!0)}function Ju(e,t,a){const n=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>ch(()=>Jc(t.guards.map(i=>{const r=Qu(i,t.node,a);let s;if(function(e){return e&&ku(e.canActivateChild)}(r))s=wd(r.canActivateChild(n,e));else{if(!ku(r))throw new Error("Invalid CanActivateChild guard");s=wd(r(n,e))}return s.pipe(zh())})).pipe(Cu())));return Jc(i).pipe(Cu())}class Zu{}class $u{constructor(e,t,a,n,i,r){this.rootComponentType=e,this.config=t,this.urlTree=a,this.url=n,this.paramsInheritanceStrategy=i,this.relativeLinkResolution=r}recognize(){try{const e=ap(this.urlTree.root,[],[],this.config,this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,cd),a=new eu([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},cd,this.rootComponentType,null,this.urlTree.root,-1,{}),n=new Vd(a,t),i=new tu(this.url,n);return this.inheritParamsAndData(i._root),Jc(i)}catch(e){return new y(t=>t.error(e))}}inheritParamsAndData(e){const t=e.value,a=$d(t,this.paramsInheritanceStrategy);t.params=Object.freeze(a.params),t.data=Object.freeze(a.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,a){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,a)}processChildren(e,t){const a=Ad(t,(t,a)=>this.processSegmentGroup(e,t,a));return function(e){const t={};e.forEach(e=>{const a=t[e.value.outlet];if(a){const t=a.url.map(e=>e.toString()).join("/"),n=e.value.url.map(e=>e.toString()).join("/");throw new Error(`Two segments cannot have the same outlet name: '${t}' and '${n}'.`)}t[e.value.outlet]=e.value})}(a),a.sort((e,t)=>e.value.outlet===cd?-1:t.value.outlet===cd?1:e.value.outlet.localeCompare(t.value.outlet)),a}processSegment(e,t,a,n){for(const r of e)try{return this.processSegmentAgainstRoute(r,t,a,n)}catch(i){if(!(i instanceof Zu))throw i}if(this.noLeftoversInUrl(t,a,n))return[];throw new Zu}noLeftoversInUrl(e,t,a){return 0===t.length&&!e.children[a]}processSegmentAgainstRoute(e,t,a,n){if(e.redirectTo)throw new Zu;if((e.outlet||cd)!==n)throw new Zu;let i,r=[],s=[];if("**"===e.path){const r=a.length>0?bd(a).parameters:{};i=new eu(a,r,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,rp(e),n,e.component,e,ep(t),tp(t)+a.length,sp(e))}else{const o=function(e,t,a){if(""===t.path){if("full"===t.pathMatch&&(e.hasChildren()||a.length>0))throw new Zu;return{consumedSegments:[],lastChild:0,parameters:{}}}const n=(t.matcher||pd)(a,e,t);if(!n)throw new Zu;const i={};yd(n.posParams,(e,t)=>{i[t]=e.path});const r=n.consumed.length>0?Object.assign(Object.assign({},i),n.consumed[n.consumed.length-1].parameters):i;return{consumedSegments:n.consumed,lastChild:n.consumed.length,parameters:r}}(t,e,a);r=o.consumedSegments,s=a.slice(o.lastChild),i=new eu(r,o.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,rp(e),n,e.component,e,ep(t),tp(t)+r.length,sp(e))}const o=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:l,slicedSegments:c}=ap(t,r,s,o,this.relativeLinkResolution);if(0===c.length&&l.hasChildren()){const e=this.processChildren(o,l);return[new Vd(i,e)]}if(0===o.length&&0===c.length)return[new Vd(i,[])];const h=this.processSegment(o,l,c,cd);return[new Vd(i,h)]}}function ep(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function tp(e){let t=e,a=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,a+=t._segmentIndexShift?t._segmentIndexShift:0;return a-1}function ap(e,t,a,n,i){if(a.length>0&&function(e,t,a){return a.some(a=>np(e,t,a)&&ip(a)!==cd)}(e,a,n)){const i=new Td(t,function(e,t,a,n){const i={};i.primary=n,n._sourceSegment=e,n._segmentIndexShift=t.length;for(const r of a)if(""===r.path&&ip(r)!==cd){const a=new Td([],{});a._sourceSegment=e,a._segmentIndexShift=t.length,i[ip(r)]=a}return i}(e,t,n,new Td(a,e.children)));return i._sourceSegment=e,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:[]}}if(0===a.length&&function(e,t,a){return a.some(a=>np(e,t,a))}(e,a,n)){const r=new Td(e.segments,function(e,t,a,n,i,r){const s={};for(const o of n)if(np(e,a,o)&&!i[ip(o)]){const a=new Td([],{});a._sourceSegment=e,a._segmentIndexShift="legacy"===r?e.segments.length:t.length,s[ip(o)]=a}return Object.assign(Object.assign({},i),s)}(e,t,a,n,e.children,i));return r._sourceSegment=e,r._segmentIndexShift=t.length,{segmentGroup:r,slicedSegments:a}}const r=new Td(e.segments,e.children);return r._sourceSegment=e,r._segmentIndexShift=t.length,{segmentGroup:r,slicedSegments:a}}function np(e,t,a){return(!(e.hasChildren()||t.length>0)||"full"!==a.pathMatch)&&""===a.path&&void 0===a.redirectTo}function ip(e){return e.outlet||cd}function rp(e){return e.data||{}}function sp(e){return e.resolve||{}}function op(e){return function(t){return t.pipe(Th(t=>{const a=e(t);return a?O(a).pipe(C(()=>t)):O([t])}))}}class lp extends class{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}{}const cp=new Ne("ROUTES");class hp{constructor(e,t,a,n){this.loader=e,this.compiler=t,this.onLoadStartListener=a,this.onLoadEndListener=n}load(e,t){return this.onLoadStartListener&&this.onLoadStartListener(t),this.loadModuleFactory(t.loadChildren).pipe(C(a=>{this.onLoadEndListener&&this.onLoadEndListener(t);const n=a.create(e);return new xu(fd(n.injector.get(cp)).map(Mu),n)}))}loadModuleFactory(e){return"string"==typeof e?O(this.loader.load(e)):wd(e()).pipe(B(e=>e instanceof Ze?Jc(e):O(this.compiler.compileModuleAsync(e))))}}class dp{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new up,this.attachRef=null}}class up{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const a=this.getOrCreateContext(e);a.outlet=t,this.contexts.set(e,a)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new dp,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}class pp{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function mp(e){throw e}function gp(e,t,a){return t.parse("/")}function fp(e,t){return Jc(null)}let bp=(()=>{class e{constructor(e,t,a,n,i,r,s,o){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=a,this.location=n,this.config=o,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.lastLocationChangeInfo=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new k,this.errorHandler=mp,this.malformedUriErrorHandler=gp,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:fp,afterPreactivation:fp},this.urlHandlingStrategy=new pp,this.routeReuseStrategy=new lp,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.ngModule=i.get(Je),this.console=i.get(Xo);const l=i.get(cl);this.isNgZoneEnabled=l instanceof cl,this.resetConfig(o),this.currentUrlTree=new Sd(new Td([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new hp(r,s,e=>this.triggerEvent(new ad(e)),e=>this.triggerEvent(new nd(e))),this.routerState=Jd(this.currentUrlTree,this.rootComponentType),this.transitions=new Zc({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(dh(e=>0!==e.id),C(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),Th(e=>{let a=!1,n=!1;return Jc(e).pipe(Gh(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Th(e=>{const a=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||a)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return Jc(e).pipe(Th(e=>{const a=this.transitions.getValue();return t.next(new Uh(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),a!==this.transitions.getValue()?oh:[e]}),Th(e=>Promise.resolve(e)),(n=this.ngModule.injector,i=this.configLoader,r=this.urlSerializer,s=this.config,function(e){return e.pipe(Th(e=>function(e,t,a,n,i){return new Wu(e,t,a,n,i).apply()}(n,i,r,e.extractedUrl,s).pipe(C(t=>Object.assign(Object.assign({},e),{urlAfterRedirects:t})))))}),Gh(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,a,n,i){return function(r){return r.pipe(B(r=>function(e,t,a,n,i="emptyOnly",r="legacy"){return new $u(e,t,a,n,i,r).recognize()}(e,t,r.urlAfterRedirects,a(r.urlAfterRedirects),n,i).pipe(C(e=>Object.assign(Object.assign({},r),{targetSnapshot:e})))))}}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),Gh(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,!!e.extras.replaceUrl,e.id,e.extras.state),this.browserUrlTree=e.urlAfterRedirects)}),Gh(e=>{const a=new Jh(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(a)}));var n,i,r,s;if(a&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:a,extractedUrl:n,source:i,restoredState:r,extras:s}=e,o=new Uh(a,this.serializeUrl(n),i,r);t.next(o);const l=Jd(n,this.rootComponentType).snapshot;return Jc(Object.assign(Object.assign({},e),{targetSnapshot:l,urlAfterRedirects:n,extras:Object.assign(Object.assign({},s),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),oh}),op(e=>{const{targetSnapshot:t,id:a,extractedUrl:n,rawUrl:i,extras:{skipLocationChange:r,replaceUrl:s}}=e;return this.hooks.beforePreactivation(t,{navigationId:a,appliedUrlTree:n,rawUrlTree:i,skipLocationChange:!!r,replaceUrl:!!s})}),Gh(e=>{const t=new Zh(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),C(e=>Object.assign(Object.assign({},e),{guards:qu(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return function(a){return a.pipe(B(a=>{const{targetSnapshot:n,currentSnapshot:i,guards:{canActivateChecks:r,canDeactivateChecks:s}}=a;return 0===s.length&&0===r.length?Jc(Object.assign(Object.assign({},a),{guardsResult:!0})):function(e,t,a,n){return O(e).pipe(B(e=>function(e,t,a,n,i){const r=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return r&&0!==r.length?Jc(r.map(r=>{const s=Qu(r,t,i);let o;if(function(e){return e&&ku(e.canDeactivate)}(s))o=wd(s.canDeactivate(e,t,a,n));else{if(!ku(s))throw new Error("Invalid CanDeactivate guard");o=wd(s(e,t,a,n))}return o.pipe(zh())})).pipe(Cu()):Jc(!0)}(e.component,e.route,a,t,n)),zh(e=>!0!==e,!0))}(s,n,i,e).pipe(B(a=>a&&"boolean"==typeof a?function(e,t,a,n){return O(t).pipe(Wh(t=>O([Ku(t.route.parent,n),Vu(t.route,n),Ju(e,t.path,a),Xu(e,t.route,a)]).pipe(hh(),zh(e=>!0!==e,!0))),zh(e=>!0!==e,!0))}(n,r,e,t):Jc(a)),C(e=>Object.assign(Object.assign({},a),{guardsResult:e})))}))}}(this.ngModule.injector,e=>this.triggerEvent(e)),Gh(e=>{if(Su(e.guardsResult)){const t=ud(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}}),Gh(e=>{const t=new $h(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),dh(e=>{if(!e.guardsResult){this.resetUrlToCurrentUrlTree();const a=new Kh(e.id,this.serializeUrl(e.extractedUrl),"");return t.next(a),e.resolve(!1),!1}return!0}),op(e=>{if(e.guards.canActivateChecks.length)return Jc(e).pipe(Gh(e=>{const t=new ed(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),Th(e=>{let a=!1;return Jc(e).pipe((n=this.paramsInheritanceStrategy,i=this.ngModule.injector,function(e){return e.pipe(B(e=>{const{targetSnapshot:t,guards:{canActivateChecks:a}}=e;if(!a.length)return Jc(e);let r=0;return O(a).pipe(Wh(e=>function(e,t,a,n){return function(e,t,a,n){const i=Object.keys(e);if(0===i.length)return Jc({});const r={};return O(i).pipe(B(i=>function(e,t,a,n){const i=Qu(e,t,n);return wd(i.resolve?i.resolve(t,a):i(t,a))}(e[i],t,a,n).pipe(Gh(e=>{r[i]=e}))),gh(1),B(()=>Object.keys(r).length===i.length?Jc(r):oh))}(e._resolve,e,t,n).pipe(C(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),$d(e,a).resolve),null)))}(e.route,t,n,i)),Gh(()=>r++),gh(1),B(t=>r===a.length?Jc(e):oh))}))}),Gh({next:()=>a=!0,complete:()=>{if(!a){const a=new Kh(e.id,this.serializeUrl(e.extractedUrl),"At least one route resolver didn't emit any value.");t.next(a),e.resolve(!1)}}}));var n,i}),Gh(e=>{const t=new td(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}))}),op(e=>{const{targetSnapshot:t,id:a,extractedUrl:n,rawUrl:i,extras:{skipLocationChange:r,replaceUrl:s}}=e;return this.hooks.afterPreactivation(t,{navigationId:a,appliedUrlTree:n,rawUrlTree:i,skipLocationChange:!!r,replaceUrl:!!s})}),C(e=>{const t=function(e,t,a){const n=su(e,t._root,a?a._root:void 0);return new Xd(n,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),Gh(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!e.extras.replaceUrl,e.id,e.extras.state),this.browserUrlTree=e.urlAfterRedirects)}),(r=this.rootContexts,s=this.routeReuseStrategy,o=e=>this.triggerEvent(e),C(e=>(new vu(s,e.targetRouterState,e.currentRouterState,o).activate(r),e))),Gh({next(){a=!0},complete(){a=!0}}),(i=()=>{if(!a&&!n){this.resetUrlToCurrentUrlTree();const a=new Kh(e.id,this.serializeUrl(e.extractedUrl),`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`);t.next(a),e.resolve(!1)}this.currentNavigation=null},e=>e.lift(new qh(i))),Nh(a=>{if(n=!0,(i=a)&&i.ngNavigationCancelingError){const n=Su(a.url);n||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const i=new Kh(e.id,this.serializeUrl(e.extractedUrl),a.message);t.next(i),n?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(a.url,this.rawUrlTree);return this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const n=new Xh(e.id,this.serializeUrl(e.extractedUrl),a);t.next(n);try{e.resolve(this.errorHandler(a))}catch(r){e.reject(r)}}var i;return oh}));var i,r,s,o}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const t=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,t)&&setTimeout(()=>{const{source:e,state:a,urlTree:n}=t,i={replaceUrl:!0};if(a){const e=Object.assign({},a);delete e.navigationId,0!==Object.keys(e).length&&(i.state=e)}this.scheduleNavigation(n,e,a,i)},0),this.lastLocationChangeInfo=t}))}extractLocationChangeInfoFromEvent(e){var t;return{source:"popstate"===e.type?"popstate":"hashchange",urlTree:this.parseUrl(e.url),state:(null===(t=e.state)||void 0===t?void 0:t.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,t){if(!e)return!0;const a=t.urlTree.toString()===e.urlTree.toString();return!(t.transitionId===e.transitionId&&a&&("hashchange"===t.source&&"popstate"===e.source||"popstate"===t.source&&"hashchange"===e.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){Au(e),this.config=e.map(Mu),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0)}createUrlTree(e,t={}){const{relativeTo:a,queryParams:n,fragment:i,queryParamsHandling:r,preserveFragment:s}=t,o=a||this.routerState.root,l=s?this.currentUrlTree.fragment:i;let c=null;switch(r){case"merge":c=Object.assign(Object.assign({},this.currentUrlTree.queryParams),n);break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=n||null}return null!==c&&(c=this.removeEmptyProps(c)),function(e,t,a,n,i){if(0===a.length)return hu(t.root,t.root,t,n,i);const r=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new uu(!0,0,e);let t=0,a=!1;const n=e.reduce((e,n,i)=>{if("object"==typeof n&&null!=n){if(n.outlets){const t={};return yd(n.outlets,(e,a)=>{t[a]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(n.segmentPath)return[...e,n.segmentPath]}return"string"!=typeof n?[...e,n]:0===i?(n.split("/").forEach((n,i)=>{0==i&&"."===n||(0==i&&""===n?a=!0:".."===n?t++:""!=n&&e.push(n))}),e):[...e,n]},[]);return new uu(a,t,n)}(a);if(r.toRoot())return hu(t.root,new Td([],{}),t,n,i);const s=function(e,t,a){if(e.isAbsolute)return new pu(t.root,!0,0);if(-1===a.snapshot._lastPathIndex){const e=a.snapshot._urlSegment;return new pu(e,e===t.root,0)}const n=lu(e.commands[0])?0:1;return function(e,t,a){let n=e,i=t,r=a;for(;r>i;){if(r-=i,n=n.parent,!n)throw new Error("Invalid number of '../'");i=n.segments.length}return new pu(n,!1,i-r)}(a.snapshot._urlSegment,a.snapshot._lastPathIndex+n,e.numberOfDoubleDots)}(r,t,e),o=s.processChildren?gu(s.segmentGroup,s.index,r.commands):mu(s.segmentGroup,s.index,r.commands);return hu(s.segmentGroup,o,t,n,i)}(o,this.currentUrlTree,e,c,l)}navigateByUrl(e,t={skipLocationChange:!1}){const a=Su(e)?e:this.parseUrl(e),n=this.urlHandlingStrategy.merge(a,this.rawUrlTree);return this.scheduleNavigation(n,"imperative",null,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const a=e[t];if(null==a)throw new Error(`The requested path contains ${a} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(a){t=this.malformedUriErrorHandler(a,this.urlSerializer,e)}return t}isActive(e,t){if(Su(e))return vd(this.currentUrlTree,e,t);const a=this.parseUrl(e);return vd(this.currentUrlTree,a,t)}removeEmptyProps(e){return Object.keys(e).reduce((t,a)=>{const n=e[a];return null!=n&&(t[a]=n),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.events.next(new Vh(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.currentNavigation=null,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,a,n,i){const r=this.getTransition(),s="imperative"!==t&&"imperative"===(null==r?void 0:r.source),o=(this.lastSuccessfulId===r.id||this.currentNavigation?r.rawUrl:r.urlAfterRedirects).toString()===e.toString();if(s&&o)return Promise.resolve(!0);let l,c,h;i?(l=i.resolve,c=i.reject,h=i.promise):h=new Promise((e,t)=>{l=e,c=t});const d=++this.navigationId;return this.setTransition({id:d,source:t,restoredState:a,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:n,resolve:l,reject:c,promise:h,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),h.catch(e=>Promise.reject(e))}setBrowserUrl(e,t,a,n){const i=this.urlSerializer.serialize(e);n=n||{},this.location.isCurrentPathEqualTo(i)||t?this.location.replaceState(i,"",Object.assign(Object.assign({},n),{navigationId:a})):this.location.go(i,"",Object.assign(Object.assign({},n),{navigationId:a}))}resetStateAndUrl(e,t,a){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,a),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return e.\u0275fac=function(t){return new(t||e)(Ye(wr),Ye(Id),Ye(up),Ye(tc),Ye(Dr),Ye(Rl),Ye(sl),Ye(void 0))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),yp=(()=>{class e{constructor(e,t,a,n,i){this.router=e,this.route=t,this.commands=[],this.onChanges=new k,null==a&&n.setAttribute(i.nativeElement,"tabindex","0")}ngOnChanges(e){this.onChanges.next(this)}set routerLink(e){this.commands=null!=e?Array.isArray(e)?e:[e]:[]}onClick(){const e={skipLocationChange:vp(this.skipLocationChange),replaceUrl:vp(this.replaceUrl),state:this.state};return this.router.navigateByUrl(this.urlTree,e),!0}get urlTree(){return this.router.createUrlTree(this.commands,{relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:vp(this.preserveFragment)})}}return e.\u0275fac=function(t){return new(t||e)(Xr(bp),Xr(Zd),Jr("tabindex"),Xr(qs),Xr(Bs))},e.\u0275dir=yt({type:e,selectors:[["","routerLink","",5,"a",5,"area"]],hostBindings:function(e,t){1&e&&os("click",function(){return t.onClick()})},inputs:{routerLink:"routerLink",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",preserveFragment:"preserveFragment",skipLocationChange:"skipLocationChange",replaceUrl:"replaceUrl",state:"state"},features:[Bt]}),e})(),wp=(()=>{class e{constructor(e,t,a){this.router=e,this.route=t,this.locationStrategy=a,this.commands=[],this.onChanges=new k,this.subscription=e.events.subscribe(e=>{e instanceof Vh&&this.updateTargetUrlAndHref()})}set routerLink(e){this.commands=null!=e?Array.isArray(e)?e:[e]:[]}ngOnChanges(e){this.updateTargetUrlAndHref(),this.onChanges.next(this)}ngOnDestroy(){this.subscription.unsubscribe()}onClick(e,t,a,n,i){if(0!==e||t||a||n||i)return!0;if("string"==typeof this.target&&"_self"!=this.target)return!0;const r={skipLocationChange:vp(this.skipLocationChange),replaceUrl:vp(this.replaceUrl),state:this.state};return this.router.navigateByUrl(this.urlTree,r),!1}updateTargetUrlAndHref(){this.href=this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree))}get urlTree(){return this.router.createUrlTree(this.commands,{relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:vp(this.preserveFragment)})}}return e.\u0275fac=function(t){return new(t||e)(Xr(bp),Xr(Zd),Xr(Xl))},e.\u0275dir=yt({type:e,selectors:[["a","routerLink",""],["area","routerLink",""]],hostVars:2,hostBindings:function(e,t){1&e&&os("click",function(e){return t.onClick(e.button,e.ctrlKey,e.shiftKey,e.altKey,e.metaKey)}),2&e&&(As("href",t.href,Tn),Vr("target",t.target))},inputs:{routerLink:"routerLink",target:"target",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",preserveFragment:"preserveFragment",skipLocationChange:"skipLocationChange",replaceUrl:"replaceUrl",state:"state"},features:[Bt]}),e})();function vp(e){return""===e||!!e}let _p=(()=>{class e{constructor(e,t,a,n,i){this.parentContexts=e,this.location=t,this.resolver=a,this.changeDetector=i,this.activated=null,this._activatedRoute=null,this.activateEvents=new To,this.deactivateEvents=new To,this.name=n||cd,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const a=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),n=this.parentContexts.getOrCreateContext(this.name).children,i=new xp(e,n,this.location.injector);this.activated=this.location.createComponent(a,this.location.length,i),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(Xr(up),Xr(po),Xr(zs),Jr("name"),Xr(br))},e.\u0275dir=yt({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class xp{constructor(e,t,a){this.route=e,this.childContexts=t,this.parent=a}get(e,t){return e===Zd?this.route:e===up?this.childContexts:this.parent.get(e,t)}}class kp{}class Sp{preload(e,t){return Jc(null)}}let Tp=(()=>{class e{constructor(e,t,a,n,i){this.router=e,this.injector=n,this.preloadingStrategy=i,this.loader=new hp(t,a,t=>e.triggerEvent(new ad(t)),t=>e.triggerEvent(new nd(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(dh(e=>e instanceof Vh),Wh(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(Je);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,t){const a=[];for(const n of t)if(n.loadChildren&&!n.canLoad&&n._loadedConfig){const e=n._loadedConfig;a.push(this.processRoutes(e.module,e.routes))}else n.loadChildren&&!n.canLoad?a.push(this.preloadConfig(e,n)):n.children&&a.push(this.processRoutes(e,n.children));return O(a).pipe(F(),C(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>this.loader.load(e.injector,t).pipe(B(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(Ye(bp),Ye(Rl),Ye(sl),Ye(Dr),Ye(kp))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),Cp=(()=>{class e{constructor(e,t,a={}){this.router=e,this.viewportScroller=t,this.options=a,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},a.scrollPositionRestoration=a.scrollPositionRestoration||"disabled",a.anchorScrolling=a.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Uh?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Vh&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof ld&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new ld(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(t){return new(t||e)(Ye(bp),Ye(vc),Ye(void 0))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const Ep=new Ne("ROUTER_CONFIGURATION"),Ap=new Ne("ROUTER_FORROOT_GUARD"),Ip=[tc,{provide:Id,useClass:Rd},{provide:bp,useFactory:function(e,t,a,n,i,r,s,o={},l,c){const h=new bp(null,e,t,a,n,i,r,fd(s));if(l&&(h.urlHandlingStrategy=l),c&&(h.routeReuseStrategy=c),function(e,t){e.errorHandler&&(t.errorHandler=e.errorHandler),e.malformedUriErrorHandler&&(t.malformedUriErrorHandler=e.malformedUriErrorHandler),e.onSameUrlNavigation&&(t.onSameUrlNavigation=e.onSameUrlNavigation),e.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=e.paramsInheritanceStrategy),e.relativeLinkResolution&&(t.relativeLinkResolution=e.relativeLinkResolution),e.urlUpdateStrategy&&(t.urlUpdateStrategy=e.urlUpdateStrategy)}(o,h),o.enableTracing){const e=zl();h.events.subscribe(t=>{e.logGroup("Router Event: "+t.constructor.name),e.log(t.toString()),e.log(t),e.logGroupEnd()})}return h},deps:[Id,up,tc,Dr,Rl,sl,cp,Ep,[class{},new ne],[class{},new ne]]},up,{provide:Zd,useFactory:function(e){return e.routerState.root},deps:[bp]},{provide:Rl,useClass:Dl},Tp,Sp,class{preload(e,t){return t().pipe(Nh(()=>Jc(null)))}},{provide:Ep,useValue:{enableTracing:!1}}];function Rp(){return new kl("Router",bp)}let Mp=(()=>{class e{constructor(e,t){}static forRoot(t,a){return{ngModule:e,providers:[Ip,Np(t),{provide:Ap,useFactory:Lp,deps:[[bp,new ne,new re]]},{provide:Ep,useValue:a||{}},{provide:Xl,useFactory:Dp,deps:[Gl,[new ae(Zl),new ne],Ep]},{provide:Cp,useFactory:Pp,deps:[bp,vc,Ep]},{provide:kp,useExisting:a&&a.preloadingStrategy?a.preloadingStrategy:Sp},{provide:kl,multi:!0,useFactory:Rp},[Op,{provide:Ho,multi:!0,useFactory:jp,deps:[Op]},{provide:zp,useFactory:Wp,deps:[Op]},{provide:Ko,multi:!0,useExisting:zp}]]}}static forChild(t){return{ngModule:e,providers:[Np(t)]}}}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)(Ye(Ap,8),Ye(bp,8))}}),e})();function Pp(e,t,a){return a.scrollOffset&&t.setOffset(a.scrollOffset),new Cp(e,t,a)}function Dp(e,t,a={}){return a.useHash?new ec(e,t):new $l(e,t)}function Lp(e){return"guarded"}function Np(e){return[{provide:Lr,multi:!0,useValue:e},{provide:cp,multi:!0,useValue:e}]}let Op=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.resultOfPreactivationDone=new k}appInitializer(){return this.injector.get(Fl,Promise.resolve(null)).then(()=>{let e=null;const t=new Promise(t=>e=t),a=this.injector.get(bp),n=this.injector.get(Ep);return"disabled"===n.initialNavigation?(a.setUpLocationChangeListener(),e(!0)):"enabled"===n.initialNavigation||"enabledBlocking"===n.initialNavigation?(a.hooks.afterPreactivation=()=>this.initNavigation?Jc(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),a.initialNavigation()):e(!0),t})}bootstrapListener(e){const t=this.injector.get(Ep),a=this.injector.get(Tp),n=this.injector.get(Cp),i=this.injector.get(bp),r=this.injector.get(Al);e===r.components[0]&&("enabledNonBlocking"!==t.initialNavigation&&void 0!==t.initialNavigation||i.initialNavigation(),a.setUpPreloading(),n.init(),i.resetRootComponentType(r.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}}return e.\u0275fac=function(t){return new(t||e)(Ye(Dr))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();function jp(e){return e.appInitializer.bind(e)}function Wp(e){return e.bootstrapListener.bind(e)}const zp=new Ne("Router Initializer");let Bp=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-main"]],decls:21,vars:0,consts:[["src","assets/lab/main.jpg","width","100%","alt","Lab image 2017"]],template:function(e,t){1&e&&(es(0,"p"),Ss(1," Natural language processing allows computers to analyze and \u201cunderstand\u201d human language, by combining advanced computer science algorithms with linguistic knowledge.\n"),ts(),es(2,"p"),Ss(3," In our lab, we work on problems at the forefront of the worldwide academic community. For that we use cutting-edge methods in Machine Learning, Deep Learning and Artificial Intelligence.\n"),ts(),es(4,"p"),Ss(5,"Our research interests include, among others:"),ts(),es(6,"ul"),es(7,"li"),Ss(8," Information extraction and aggregation"),ts(),es(9,"li"),Ss(10," Bias detection and mitigation"),ts(),es(11,"li"),Ss(12," Textual entailment"),ts(),es(13,"li"),Ss(14," Model interpretation"),ts(),es(15,"li"),Ss(16," NLP pipeline for Hebrew"),ts(),ts(),es(17,"p"),Ss(18," We collaborate with leading labs all over the world. We believe in open research, and make our papers, tools, models, and algorithms publicly available to facilitate future research.\n"),ts(),es(19,"p"),as(20,"img",0),ts())},styles:["[_nghost-%COMP%]{margin:40px 0}"]}),e})();const Gp=a("bjCJ"),Hp={};function Fp(e){try{return decodeURIComponent(e.replace(/\\x/g,"%"))}catch(t){return e.replace(/\\x([0-9A-Fa-f]{2,4})/g,function(){return String.fromCharCode(parseInt(arguments[1],16))})}}Gp.forEach(e=>{const t=e.date?e.date.slice(0,4):"";t in Hp||(Hp[t]=[]),Hp[t].push(e),e.authors=e.authors.map(Fp)});const qp=a("WciA"),Qp={},Yp=[];for(const Ww of Object.values(qp))for(const e of Ww){if(Qp[e.name]=e,e.id=e.name.toLowerCase().replace(/ /g,"_"),e.imagePath="image"in e&&!e.image?"unknown":e.id,e.aliases)for(const t of e.aliases)Qp[t]=e;Yp.push(e)}let Up;try{Up="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(jw){Up=!1}let Vp,Kp,Xp=(()=>{class e{constructor(e){this._platformId=e,this.isBrowser=this._platformId?"browser"===this._platformId:"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!Up)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return e.\u0275fac=function(t){return new(t||e)(Ye(Vo))},e.\u0275prov=ce({factory:function(){return new e(Ye(Vo))},token:e,providedIn:"root"}),e})(),Jp=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)}}),e})();function Zp(e){return function(){if(null==Vp&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Vp=!0}))}finally{Vp=Vp||!1}return Vp}()?e:!!e.capture}class $p extends d{constructor(e,t){super()}schedule(e,t=0){return this}}class em extends $p{constructor(e,t){super(e,t),this.scheduler=e,this.work=t,this.pending=!1}schedule(e,t=0){if(this.closed)return this;this.state=e;const a=this.id,n=this.scheduler;return null!=a&&(this.id=this.recycleAsyncId(n,a,t)),this.pending=!0,this.delay=t,this.id=this.id||this.requestAsyncId(n,this.id,t),this}requestAsyncId(e,t,a=0){return setInterval(e.flush.bind(e,this),a)}recycleAsyncId(e,t,a=0){if(null!==a&&this.delay===a&&!1===this.pending)return t;clearInterval(t)}execute(e,t){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const a=this._execute(e,t);if(a)return a;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(e,t){let a=!1,n=void 0;try{this.work(e)}catch(i){a=!0,n=!!i&&i||new Error(i)}if(a)return this.unsubscribe(),n}_unsubscribe(){const e=this.id,t=this.scheduler,a=t.actions,n=a.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==n&&a.splice(n,1),null!=e&&(this.id=this.recycleAsyncId(t,e,null)),this.delay=null}}let tm=(()=>{class e{constructor(t,a=e.now){this.SchedulerAction=t,this.now=a}schedule(e,t=0,a){return new this.SchedulerAction(this,e).schedule(a,t)}}return e.now=()=>Date.now(),e})();class am extends tm{constructor(e,t=tm.now){super(e,()=>am.delegate&&am.delegate!==this?am.delegate.now():t()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(e,t=0,a){return am.delegate&&am.delegate!==this?am.delegate.schedule(e,t,a):super.schedule(e,t,a)}flush(e){const{actions:t}=this;if(this.active)return void t.push(e);let a;this.active=!0;do{if(a=e.execute(e.state,e.delay))break}while(e=t.shift());if(this.active=!1,a){for(;e=t.shift();)e.unsubscribe();throw a}}}const nm=new am(em);class im{constructor(e,t){this.dueTime=e,this.scheduler=t}call(e,t){return t.subscribe(new rm(e,this.dueTime,this.scheduler))}}class rm extends m{constructor(e,t,a){super(e),this.dueTime=t,this.scheduler=a,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(e){this.clearDebounce(),this.lastValue=e,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(sm,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:e}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(e)}}clearDebounce(){const e=this.debouncedSubscription;null!==e&&(this.remove(e),e.unsubscribe(),this.debouncedSubscription=null)}}function sm(e){e.debouncedNext()}function om(e){return null!=e&&""+e!="false"}function lm(e){return Array.isArray(e)?e:[e]}function cm(e){return null==e?"":"string"==typeof e?e:e+"px"}function hm(e){return e instanceof Bs?e.nativeElement:e}let dm=(()=>{class e{create(e){return"undefined"==typeof MutationObserver?null:new MutationObserver(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({factory:function(){return new e},token:e,providedIn:"root"}),e})(),um=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},providers:[dm]}),e})();function pm(e,t){return(e.getAttribute(t)||"").match(/\S+/g)||[]}const mm="cdk-describedby-message-container",gm="cdk-describedby-host";let fm=0;const bm=new Map;let ym=null,wm=(()=>{class e{constructor(e,t){this._platform=t,this._document=e}describe(e,t){this._canBeDescribed(e,t)&&("string"!=typeof t?(this._setMessageId(t),bm.set(t,{messageElement:t,referenceCount:0})):bm.has(t)||this._createMessageElement(t),this._isElementDescribedByMessage(e,t)||this._addMessageReference(e,t))}removeDescription(e,t){if(t&&this._isElementNode(e)){if(this._isElementDescribedByMessage(e,t)&&this._removeMessageReference(e,t),"string"==typeof t){const e=bm.get(t);e&&0===e.referenceCount&&this._deleteMessageElement(t)}ym&&0===ym.childNodes.length&&this._deleteMessagesContainer()}}ngOnDestroy(){const e=this._document.querySelectorAll("[cdk-describedby-host]");for(let t=0;t<e.length;t++)this._removeCdkDescribedByReferenceIds(e[t]),e[t].removeAttribute(gm);ym&&this._deleteMessagesContainer(),bm.clear()}_createMessageElement(e){const t=this._document.createElement("div");this._setMessageId(t),t.textContent=e,this._createMessagesContainer(),ym.appendChild(t),bm.set(e,{messageElement:t,referenceCount:0})}_setMessageId(e){e.id||(e.id="cdk-describedby-message-"+fm++)}_deleteMessageElement(e){const t=bm.get(e),a=t&&t.messageElement;ym&&a&&ym.removeChild(a),bm.delete(e)}_createMessagesContainer(){if(!ym){const e=!this._platform||!this._platform.EDGE&&!this._platform.TRIDENT,t=this._document.getElementById(mm);t&&t.parentNode&&t.parentNode.removeChild(t),ym=this._document.createElement("div"),ym.id=mm,ym.classList.add("cdk-visually-hidden"),ym.setAttribute("aria-hidden",e+""),this._document.body.appendChild(ym)}}_deleteMessagesContainer(){ym&&ym.parentNode&&(ym.parentNode.removeChild(ym),ym=null)}_removeCdkDescribedByReferenceIds(e){const t=pm(e,"aria-describedby").filter(e=>0!=e.indexOf("cdk-describedby-message"));e.setAttribute("aria-describedby",t.join(" "))}_addMessageReference(e,t){const a=bm.get(t);!function(e,t,a){const n=pm(e,t);n.some(e=>e.trim()==a.trim())||(n.push(a.trim()),e.setAttribute(t,n.join(" ")))}(e,"aria-describedby",a.messageElement.id),e.setAttribute(gm,""),a.referenceCount++}_removeMessageReference(e,t){const a=bm.get(t);a.referenceCount--,function(e,t,a){const n=pm(e,t).filter(e=>e!=a.trim());n.length?e.setAttribute(t,n.join(" ")):e.removeAttribute(t)}(e,"aria-describedby",a.messageElement.id),e.removeAttribute(gm)}_isElementDescribedByMessage(e,t){const a=pm(e,"aria-describedby"),n=bm.get(t),i=n&&n.messageElement.id;return!!i&&-1!=a.indexOf(i)}_canBeDescribed(e,t){if(!this._isElementNode(e))return!1;if(t&&"object"==typeof t)return!0;const a=null==t?"":(""+t).trim(),n=e.getAttribute("aria-label");return!(!a||n&&n.trim()===a)}_isElementNode(e){return e.nodeType===this._document.ELEMENT_NODE}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl),Ye(Xp))},e.\u0275prov=ce({factory:function(){return new e(Ye(Bl),Ye(Xp))},token:e,providedIn:"root"}),e})();function vm(e){return 0===e.buttons}"undefined"!=typeof Element&&Element;const _m=new Ne("cdk-focus-monitor-default-options"),xm=Zp({passive:!0,capture:!0});let km=(()=>{class e{constructor(e,t,a,n){this._ngZone=e,this._platform=t,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=e=>{if(!this._lastTouchTarget){const t=vm(e)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(t)}},this._documentTouchstartListener=e=>{null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=Sm(e),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650)},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=e=>{const t=Sm(e),a="focus"===e.type?this._onFocus:this._onBlur;for(let n=t;n;n=n.parentElement)a.call(this,e,n)},this._document=a,this._detectionMode=(null==n?void 0:n.detectionMode)||0}monitor(e,t=!1){const a=hm(e);if(!this._platform.isBrowser||1!==a.nodeType)return Jc(null);const n=function(e){if(function(){if(null==Kp){const e="undefined"!=typeof document?document.head:null;Kp=!(!e||!e.createShadowRoot&&!e.attachShadow)}return Kp}()){const t=e.getRootNode?e.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(a)||this._getDocument(),i=this._elementInfo.get(a);if(i)return t&&(i.checkChildren=!0),i.subject;const r={checkChildren:t,subject:new k,rootNode:n};return this._elementInfo.set(a,r),this._registerGlobalListeners(r),r.subject}stopMonitoring(e){const t=hm(e),a=this._elementInfo.get(t);a&&(a.subject.complete(),this._setClasses(t),this._elementInfo.delete(t),this._removeGlobalListeners(a))}focusVia(e,t,a){const n=hm(e);this._setOriginForCurrentEventQueue(t),"function"==typeof n.focus&&n.focus(a)}ngOnDestroy(){this._elementInfo.forEach((e,t)=>this.stopMonitoring(t))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(e,t,a){a?e.classList.add(t):e.classList.remove(t)}_getFocusOrigin(e){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(e)?"touch":"program"}_setClasses(e,t){this._toggleClass(e,"cdk-focused",!!t),this._toggleClass(e,"cdk-touch-focused","touch"===t),this._toggleClass(e,"cdk-keyboard-focused","keyboard"===t),this._toggleClass(e,"cdk-mouse-focused","mouse"===t),this._toggleClass(e,"cdk-program-focused","program"===t)}_setOriginForCurrentEventQueue(e){this._ngZone.runOutsideAngular(()=>{this._origin=e,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(e){const t=Sm(e);return this._lastTouchTarget instanceof Node&&t instanceof Node&&(t===this._lastTouchTarget||t.contains(this._lastTouchTarget))}_onFocus(e,t){const a=this._elementInfo.get(t);if(!a||!a.checkChildren&&t!==Sm(e))return;const n=this._getFocusOrigin(e);this._setClasses(t,n),this._emitOrigin(a.subject,n),this._lastFocusOrigin=n}_onBlur(e,t){const a=this._elementInfo.get(t);!a||a.checkChildren&&e.relatedTarget instanceof Node&&t.contains(e.relatedTarget)||(this._setClasses(t),this._emitOrigin(a.subject,null))}_emitOrigin(e,t){this._ngZone.run(()=>e.next(t))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const t=e.rootNode,a=this._rootNodeFocusListenerCount.get(t)||0;a||this._ngZone.runOutsideAngular(()=>{t.addEventListener("focus",this._rootNodeFocusAndBlurListener,xm),t.addEventListener("blur",this._rootNodeFocusAndBlurListener,xm)}),this._rootNodeFocusListenerCount.set(t,a+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const e=this._getDocument(),t=this._getWindow();e.addEventListener("keydown",this._documentKeydownListener,xm),e.addEventListener("mousedown",this._documentMousedownListener,xm),e.addEventListener("touchstart",this._documentTouchstartListener,xm),t.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(e){const t=e.rootNode;if(this._rootNodeFocusListenerCount.has(t)){const e=this._rootNodeFocusListenerCount.get(t);e>1?this._rootNodeFocusListenerCount.set(t,e-1):(t.removeEventListener("focus",this._rootNodeFocusAndBlurListener,xm),t.removeEventListener("blur",this._rootNodeFocusAndBlurListener,xm),this._rootNodeFocusListenerCount.delete(t))}if(!--this._monitoredElementCount){const e=this._getDocument(),t=this._getWindow();e.removeEventListener("keydown",this._documentKeydownListener,xm),e.removeEventListener("mousedown",this._documentMousedownListener,xm),e.removeEventListener("touchstart",this._documentTouchstartListener,xm),t.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}}return e.\u0275fac=function(t){return new(t||e)(Ye(cl),Ye(Xp),Ye(Bl,8),Ye(_m,8))},e.\u0275prov=ce({factory:function(){return new e(Ye(cl),Ye(Xp),Ye(Bl,8),Ye(_m,8))},token:e,providedIn:"root"}),e})();function Sm(e){return e.composedPath?e.composedPath()[0]:e.target}const Tm="cdk-high-contrast-black-on-white",Cm="cdk-high-contrast-white-on-black",Em="cdk-high-contrast-active";let Am=(()=>{class e{constructor(e,t){this._platform=e,this._document=t}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const t=this._document.defaultView||window,a=t&&t.getComputedStyle?t.getComputedStyle(e):null,n=(a&&a.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(e),n){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(Em),e.remove(Tm),e.remove(Cm);const t=this.getHighContrastMode();1===t?(e.add(Em),e.add(Tm)):2===t&&(e.add(Em),e.add(Cm))}}}return e.\u0275fac=function(t){return new(t||e)(Ye(Xp),Ye(Bl))},e.\u0275prov=ce({factory:function(){return new e(Ye(Xp),Ye(Bl))},token:e,providedIn:"root"}),e})(),Im=(()=>{class e{constructor(e){e._applyBodyHighContrastModeCssClasses()}}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)(Ye(Am))},imports:[[Jp,um]]}),e})();const Rm=new Ne("cdk-dir-doc",{providedIn:"root",factory:function(){return Ue(Bl)}});let Mm=(()=>{class e{constructor(e){if(this.value="ltr",this.change=new To,e){const t=e.documentElement?e.documentElement.dir:null,a=(e.body?e.body.dir:null)||t;this.value="ltr"===a||"rtl"===a?a:"ltr"}}ngOnDestroy(){this.change.complete()}}return e.\u0275fac=function(t){return new(t||e)(Ye(Rm,8))},e.\u0275prov=ce({factory:function(){return new e(Ye(Rm,8))},token:e,providedIn:"root"}),e})(),Pm=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)}}),e})();const Dm=new Us("10.2.7");class Lm{}const Nm="*";function Om(e,t){return{type:7,name:e,definitions:t,options:{}}}function jm(e,t=null){return{type:4,styles:t,timings:e}}function Wm(e,t=null){return{type:2,steps:e,options:t}}function zm(e){return{type:6,styles:e,offset:null}}function Bm(e,t,a){return{type:0,name:e,styles:t,options:a}}function Gm(e){return{type:5,steps:e}}function Hm(e,t,a=null){return{type:1,expr:e,animation:t,options:a}}function Fm(e){Promise.resolve(null).then(e)}class qm{constructor(e=0,t=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this.parentPlayer=null,this.totalTime=e+t}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(e=>e()),this._onDoneFns=[])}onStart(e){this._onStartFns.push(e)}onDone(e){this._onDoneFns.push(e)}onDestroy(e){this._onDestroyFns.push(e)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){Fm(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(e=>e()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(e=>e()),this._onDestroyFns=[])}reset(){}setPosition(e){}getPosition(){return 0}triggerCallback(e){const t="start"==e?this._onStartFns:this._onDoneFns;t.forEach(e=>e()),t.length=0}}class Qm{constructor(e){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=e;let t=0,a=0,n=0;const i=this.players.length;0==i?Fm(()=>this._onFinish()):this.players.forEach(e=>{e.onDone(()=>{++t==i&&this._onFinish()}),e.onDestroy(()=>{++a==i&&this._onDestroy()}),e.onStart(()=>{++n==i&&this._onStart()})}),this.totalTime=this.players.reduce((e,t)=>Math.max(e,t.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(e=>e()),this._onDoneFns=[])}init(){this.players.forEach(e=>e.init())}onStart(e){this._onStartFns.push(e)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(e=>e()),this._onStartFns=[])}onDone(e){this._onDoneFns.push(e)}onDestroy(e){this._onDestroyFns.push(e)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(e=>e.play())}pause(){this.players.forEach(e=>e.pause())}restart(){this.players.forEach(e=>e.restart())}finish(){this._onFinish(),this.players.forEach(e=>e.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(e=>e.destroy()),this._onDestroyFns.forEach(e=>e()),this._onDestroyFns=[])}reset(){this.players.forEach(e=>e.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(e){const t=e*this.totalTime;this.players.forEach(e=>{const a=e.totalTime?Math.min(1,t/e.totalTime):1;e.setPosition(a)})}getPosition(){let e=0;return this.players.forEach(t=>{const a=t.getPosition();e=Math.min(a,e)}),e}beforeDestroy(){this.players.forEach(e=>{e.beforeDestroy&&e.beforeDestroy()})}triggerCallback(e){const t="start"==e?this._onStartFns:this._onDoneFns;t.forEach(e=>e()),t.length=0}}function Ym(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function Um(e){switch(e.length){case 0:return new qm;case 1:return e[0];default:return new Qm(e)}}function Vm(e,t,a,n,i={},r={}){const s=[],o=[];let l=-1,c=null;if(n.forEach(e=>{const a=e.offset,n=a==l,h=n&&c||{};Object.keys(e).forEach(a=>{let n=a,o=e[a];if("offset"!==a)switch(n=t.normalizePropertyName(n,s),o){case"!":o=i[a];break;case Nm:o=r[a];break;default:o=t.normalizeStyleValue(a,n,o,s)}h[n]=o}),n||o.push(h),c=h,l=a}),s.length){const e="\n - ";throw new Error(`Unable to animate due to the following errors:${e}${s.join(e)}`)}return o}function Km(e,t,a,n){switch(t){case"start":e.onStart(()=>n(a&&Xm(a,"start",e)));break;case"done":e.onDone(()=>n(a&&Xm(a,"done",e)));break;case"destroy":e.onDestroy(()=>n(a&&Xm(a,"destroy",e)))}}function Xm(e,t,a){const n=a.totalTime,i=Jm(e.element,e.triggerName,e.fromState,e.toState,t||e.phaseName,null==n?e.totalTime:n,!!a.disabled),r=e._data;return null!=r&&(i._data=r),i}function Jm(e,t,a,n,i="",r=0,s){return{element:e,triggerName:t,fromState:a,toState:n,phaseName:i,totalTime:r,disabled:!!s}}function Zm(e,t,a){let n;return e instanceof Map?(n=e.get(t),n||e.set(t,n=a)):(n=e[t],n||(n=e[t]=a)),n}function $m(e){const t=e.indexOf(":");return[e.substring(1,t),e.substr(t+1)]}let eg=(e,t)=>!1,tg=(e,t)=>!1,ag=(e,t,a)=>[];const ng=Ym();(ng||"undefined"!=typeof Element)&&(eg=(e,t)=>e.contains(t),tg=(()=>{if(ng||Element.prototype.matches)return(e,t)=>e.matches(t);{const e=Element.prototype,t=e.matchesSelector||e.mozMatchesSelector||e.msMatchesSelector||e.oMatchesSelector||e.webkitMatchesSelector;return t?(e,a)=>t.apply(e,[a]):tg}})(),ag=(e,t,a)=>{let n=[];if(a)n.push(...e.querySelectorAll(t));else{const a=e.querySelector(t);a&&n.push(a)}return n});let ig=null,rg=!1;function sg(e){ig||(ig=("undefined"!=typeof document?document.body:null)||{},rg=!!ig.style&&"WebkitAppearance"in ig.style);let t=!0;return ig.style&&!function(e){return"ebkit"==e.substring(1,6)}(e)&&(t=e in ig.style,!t&&rg)&&(t="Webkit"+e.charAt(0).toUpperCase()+e.substr(1)in ig.style),t}const og=tg,lg=eg,cg=ag;function hg(e){const t={};return Object.keys(e).forEach(a=>{const n=a.replace(/([a-z])([A-Z])/g,"$1-$2");t[n]=e[a]}),t}let dg=(()=>{class e{validateStyleProperty(e){return sg(e)}matchesElement(e,t){return og(e,t)}containsElement(e,t){return lg(e,t)}query(e,t,a){return cg(e,t,a)}computeStyle(e,t,a){return a||""}animate(e,t,a,n,i,r=[],s){return new qm(a,n)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})(),ug=(()=>{class e{}return e.NOOP=new dg,e})();const pg="ng-enter",mg="ng-leave",gg="ng-trigger",fg=".ng-trigger",bg="ng-animating",yg=".ng-animating";function wg(e){if("number"==typeof e)return e;const t=e.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:vg(parseFloat(t[1]),t[2])}function vg(e,t){switch(t){case"s":return 1e3*e;default:return e}}function _g(e,t,a){return e.hasOwnProperty("duration")?e:function(e,t,a){let n,i=0,r="";if("string"==typeof e){const a=e.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(`The provided timing value "${e}" is invalid.`),{duration:0,delay:0,easing:""};n=vg(parseFloat(a[1]),a[2]);const s=a[3];null!=s&&(i=vg(parseFloat(s),a[4]));const o=a[5];o&&(r=o)}else n=e;if(!a){let a=!1,r=t.length;n<0&&(t.push("Duration values below 0 are not allowed for this animation step."),a=!0),i<0&&(t.push("Delay values below 0 are not allowed for this animation step."),a=!0),a&&t.splice(r,0,`The provided timing value "${e}" is invalid.`)}return{duration:n,delay:i,easing:r}}(e,t,a)}function xg(e,t={}){return Object.keys(e).forEach(a=>{t[a]=e[a]}),t}function kg(e,t,a={}){if(t)for(let n in e)a[n]=e[n];else xg(e,a);return a}function Sg(e,t,a){return a?t+":"+a+";":""}function Tg(e){let t="";for(let a=0;a<e.style.length;a++){const n=e.style.item(a);t+=Sg(0,n,e.style.getPropertyValue(n))}for(const a in e.style)e.style.hasOwnProperty(a)&&!a.startsWith("_")&&(t+=Sg(0,a.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),e.style[a]));e.setAttribute("style",t)}function Cg(e,t,a){e.style&&(Object.keys(t).forEach(n=>{const i=Lg(n);a&&!a.hasOwnProperty(n)&&(a[n]=e.style[i]),e.style[i]=t[n]}),Ym()&&Tg(e))}function Eg(e,t){e.style&&(Object.keys(t).forEach(t=>{const a=Lg(t);e.style[a]=""}),Ym()&&Tg(e))}function Ag(e){return Array.isArray(e)?1==e.length?e[0]:Wm(e):e}const Ig=new RegExp("{{\\s*(.+?)\\s*}}","g");function Rg(e){let t=[];if("string"==typeof e){let a;for(;a=Ig.exec(e);)t.push(a[1]);Ig.lastIndex=0}return t}function Mg(e,t,a){const n=e.toString(),i=n.replace(Ig,(e,n)=>{let i=t[n];return t.hasOwnProperty(n)||(a.push("Please provide a value for the animation param "+n),i=""),i.toString()});return i==n?e:i}function Pg(e){const t=[];let a=e.next();for(;!a.done;)t.push(a.value),a=e.next();return t}const Dg=/-+([a-z0-9])/g;function Lg(e){return e.replace(Dg,(...e)=>e[1].toUpperCase())}function Ng(e,t){return 0===e||0===t}function Og(e,t,a){const n=Object.keys(a);if(n.length&&t.length){let r=t[0],s=[];if(n.forEach(e=>{r.hasOwnProperty(e)||s.push(e),r[e]=a[e]}),s.length)for(var i=1;i<t.length;i++){let a=t[i];s.forEach(function(t){a[t]=Wg(e,t)})}}return t}function jg(e,t,a){switch(t.type){case 7:return e.visitTrigger(t,a);case 0:return e.visitState(t,a);case 1:return e.visitTransition(t,a);case 2:return e.visitSequence(t,a);case 3:return e.visitGroup(t,a);case 4:return e.visitAnimate(t,a);case 5:return e.visitKeyframes(t,a);case 6:return e.visitStyle(t,a);case 8:return e.visitReference(t,a);case 9:return e.visitAnimateChild(t,a);case 10:return e.visitAnimateRef(t,a);case 11:return e.visitQuery(t,a);case 12:return e.visitStagger(t,a);default:throw new Error("Unable to resolve animation metadata node #"+t.type)}}function Wg(e,t){return window.getComputedStyle(e)[t]}const zg="*";function Bg(e,t){const a=[];return"string"==typeof e?e.split(/\s*,\s*/).forEach(e=>function(e,t,a){if(":"==e[0]){const n=function(e,t){switch(e){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,t)=>parseFloat(t)>parseFloat(e);case":decrement":return(e,t)=>parseFloat(t)<parseFloat(e);default:return t.push(`The transition alias value "${e}" is not supported`),"* => *"}}(e,a);if("function"==typeof n)return void t.push(n);e=n}const n=e.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==n||n.length<4)return a.push(`The provided transition expression "${e}" is not supported`),t;const i=n[1],r=n[2],s=n[3];t.push(Fg(i,s)),"<"!=r[0]||i==zg&&s==zg||t.push(Fg(s,i))}(e,a,t)):a.push(e),a}const Gg=new Set(["true","1"]),Hg=new Set(["false","0"]);function Fg(e,t){const a=Gg.has(e)||Hg.has(e),n=Gg.has(t)||Hg.has(t);return(i,r)=>{let s=e==zg||e==i,o=t==zg||t==r;return!s&&a&&"boolean"==typeof i&&(s=i?Gg.has(e):Hg.has(e)),!o&&n&&"boolean"==typeof r&&(o=r?Gg.has(t):Hg.has(t)),s&&o}}const qg=new RegExp("s*:selfs*,?","g");function Qg(e,t,a){return new Yg(e).build(t,a)}class Yg{constructor(e){this._driver=e}build(e,t){const a=new Ug(t);return this._resetContextStyleTimingState(a),jg(this,Ag(e),a)}_resetContextStyleTimingState(e){e.currentQuerySelector="",e.collectedStyles={},e.collectedStyles[""]={},e.currentTime=0}visitTrigger(e,t){let a=t.queryCount=0,n=t.depCount=0;const i=[],r=[];return"@"==e.name.charAt(0)&&t.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),e.definitions.forEach(e=>{if(this._resetContextStyleTimingState(t),0==e.type){const a=e,n=a.name;n.toString().split(/\s*,\s*/).forEach(e=>{a.name=e,i.push(this.visitState(a,t))}),a.name=n}else if(1==e.type){const i=this.visitTransition(e,t);a+=i.queryCount,n+=i.depCount,r.push(i)}else t.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:e.name,states:i,transitions:r,queryCount:a,depCount:n,options:null}}visitState(e,t){const a=this.visitStyle(e.styles,t),n=e.options&&e.options.params||null;if(a.containsDynamicStyles){const i=new Set,r=n||{};if(a.styles.forEach(e=>{if(Vg(e)){const t=e;Object.keys(t).forEach(e=>{Rg(t[e]).forEach(e=>{r.hasOwnProperty(e)||i.add(e)})})}}),i.size){const a=Pg(i.values());t.errors.push(`state("${e.name}", ...) must define default values for all the following style substitutions: ${a.join(", ")}`)}}return{type:0,name:e.name,style:a,options:n?{params:n}:null}}visitTransition(e,t){t.queryCount=0,t.depCount=0;const a=jg(this,Ag(e.animation),t);return{type:1,matchers:Bg(e.expr,t.errors),animation:a,queryCount:t.queryCount,depCount:t.depCount,options:Kg(e.options)}}visitSequence(e,t){return{type:2,steps:e.steps.map(e=>jg(this,e,t)),options:Kg(e.options)}}visitGroup(e,t){const a=t.currentTime;let n=0;const i=e.steps.map(e=>{t.currentTime=a;const i=jg(this,e,t);return n=Math.max(n,t.currentTime),i});return t.currentTime=n,{type:3,steps:i,options:Kg(e.options)}}visitAnimate(e,t){const a=function(e,t){let a=null;if(e.hasOwnProperty("duration"))a=e;else if("number"==typeof e)return Xg(_g(e,t).duration,0,"");const n=e;if(n.split(/\s+/).some(e=>"{"==e.charAt(0)&&"{"==e.charAt(1))){const e=Xg(0,0,"");return e.dynamic=!0,e.strValue=n,e}return a=a||_g(n,t),Xg(a.duration,a.delay,a.easing)}(e.timings,t.errors);let n;t.currentAnimateTimings=a;let i=e.styles?e.styles:zm({});if(5==i.type)n=this.visitKeyframes(i,t);else{let i=e.styles,r=!1;if(!i){r=!0;const e={};a.easing&&(e.easing=a.easing),i=zm(e)}t.currentTime+=a.duration+a.delay;const s=this.visitStyle(i,t);s.isEmptyStep=r,n=s}return t.currentAnimateTimings=null,{type:4,timings:a,style:n,options:null}}visitStyle(e,t){const a=this._makeStyleAst(e,t);return this._validateStyleAst(a,t),a}_makeStyleAst(e,t){const a=[];Array.isArray(e.styles)?e.styles.forEach(e=>{"string"==typeof e?e==Nm?a.push(e):t.errors.push(`The provided style string value ${e} is not allowed.`):a.push(e)}):a.push(e.styles);let n=!1,i=null;return a.forEach(e=>{if(Vg(e)){const t=e,a=t.easing;if(a&&(i=a,delete t.easing),!n)for(let e in t)if(t[e].toString().indexOf("{{")>=0){n=!0;break}}}),{type:6,styles:a,easing:i,offset:e.offset,containsDynamicStyles:n,options:null}}_validateStyleAst(e,t){const a=t.currentAnimateTimings;let n=t.currentTime,i=t.currentTime;a&&i>0&&(i-=a.duration+a.delay),e.styles.forEach(e=>{"string"!=typeof e&&Object.keys(e).forEach(a=>{if(!this._driver.validateStyleProperty(a))return void t.errors.push(`The provided animation property "${a}" is not a supported CSS property for animations`);const r=t.collectedStyles[t.currentQuerySelector],s=r[a];let o=!0;s&&(i!=n&&i>=s.startTime&&n<=s.endTime&&(t.errors.push(`The CSS property "${a}" that exists between the times of "${s.startTime}ms" and "${s.endTime}ms" is also being animated in a parallel animation between the times of "${i}ms" and "${n}ms"`),o=!1),i=s.startTime),o&&(r[a]={startTime:i,endTime:n}),t.options&&function(e,t,a){const n=t.params||{},i=Rg(e);i.length&&i.forEach(e=>{n.hasOwnProperty(e)||a.push(`Unable to resolve the local animation param ${e} in the given list of values`)})}(e[a],t.options,t.errors)})})}visitKeyframes(e,t){const a={type:5,styles:[],options:null};if(!t.currentAnimateTimings)return t.errors.push("keyframes() must be placed inside of a call to animate()"),a;let n=0;const i=[];let r=!1,s=!1,o=0;const l=e.steps.map(e=>{const a=this._makeStyleAst(e,t);let l=null!=a.offset?a.offset:function(e){if("string"==typeof e)return null;let t=null;if(Array.isArray(e))e.forEach(e=>{if(Vg(e)&&e.hasOwnProperty("offset")){const a=e;t=parseFloat(a.offset),delete a.offset}});else if(Vg(e)&&e.hasOwnProperty("offset")){const a=e;t=parseFloat(a.offset),delete a.offset}return t}(a.styles),c=0;return null!=l&&(n++,c=a.offset=l),s=s||c<0||c>1,r=r||c<o,o=c,i.push(c),a});s&&t.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),r&&t.errors.push("Please ensure that all keyframe offsets are in order");const c=e.steps.length;let h=0;n>0&&n<c?t.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==n&&(h=1/(c-1));const d=c-1,u=t.currentTime,p=t.currentAnimateTimings,m=p.duration;return l.forEach((e,n)=>{const r=h>0?n==d?1:h*n:i[n],s=r*m;t.currentTime=u+p.delay+s,p.duration=s,this._validateStyleAst(e,t),e.offset=r,a.styles.push(e)}),a}visitReference(e,t){return{type:8,animation:jg(this,Ag(e.animation),t),options:Kg(e.options)}}visitAnimateChild(e,t){return t.depCount++,{type:9,options:Kg(e.options)}}visitAnimateRef(e,t){return{type:10,animation:this.visitReference(e.animation,t),options:Kg(e.options)}}visitQuery(e,t){const a=t.currentQuerySelector,n=e.options||{};t.queryCount++,t.currentQuery=e;const[i,r]=function(e){const t=!!e.split(/\s*,\s*/).find(e=>":self"==e);return t&&(e=e.replace(qg,"")),[e=e.replace(/@\*/g,fg).replace(/@\w+/g,e=>".ng-trigger-"+e.substr(1)).replace(/:animating/g,yg),t]}(e.selector);t.currentQuerySelector=a.length?a+" "+i:i,Zm(t.collectedStyles,t.currentQuerySelector,{});const s=jg(this,Ag(e.animation),t);return t.currentQuery=null,t.currentQuerySelector=a,{type:11,selector:i,limit:n.limit||0,optional:!!n.optional,includeSelf:r,animation:s,originalSelector:e.selector,options:Kg(e.options)}}visitStagger(e,t){t.currentQuery||t.errors.push("stagger() can only be used inside of query()");const a="full"===e.timings?{duration:0,delay:0,easing:"full"}:_g(e.timings,t.errors,!0);return{type:12,animation:jg(this,Ag(e.animation),t),timings:a,options:null}}}class Ug{constructor(e){this.errors=e,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function Vg(e){return!Array.isArray(e)&&"object"==typeof e}function Kg(e){var t;return e?(e=xg(e)).params&&(e.params=(t=e.params)?xg(t):null):e={},e}function Xg(e,t,a){return{duration:e,delay:t,easing:a}}function Jg(e,t,a,n,i,r,s=null,o=!1){return{type:1,element:e,keyframes:t,preStyleProps:a,postStyleProps:n,duration:i,delay:r,totalTime:i+r,easing:s,subTimeline:o}}class Zg{constructor(){this._map=new Map}consume(e){let t=this._map.get(e);return t?this._map.delete(e):t=[],t}append(e,t){let a=this._map.get(e);a||this._map.set(e,a=[]),a.push(...t)}has(e){return this._map.has(e)}clear(){this._map.clear()}}const $g=new RegExp(":enter","g"),ef=new RegExp(":leave","g");function tf(e,t,a,n,i,r={},s={},o,l,c=[]){return(new af).buildKeyframes(e,t,a,n,i,r,s,o,l,c)}class af{buildKeyframes(e,t,a,n,i,r,s,o,l,c=[]){l=l||new Zg;const h=new rf(e,t,l,n,i,c,[]);h.options=o,h.currentTimeline.setStyles([r],null,h.errors,o),jg(this,a,h);const d=h.timelines.filter(e=>e.containsAnimation());if(d.length&&Object.keys(s).length){const e=d[d.length-1];e.allowOnlyTimelineStyles()||e.setStyles([s],null,h.errors,o)}return d.length?d.map(e=>e.buildKeyframes()):[Jg(t,[],[],[],0,0,"",!1)]}visitTrigger(e,t){}visitState(e,t){}visitTransition(e,t){}visitAnimateChild(e,t){const a=t.subInstructions.consume(t.element);if(a){const n=t.createSubContext(e.options),i=t.currentTimeline.currentTime,r=this._visitSubInstructions(a,n,n.options);i!=r&&t.transformIntoNewTimeline(r)}t.previousNode=e}visitAnimateRef(e,t){const a=t.createSubContext(e.options);a.transformIntoNewTimeline(),this.visitReference(e.animation,a),t.transformIntoNewTimeline(a.currentTimeline.currentTime),t.previousNode=e}_visitSubInstructions(e,t,a){let n=t.currentTimeline.currentTime;const i=null!=a.duration?wg(a.duration):null,r=null!=a.delay?wg(a.delay):null;return 0!==i&&e.forEach(e=>{const a=t.appendInstructionToTimeline(e,i,r);n=Math.max(n,a.duration+a.delay)}),n}visitReference(e,t){t.updateOptions(e.options,!0),jg(this,e.animation,t),t.previousNode=e}visitSequence(e,t){const a=t.subContextCount;let n=t;const i=e.options;if(i&&(i.params||i.delay)&&(n=t.createSubContext(i),n.transformIntoNewTimeline(),null!=i.delay)){6==n.previousNode.type&&(n.currentTimeline.snapshotCurrentStyles(),n.previousNode=nf);const e=wg(i.delay);n.delayNextStep(e)}e.steps.length&&(e.steps.forEach(e=>jg(this,e,n)),n.currentTimeline.applyStylesToKeyframe(),n.subContextCount>a&&n.transformIntoNewTimeline()),t.previousNode=e}visitGroup(e,t){const a=[];let n=t.currentTimeline.currentTime;const i=e.options&&e.options.delay?wg(e.options.delay):0;e.steps.forEach(r=>{const s=t.createSubContext(e.options);i&&s.delayNextStep(i),jg(this,r,s),n=Math.max(n,s.currentTimeline.currentTime),a.push(s.currentTimeline)}),a.forEach(e=>t.currentTimeline.mergeTimelineCollectedStyles(e)),t.transformIntoNewTimeline(n),t.previousNode=e}_visitTiming(e,t){if(e.dynamic){const a=e.strValue;return _g(t.params?Mg(a,t.params,t.errors):a,t.errors)}return{duration:e.duration,delay:e.delay,easing:e.easing}}visitAnimate(e,t){const a=t.currentAnimateTimings=this._visitTiming(e.timings,t),n=t.currentTimeline;a.delay&&(t.incrementTime(a.delay),n.snapshotCurrentStyles());const i=e.style;5==i.type?this.visitKeyframes(i,t):(t.incrementTime(a.duration),this.visitStyle(i,t),n.applyStylesToKeyframe()),t.currentAnimateTimings=null,t.previousNode=e}visitStyle(e,t){const a=t.currentTimeline,n=t.currentAnimateTimings;!n&&a.getCurrentStyleProperties().length&&a.forwardFrame();const i=n&&n.easing||e.easing;e.isEmptyStep?a.applyEmptyStep(i):a.setStyles(e.styles,i,t.errors,t.options),t.previousNode=e}visitKeyframes(e,t){const a=t.currentAnimateTimings,n=t.currentTimeline.duration,i=a.duration,r=t.createSubContext().currentTimeline;r.easing=a.easing,e.styles.forEach(e=>{r.forwardTime((e.offset||0)*i),r.setStyles(e.styles,e.easing,t.errors,t.options),r.applyStylesToKeyframe()}),t.currentTimeline.mergeTimelineCollectedStyles(r),t.transformIntoNewTimeline(n+i),t.previousNode=e}visitQuery(e,t){const a=t.currentTimeline.currentTime,n=e.options||{},i=n.delay?wg(n.delay):0;i&&(6===t.previousNode.type||0==a&&t.currentTimeline.getCurrentStyleProperties().length)&&(t.currentTimeline.snapshotCurrentStyles(),t.previousNode=nf);let r=a;const s=t.invokeQuery(e.selector,e.originalSelector,e.limit,e.includeSelf,!!n.optional,t.errors);t.currentQueryTotal=s.length;let o=null;s.forEach((a,n)=>{t.currentQueryIndex=n;const s=t.createSubContext(e.options,a);i&&s.delayNextStep(i),a===t.element&&(o=s.currentTimeline),jg(this,e.animation,s),s.currentTimeline.applyStylesToKeyframe(),r=Math.max(r,s.currentTimeline.currentTime)}),t.currentQueryIndex=0,t.currentQueryTotal=0,t.transformIntoNewTimeline(r),o&&(t.currentTimeline.mergeTimelineCollectedStyles(o),t.currentTimeline.snapshotCurrentStyles()),t.previousNode=e}visitStagger(e,t){const a=t.parentContext,n=t.currentTimeline,i=e.timings,r=Math.abs(i.duration),s=r*(t.currentQueryTotal-1);let o=r*t.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":o=s-o;break;case"full":o=a.currentStaggerTime}const l=t.currentTimeline;o&&l.delayNextStep(o);const c=l.currentTime;jg(this,e.animation,t),t.previousNode=e,a.currentStaggerTime=n.currentTime-c+(n.startTime-a.currentTimeline.startTime)}}const nf={};class rf{constructor(e,t,a,n,i,r,s,o){this._driver=e,this.element=t,this.subInstructions=a,this._enterClassName=n,this._leaveClassName=i,this.errors=r,this.timelines=s,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=nf,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=o||new sf(this._driver,t,0),s.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(e,t){if(!e)return;const a=e;let n=this.options;null!=a.duration&&(n.duration=wg(a.duration)),null!=a.delay&&(n.delay=wg(a.delay));const i=a.params;if(i){let e=n.params;e||(e=this.options.params={}),Object.keys(i).forEach(a=>{t&&e.hasOwnProperty(a)||(e[a]=Mg(i[a],e,this.errors))})}}_copyOptions(){const e={};if(this.options){const t=this.options.params;if(t){const a=e.params={};Object.keys(t).forEach(e=>{a[e]=t[e]})}}return e}createSubContext(e=null,t,a){const n=t||this.element,i=new rf(this._driver,n,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(n,a||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(e),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(e){return this.previousNode=nf,this.currentTimeline=this.currentTimeline.fork(this.element,e),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(e,t,a){const n={duration:null!=t?t:e.duration,delay:this.currentTimeline.currentTime+(null!=a?a:0)+e.delay,easing:""},i=new of(this._driver,e.element,e.keyframes,e.preStyleProps,e.postStyleProps,n,e.stretchStartingKeyframe);return this.timelines.push(i),n}incrementTime(e){this.currentTimeline.forwardTime(this.currentTimeline.duration+e)}delayNextStep(e){e>0&&this.currentTimeline.delayNextStep(e)}invokeQuery(e,t,a,n,i,r){let s=[];if(n&&s.push(this.element),e.length>0){e=(e=e.replace($g,"."+this._enterClassName)).replace(ef,"."+this._leaveClassName);let t=this._driver.query(this.element,e,1!=a);0!==a&&(t=a<0?t.slice(t.length+a,t.length):t.slice(0,a)),s.push(...t)}return i||0!=s.length||r.push(`\`query("${t}")\` returned zero elements. (Use \`query("${t}", { optional: true })\` if you wish to allow this.)`),s}}class sf{constructor(e,t,a,n){this._driver=e,this.element=t,this.startTime=a,this._elementTimelineStylesLookup=n,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(t),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(t,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(e){const t=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||t?(this.forwardTime(this.currentTime+e),t&&this.snapshotCurrentStyles()):this.startTime+=e}fork(e,t){return this.applyStylesToKeyframe(),new sf(this._driver,e,t||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(e){this.applyStylesToKeyframe(),this.duration=e,this._loadKeyframe()}_updateStyle(e,t){this._localTimelineStyles[e]=t,this._globalTimelineStyles[e]=t,this._styleSummary[e]={time:this.currentTime,value:t}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(e){e&&(this._previousKeyframe.easing=e),Object.keys(this._globalTimelineStyles).forEach(e=>{this._backFill[e]=this._globalTimelineStyles[e]||Nm,this._currentKeyframe[e]=Nm}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(e,t,a,n){t&&(this._previousKeyframe.easing=t);const i=n&&n.params||{},r=function(e,t){const a={};let n;return e.forEach(e=>{"*"===e?(n=n||Object.keys(t),n.forEach(e=>{a[e]=Nm})):kg(e,!1,a)}),a}(e,this._globalTimelineStyles);Object.keys(r).forEach(e=>{const t=Mg(r[e],i,a);this._pendingStyles[e]=t,this._localTimelineStyles.hasOwnProperty(e)||(this._backFill[e]=this._globalTimelineStyles.hasOwnProperty(e)?this._globalTimelineStyles[e]:Nm),this._updateStyle(e,t)})}applyStylesToKeyframe(){const e=this._pendingStyles,t=Object.keys(e);0!=t.length&&(this._pendingStyles={},t.forEach(t=>{this._currentKeyframe[t]=e[t]}),Object.keys(this._localTimelineStyles).forEach(e=>{this._currentKeyframe.hasOwnProperty(e)||(this._currentKeyframe[e]=this._localTimelineStyles[e])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(e=>{const t=this._localTimelineStyles[e];this._pendingStyles[e]=t,this._updateStyle(e,t)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const e=[];for(let t in this._currentKeyframe)e.push(t);return e}mergeTimelineCollectedStyles(e){Object.keys(e._styleSummary).forEach(t=>{const a=this._styleSummary[t],n=e._styleSummary[t];(!a||n.time>a.time)&&this._updateStyle(t,n.value)})}buildKeyframes(){this.applyStylesToKeyframe();const e=new Set,t=new Set,a=1===this._keyframes.size&&0===this.duration;let n=[];this._keyframes.forEach((i,r)=>{const s=kg(i,!0);Object.keys(s).forEach(a=>{const n=s[a];"!"==n?e.add(a):n==Nm&&t.add(a)}),a||(s.offset=r/this.duration),n.push(s)});const i=e.size?Pg(e.values()):[],r=t.size?Pg(t.values()):[];if(a){const e=n[0],t=xg(e);e.offset=0,t.offset=1,n=[e,t]}return Jg(this.element,n,i,r,this.duration,this.startTime,this.easing,!1)}}class of extends sf{constructor(e,t,a,n,i,r,s=!1){super(e,t,r.delay),this.element=t,this.keyframes=a,this.preStyleProps=n,this.postStyleProps=i,this._stretchStartingKeyframe=s,this.timings={duration:r.duration,delay:r.delay,easing:r.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let e=this.keyframes,{delay:t,duration:a,easing:n}=this.timings;if(this._stretchStartingKeyframe&&t){const i=[],r=a+t,s=t/r,o=kg(e[0],!1);o.offset=0,i.push(o);const l=kg(e[0],!1);l.offset=lf(s),i.push(l);const c=e.length-1;for(let n=1;n<=c;n++){let s=kg(e[n],!1);s.offset=lf((t+s.offset*a)/r),i.push(s)}a=r,t=0,n="",e=i}return Jg(this.element,e,this.preStyleProps,this.postStyleProps,a,t,n,!0)}}function lf(e,t=3){const a=Math.pow(10,t-1);return Math.round(e*a)/a}class cf{}class hf extends cf{normalizePropertyName(e,t){return Lg(e)}normalizeStyleValue(e,t,a,n){let i="";const r=a.toString().trim();if(df[t]&&0!==a&&"0"!==a)if("number"==typeof a)i="px";else{const t=a.match(/^[+-]?[\d\.]+([a-z]*)$/);t&&0==t[1].length&&n.push(`Please provide a CSS unit value for ${e}:${a}`)}return r+i}}const df=(()=>function(e){const t={};return e.forEach(e=>t[e]=!0),t}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function uf(e,t,a,n,i,r,s,o,l,c,h,d,u){return{type:0,element:e,triggerName:t,isRemovalTransition:i,fromState:a,fromStyles:r,toState:n,toStyles:s,timelines:o,queriedElements:l,preStyleProps:c,postStyleProps:h,totalTime:d,errors:u}}const pf={};class mf{constructor(e,t,a){this._triggerName=e,this.ast=t,this._stateStyles=a}match(e,t,a,n){return function(e,t,a,n,i){return e.some(e=>e(t,a,n,i))}(this.ast.matchers,e,t,a,n)}buildStyles(e,t,a){const n=this._stateStyles["*"],i=this._stateStyles[e],r=n?n.buildStyles(t,a):{};return i?i.buildStyles(t,a):r}build(e,t,a,n,i,r,s,o,l,c){const h=[],d=this.ast.options&&this.ast.options.params||pf,u=this.buildStyles(a,s&&s.params||pf,h),p=o&&o.params||pf,m=this.buildStyles(n,p,h),g=new Set,f=new Map,b=new Map,y="void"===n,w={params:Object.assign(Object.assign({},d),p)},v=c?[]:tf(e,t,this.ast.animation,i,r,u,m,w,l,h);let _=0;if(v.forEach(e=>{_=Math.max(e.duration+e.delay,_)}),h.length)return uf(t,this._triggerName,a,n,y,u,m,[],[],f,b,_,h);v.forEach(e=>{const a=e.element,n=Zm(f,a,{});e.preStyleProps.forEach(e=>n[e]=!0);const i=Zm(b,a,{});e.postStyleProps.forEach(e=>i[e]=!0),a!==t&&g.add(a)});const x=Pg(g.values());return uf(t,this._triggerName,a,n,y,u,m,v,x,f,b,_)}}class gf{constructor(e,t){this.styles=e,this.defaultParams=t}buildStyles(e,t){const a={},n=xg(this.defaultParams);return Object.keys(e).forEach(t=>{const a=e[t];null!=a&&(n[t]=a)}),this.styles.styles.forEach(e=>{if("string"!=typeof e){const i=e;Object.keys(i).forEach(e=>{let r=i[e];r.length>1&&(r=Mg(r,n,t)),a[e]=r})}}),a}}class ff{constructor(e,t){this.name=e,this.ast=t,this.transitionFactories=[],this.states={},t.states.forEach(e=>{this.states[e.name]=new gf(e.style,e.options&&e.options.params||{})}),bf(this.states,"true","1"),bf(this.states,"false","0"),t.transitions.forEach(t=>{this.transitionFactories.push(new mf(e,t,this.states))}),this.fallbackTransition=new mf(e,{type:1,animation:{type:2,steps:[],options:null},matchers:[(e,t)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(e,t,a,n){return this.transitionFactories.find(i=>i.match(e,t,a,n))||null}matchStyles(e,t,a){return this.fallbackTransition.buildStyles(e,t,a)}}function bf(e,t,a){e.hasOwnProperty(t)?e.hasOwnProperty(a)||(e[a]=e[t]):e.hasOwnProperty(a)&&(e[t]=e[a])}const yf=new Zg;class wf{constructor(e,t,a){this.bodyNode=e,this._driver=t,this._normalizer=a,this._animations={},this._playersById={},this.players=[]}register(e,t){const a=[],n=Qg(this._driver,t,a);if(a.length)throw new Error("Unable to build the animation due to the following errors: "+a.join("\n"));this._animations[e]=n}_buildPlayer(e,t,a){const n=e.element,i=Vm(0,this._normalizer,0,e.keyframes,t,a);return this._driver.animate(n,i,e.duration,e.delay,e.easing,[],!0)}create(e,t,a={}){const n=[],i=this._animations[e];let r;const s=new Map;if(i?(r=tf(this._driver,t,i,pg,mg,{},{},a,yf,n),r.forEach(e=>{const t=Zm(s,e.element,{});e.postStyleProps.forEach(e=>t[e]=null)})):(n.push("The requested animation doesn't exist or has already been destroyed"),r=[]),n.length)throw new Error("Unable to create the animation due to the following errors: "+n.join("\n"));s.forEach((e,t)=>{Object.keys(e).forEach(a=>{e[a]=this._driver.computeStyle(t,a,Nm)})});const o=Um(r.map(e=>{const t=s.get(e.element);return this._buildPlayer(e,{},t)}));return this._playersById[e]=o,o.onDestroy(()=>this.destroy(e)),this.players.push(o),o}destroy(e){const t=this._getPlayer(e);t.destroy(),delete this._playersById[e];const a=this.players.indexOf(t);a>=0&&this.players.splice(a,1)}_getPlayer(e){const t=this._playersById[e];if(!t)throw new Error("Unable to find the timeline player referenced by "+e);return t}listen(e,t,a,n){const i=Jm(t,"","","");return Km(this._getPlayer(e),a,i,n),()=>{}}command(e,t,a,n){if("register"==a)return void this.register(e,n[0]);if("create"==a)return void this.create(e,t,n[0]||{});const i=this._getPlayer(e);switch(a){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(n[0]));break;case"destroy":this.destroy(e)}}}const vf="ng-animate-queued",_f="ng-animate-disabled",xf=".ng-animate-disabled",kf=[],Sf={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},Tf={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class Cf{constructor(e,t=""){this.namespaceId=t;const a=e&&e.hasOwnProperty("value");if(this.value=null!=(n=a?e.value:e)?n:null,a){const t=xg(e);delete t.value,this.options=t}else this.options={};var n;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(e){const t=e.params;if(t){const e=this.options.params;Object.keys(t).forEach(a=>{null==e[a]&&(e[a]=t[a])})}}}const Ef="void",Af=new Cf(Ef);class If{constructor(e,t,a){this.id=e,this.hostElement=t,this._engine=a,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+e,Of(t,this._hostClassName)}listen(e,t,a,n){if(!this._triggers.hasOwnProperty(t))throw new Error(`Unable to listen on the animation trigger event "${a}" because the animation trigger "${t}" doesn't exist!`);if(null==a||0==a.length)throw new Error(`Unable to listen on the animation trigger "${t}" because the provided event is undefined!`);if("start"!=(i=a)&&"done"!=i)throw new Error(`The provided animation trigger event "${a}" for the animation trigger "${t}" is not supported!`);var i;const r=Zm(this._elementListeners,e,[]),s={name:t,phase:a,callback:n};r.push(s);const o=Zm(this._engine.statesByElement,e,{});return o.hasOwnProperty(t)||(Of(e,gg),Of(e,"ng-trigger-"+t),o[t]=Af),()=>{this._engine.afterFlush(()=>{const e=r.indexOf(s);e>=0&&r.splice(e,1),this._triggers[t]||delete o[t]})}}register(e,t){return!this._triggers[e]&&(this._triggers[e]=t,!0)}_getTrigger(e){const t=this._triggers[e];if(!t)throw new Error(`The provided animation trigger "${e}" has not been registered!`);return t}trigger(e,t,a,n=!0){const i=this._getTrigger(t),r=new Mf(this.id,t,e);let s=this._engine.statesByElement.get(e);s||(Of(e,gg),Of(e,"ng-trigger-"+t),this._engine.statesByElement.set(e,s={}));let o=s[t];const l=new Cf(a,this.id);if(!(a&&a.hasOwnProperty("value"))&&o&&l.absorbOptions(o.options),s[t]=l,o||(o=Af),l.value!==Ef&&o.value===l.value){if(!function(e,t){const a=Object.keys(e),n=Object.keys(t);if(a.length!=n.length)return!1;for(let i=0;i<a.length;i++){const n=a[i];if(!t.hasOwnProperty(n)||e[n]!==t[n])return!1}return!0}(o.params,l.params)){const t=[],a=i.matchStyles(o.value,o.params,t),n=i.matchStyles(l.value,l.params,t);t.length?this._engine.reportError(t):this._engine.afterFlush(()=>{Eg(e,a),Cg(e,n)})}return}const c=Zm(this._engine.playersByElement,e,[]);c.forEach(e=>{e.namespaceId==this.id&&e.triggerName==t&&e.queued&&e.destroy()});let h=i.matchTransition(o.value,l.value,e,l.params),d=!1;if(!h){if(!n)return;h=i.fallbackTransition,d=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:e,triggerName:t,transition:h,fromState:o,toState:l,player:r,isFallbackTransition:d}),d||(Of(e,vf),r.onStart(()=>{jf(e,vf)})),r.onDone(()=>{let t=this.players.indexOf(r);t>=0&&this.players.splice(t,1);const a=this._engine.playersByElement.get(e);if(a){let e=a.indexOf(r);e>=0&&a.splice(e,1)}}),this.players.push(r),c.push(r),r}deregister(e){delete this._triggers[e],this._engine.statesByElement.forEach((t,a)=>{delete t[e]}),this._elementListeners.forEach((t,a)=>{this._elementListeners.set(a,t.filter(t=>t.name!=e))})}clearElementCache(e){this._engine.statesByElement.delete(e),this._elementListeners.delete(e);const t=this._engine.playersByElement.get(e);t&&(t.forEach(e=>e.destroy()),this._engine.playersByElement.delete(e))}_signalRemovalForInnerTriggers(e,t){const a=this._engine.driver.query(e,fg,!0);a.forEach(e=>{if(e.__ng_removed)return;const a=this._engine.fetchNamespacesByElement(e);a.size?a.forEach(a=>a.triggerLeaveAnimation(e,t,!1,!0)):this.clearElementCache(e)}),this._engine.afterFlushAnimationsDone(()=>a.forEach(e=>this.clearElementCache(e)))}triggerLeaveAnimation(e,t,a,n){const i=this._engine.statesByElement.get(e);if(i){const r=[];if(Object.keys(i).forEach(t=>{if(this._triggers[t]){const a=this.trigger(e,t,Ef,n);a&&r.push(a)}}),r.length)return this._engine.markElementAsRemoved(this.id,e,!0,t),a&&Um(r).onDone(()=>this._engine.processLeaveNode(e)),!0}return!1}prepareLeaveAnimationListeners(e){const t=this._elementListeners.get(e);if(t){const a=new Set;t.forEach(t=>{const n=t.name;if(a.has(n))return;a.add(n);const i=this._triggers[n].fallbackTransition,r=this._engine.statesByElement.get(e)[n]||Af,s=new Cf(Ef),o=new Mf(this.id,n,e);this._engine.totalQueuedPlayers++,this._queue.push({element:e,triggerName:n,transition:i,fromState:r,toState:s,player:o,isFallbackTransition:!0})})}}removeNode(e,t){const a=this._engine;if(e.childElementCount&&this._signalRemovalForInnerTriggers(e,t),this.triggerLeaveAnimation(e,t,!0))return;let n=!1;if(a.totalAnimations){const t=a.players.length?a.playersByQueriedElement.get(e):[];if(t&&t.length)n=!0;else{let t=e;for(;t=t.parentNode;)if(a.statesByElement.get(t)){n=!0;break}}}if(this.prepareLeaveAnimationListeners(e),n)a.markElementAsRemoved(this.id,e,!1,t);else{const n=e.__ng_removed;n&&n!==Sf||(a.afterFlush(()=>this.clearElementCache(e)),a.destroyInnerAnimations(e),a._onRemovalComplete(e,t))}}insertNode(e,t){Of(e,this._hostClassName)}drainQueuedTransitions(e){const t=[];return this._queue.forEach(a=>{const n=a.player;if(n.destroyed)return;const i=a.element,r=this._elementListeners.get(i);r&&r.forEach(t=>{if(t.name==a.triggerName){const n=Jm(i,a.triggerName,a.fromState.value,a.toState.value);n._data=e,Km(a.player,t.phase,n,t.callback)}}),n.markedForDestroy?this._engine.afterFlush(()=>{n.destroy()}):t.push(a)}),this._queue=[],t.sort((e,t)=>{const a=e.transition.ast.depCount,n=t.transition.ast.depCount;return 0==a||0==n?a-n:this._engine.driver.containsElement(e.element,t.element)?1:-1})}destroy(e){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,e)}elementContainsData(e){let t=!1;return this._elementListeners.has(e)&&(t=!0),t=!!this._queue.find(t=>t.element===e)||t,t}}class Rf{constructor(e,t,a){this.bodyNode=e,this.driver=t,this._normalizer=a,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(e,t)=>{}}_onRemovalComplete(e,t){this.onRemovalComplete(e,t)}get queuedPlayers(){const e=[];return this._namespaceList.forEach(t=>{t.players.forEach(t=>{t.queued&&e.push(t)})}),e}createNamespace(e,t){const a=new If(e,t,this);return t.parentNode?this._balanceNamespaceList(a,t):(this.newHostElements.set(t,a),this.collectEnterElement(t)),this._namespaceLookup[e]=a}_balanceNamespaceList(e,t){const a=this._namespaceList.length-1;if(a>=0){let n=!1;for(let i=a;i>=0;i--)if(this.driver.containsElement(this._namespaceList[i].hostElement,t)){this._namespaceList.splice(i+1,0,e),n=!0;break}n||this._namespaceList.splice(0,0,e)}else this._namespaceList.push(e);return this.namespacesByHostElement.set(t,e),e}register(e,t){let a=this._namespaceLookup[e];return a||(a=this.createNamespace(e,t)),a}registerTrigger(e,t,a){let n=this._namespaceLookup[e];n&&n.register(t,a)&&this.totalAnimations++}destroy(e,t){if(!e)return;const a=this._fetchNamespace(e);this.afterFlush(()=>{this.namespacesByHostElement.delete(a.hostElement),delete this._namespaceLookup[e];const t=this._namespaceList.indexOf(a);t>=0&&this._namespaceList.splice(t,1)}),this.afterFlushAnimationsDone(()=>a.destroy(t))}_fetchNamespace(e){return this._namespaceLookup[e]}fetchNamespacesByElement(e){const t=new Set,a=this.statesByElement.get(e);if(a){const e=Object.keys(a);for(let n=0;n<e.length;n++){const i=a[e[n]].namespaceId;if(i){const e=this._fetchNamespace(i);e&&t.add(e)}}}return t}trigger(e,t,a,n){if(Pf(t)){const i=this._fetchNamespace(e);if(i)return i.trigger(t,a,n),!0}return!1}insertNode(e,t,a,n){if(!Pf(t))return;const i=t.__ng_removed;if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const e=this.collectedLeaveElements.indexOf(t);e>=0&&this.collectedLeaveElements.splice(e,1)}if(e){const n=this._fetchNamespace(e);n&&n.insertNode(t,a)}n&&this.collectEnterElement(t)}collectEnterElement(e){this.collectedEnterElements.push(e)}markElementAsDisabled(e,t){t?this.disabledNodes.has(e)||(this.disabledNodes.add(e),Of(e,_f)):this.disabledNodes.has(e)&&(this.disabledNodes.delete(e),jf(e,_f))}removeNode(e,t,a,n){if(Pf(t)){const i=e?this._fetchNamespace(e):null;if(i?i.removeNode(t,n):this.markElementAsRemoved(e,t,!1,n),a){const a=this.namespacesByHostElement.get(t);a&&a.id!==e&&a.removeNode(t,n)}}else this._onRemovalComplete(t,n)}markElementAsRemoved(e,t,a,n){this.collectedLeaveElements.push(t),t.__ng_removed={namespaceId:e,setForRemoval:n,hasAnimation:a,removedBeforeQueried:!1}}listen(e,t,a,n,i){return Pf(t)?this._fetchNamespace(e).listen(t,a,n,i):()=>{}}_buildInstruction(e,t,a,n,i){return e.transition.build(this.driver,e.element,e.fromState.value,e.toState.value,a,n,e.fromState.options,e.toState.options,t,i)}destroyInnerAnimations(e){let t=this.driver.query(e,fg,!0);t.forEach(e=>this.destroyActiveAnimationsForElement(e)),0!=this.playersByQueriedElement.size&&(t=this.driver.query(e,yg,!0),t.forEach(e=>this.finishActiveQueriedAnimationOnElement(e)))}destroyActiveAnimationsForElement(e){const t=this.playersByElement.get(e);t&&t.forEach(e=>{e.queued?e.markedForDestroy=!0:e.destroy()})}finishActiveQueriedAnimationOnElement(e){const t=this.playersByQueriedElement.get(e);t&&t.forEach(e=>e.finish())}whenRenderingDone(){return new Promise(e=>{if(this.players.length)return Um(this.players).onDone(()=>e());e()})}processLeaveNode(e){const t=e.__ng_removed;if(t&&t.setForRemoval){if(e.__ng_removed=Sf,t.namespaceId){this.destroyInnerAnimations(e);const a=this._fetchNamespace(t.namespaceId);a&&a.clearElementCache(e)}this._onRemovalComplete(e,t.setForRemoval)}this.driver.matchesElement(e,xf)&&this.markElementAsDisabled(e,!1),this.driver.query(e,xf,!0).forEach(e=>{this.markElementAsDisabled(e,!1)})}flush(e=-1){let t=[];if(this.newHostElements.size&&(this.newHostElements.forEach((e,t)=>this._balanceNamespaceList(e,t)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let a=0;a<this.collectedEnterElements.length;a++)Of(this.collectedEnterElements[a],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const a=[];try{t=this._flushAnimations(a,e)}finally{for(let e=0;e<a.length;e++)a[e]()}}else for(let a=0;a<this.collectedLeaveElements.length;a++)this.processLeaveNode(this.collectedLeaveElements[a]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(e=>e()),this._flushFns=[],this._whenQuietFns.length){const e=this._whenQuietFns;this._whenQuietFns=[],t.length?Um(t).onDone(()=>{e.forEach(e=>e())}):e.forEach(e=>e())}}reportError(e){throw new Error("Unable to process animations due to the following failed trigger transitions\n "+e.join("\n"))}_flushAnimations(e,t){const a=new Zg,n=[],i=new Map,r=[],s=new Map,o=new Map,l=new Map,c=new Set;this.disabledNodes.forEach(e=>{c.add(e);const t=this.driver.query(e,".ng-animate-queued",!0);for(let a=0;a<t.length;a++)c.add(t[a])});const h=this.bodyNode,d=Array.from(this.statesByElement.keys()),u=Nf(d,this.collectedEnterElements),p=new Map;let m=0;u.forEach((e,t)=>{const a=pg+m++;p.set(t,a),e.forEach(e=>Of(e,a))});const g=[],f=new Set,b=new Set;for(let R=0;R<this.collectedLeaveElements.length;R++){const e=this.collectedLeaveElements[R],t=e.__ng_removed;t&&t.setForRemoval&&(g.push(e),f.add(e),t.hasAnimation?this.driver.query(e,".ng-star-inserted",!0).forEach(e=>f.add(e)):b.add(e))}const y=new Map,w=Nf(d,Array.from(f));w.forEach((e,t)=>{const a=mg+m++;y.set(t,a),e.forEach(e=>Of(e,a))}),e.push(()=>{u.forEach((e,t)=>{const a=p.get(t);e.forEach(e=>jf(e,a))}),w.forEach((e,t)=>{const a=y.get(t);e.forEach(e=>jf(e,a))}),g.forEach(e=>{this.processLeaveNode(e)})});const v=[],_=[];for(let R=this._namespaceList.length-1;R>=0;R--)this._namespaceList[R].drainQueuedTransitions(t).forEach(e=>{const t=e.player,i=e.element;if(v.push(t),this.collectedEnterElements.length){const e=i.__ng_removed;if(e&&e.setForMove)return void t.destroy()}const c=!h||!this.driver.containsElement(h,i),d=y.get(i),u=p.get(i),m=this._buildInstruction(e,a,u,d,c);if(m.errors&&m.errors.length)_.push(m);else{if(c)return t.onStart(()=>Eg(i,m.fromStyles)),t.onDestroy(()=>Cg(i,m.toStyles)),void n.push(t);if(e.isFallbackTransition)return t.onStart(()=>Eg(i,m.fromStyles)),t.onDestroy(()=>Cg(i,m.toStyles)),void n.push(t);m.timelines.forEach(e=>e.stretchStartingKeyframe=!0),a.append(i,m.timelines),r.push({instruction:m,player:t,element:i}),m.queriedElements.forEach(e=>Zm(s,e,[]).push(t)),m.preStyleProps.forEach((e,t)=>{const a=Object.keys(e);if(a.length){let e=o.get(t);e||o.set(t,e=new Set),a.forEach(t=>e.add(t))}}),m.postStyleProps.forEach((e,t)=>{const a=Object.keys(e);let n=l.get(t);n||l.set(t,n=new Set),a.forEach(e=>n.add(e))})}});if(_.length){const e=[];_.forEach(t=>{e.push(`@${t.triggerName} has failed due to:\n`),t.errors.forEach(t=>e.push(`- ${t}\n`))}),v.forEach(e=>e.destroy()),this.reportError(e)}const x=new Map,k=new Map;r.forEach(e=>{const t=e.element;a.has(t)&&(k.set(t,t),this._beforeAnimationBuild(e.player.namespaceId,e.instruction,x))}),n.forEach(e=>{const t=e.element;this._getPreviousPlayers(t,!1,e.namespaceId,e.triggerName,null).forEach(e=>{Zm(x,t,[]).push(e),e.destroy()})});const S=g.filter(e=>Bf(e,o,l)),T=new Map;Lf(T,this.driver,b,l,Nm).forEach(e=>{Bf(e,o,l)&&S.push(e)});const C=new Map;u.forEach((e,t)=>{Lf(C,this.driver,new Set(e),o,"!")}),S.forEach(e=>{const t=T.get(e),a=C.get(e);T.set(e,Object.assign(Object.assign({},t),a))});const E=[],A=[],I={};r.forEach(e=>{const{element:t,player:r,instruction:s}=e;if(a.has(t)){if(c.has(t))return r.onDestroy(()=>Cg(t,s.toStyles)),r.disabled=!0,r.overrideTotalTime(s.totalTime),void n.push(r);let e=I;if(k.size>1){let a=t;const n=[];for(;a=a.parentNode;){const t=k.get(a);if(t){e=t;break}n.push(a)}n.forEach(t=>k.set(t,e))}const a=this._buildAnimation(r.namespaceId,s,x,i,C,T);if(r.setRealPlayer(a),e===I)E.push(r);else{const t=this.playersByElement.get(e);t&&t.length&&(r.parentPlayer=Um(t)),n.push(r)}}else Eg(t,s.fromStyles),r.onDestroy(()=>Cg(t,s.toStyles)),A.push(r),c.has(t)&&n.push(r)}),A.forEach(e=>{const t=i.get(e.element);if(t&&t.length){const a=Um(t);e.setRealPlayer(a)}}),n.forEach(e=>{e.parentPlayer?e.syncPlayerEvents(e.parentPlayer):e.destroy()});for(let R=0;R<g.length;R++){const e=g[R],t=e.__ng_removed;if(jf(e,mg),t&&t.hasAnimation)continue;let a=[];if(s.size){let t=s.get(e);t&&t.length&&a.push(...t);let n=this.driver.query(e,yg,!0);for(let e=0;e<n.length;e++){let t=s.get(n[e]);t&&t.length&&a.push(...t)}}const n=a.filter(e=>!e.destroyed);n.length?Wf(this,e,n):this.processLeaveNode(e)}return g.length=0,E.forEach(e=>{this.players.push(e),e.onDone(()=>{e.destroy();const t=this.players.indexOf(e);this.players.splice(t,1)}),e.play()}),E}elementContainsData(e,t){let a=!1;const n=t.__ng_removed;return n&&n.setForRemoval&&(a=!0),this.playersByElement.has(t)&&(a=!0),this.playersByQueriedElement.has(t)&&(a=!0),this.statesByElement.has(t)&&(a=!0),this._fetchNamespace(e).elementContainsData(t)||a}afterFlush(e){this._flushFns.push(e)}afterFlushAnimationsDone(e){this._whenQuietFns.push(e)}_getPreviousPlayers(e,t,a,n,i){let r=[];if(t){const t=this.playersByQueriedElement.get(e);t&&(r=t)}else{const t=this.playersByElement.get(e);if(t){const e=!i||i==Ef;t.forEach(t=>{t.queued||(e||t.triggerName==n)&&r.push(t)})}}return(a||n)&&(r=r.filter(e=>!(a&&a!=e.namespaceId||n&&n!=e.triggerName))),r}_beforeAnimationBuild(e,t,a){const n=t.element,i=t.isRemovalTransition?void 0:e,r=t.isRemovalTransition?void 0:t.triggerName;for(const s of t.timelines){const e=s.element,o=e!==n,l=Zm(a,e,[]);this._getPreviousPlayers(e,o,i,r,t.toState).forEach(e=>{const t=e.getRealPlayer();t.beforeDestroy&&t.beforeDestroy(),e.destroy(),l.push(e)})}Eg(n,t.fromStyles)}_buildAnimation(e,t,a,n,i,r){const s=t.triggerName,o=t.element,l=[],c=new Set,h=new Set,d=t.timelines.map(t=>{const d=t.element;c.add(d);const u=d.__ng_removed;if(u&&u.removedBeforeQueried)return new qm(t.duration,t.delay);const p=d!==o,m=function(e){const t=[];return zf(e,t),t}((a.get(d)||kf).map(e=>e.getRealPlayer())).filter(e=>!!e.element&&e.element===d),g=i.get(d),f=r.get(d),b=Vm(0,this._normalizer,0,t.keyframes,g,f),y=this._buildPlayer(t,b,m);if(t.subTimeline&&n&&h.add(d),p){const t=new Mf(e,s,d);t.setRealPlayer(y),l.push(t)}return y});l.forEach(e=>{Zm(this.playersByQueriedElement,e.element,[]).push(e),e.onDone(()=>function(e,t,a){let n;if(e instanceof Map){if(n=e.get(t),n){if(n.length){const e=n.indexOf(a);n.splice(e,1)}0==n.length&&e.delete(t)}}else if(n=e[t],n){if(n.length){const e=n.indexOf(a);n.splice(e,1)}0==n.length&&delete e[t]}return n}(this.playersByQueriedElement,e.element,e))}),c.forEach(e=>Of(e,bg));const u=Um(d);return u.onDestroy(()=>{c.forEach(e=>jf(e,bg)),Cg(o,t.toStyles)}),h.forEach(e=>{Zm(n,e,[]).push(u)}),u}_buildPlayer(e,t,a){return t.length>0?this.driver.animate(e.element,t,e.duration,e.delay,e.easing,a):new qm(e.duration,e.delay)}}class Mf{constructor(e,t,a){this.namespaceId=e,this.triggerName=t,this.element=a,this._player=new qm,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(e){this._containsRealPlayer||(this._player=e,Object.keys(this._queuedCallbacks).forEach(t=>{this._queuedCallbacks[t].forEach(a=>Km(e,t,void 0,a))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(e.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(e){this.totalTime=e}syncPlayerEvents(e){const t=this._player;t.triggerCallback&&e.onStart(()=>t.triggerCallback("start")),e.onDone(()=>this.finish()),e.onDestroy(()=>this.destroy())}_queueEvent(e,t){Zm(this._queuedCallbacks,e,[]).push(t)}onDone(e){this.queued&&this._queueEvent("done",e),this._player.onDone(e)}onStart(e){this.queued&&this._queueEvent("start",e),this._player.onStart(e)}onDestroy(e){this.queued&&this._queueEvent("destroy",e),this._player.onDestroy(e)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(e){this.queued||this._player.setPosition(e)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(e){const t=this._player;t.triggerCallback&&t.triggerCallback(e)}}function Pf(e){return e&&1===e.nodeType}function Df(e,t){const a=e.style.display;return e.style.display=null!=t?t:"none",a}function Lf(e,t,a,n,i){const r=[];a.forEach(e=>r.push(Df(e)));const s=[];n.forEach((a,n)=>{const r={};a.forEach(e=>{const a=r[e]=t.computeStyle(n,e,i);a&&0!=a.length||(n.__ng_removed=Tf,s.push(n))}),e.set(n,r)});let o=0;return a.forEach(e=>Df(e,r[o++])),s}function Nf(e,t){const a=new Map;if(e.forEach(e=>a.set(e,[])),0==t.length)return a;const n=new Set(t),i=new Map;function r(e){if(!e)return 1;let t=i.get(e);if(t)return t;const s=e.parentNode;return t=a.has(s)?s:n.has(s)?1:r(s),i.set(e,t),t}return t.forEach(e=>{const t=r(e);1!==t&&a.get(t).push(e)}),a}function Of(e,t){if(e.classList)e.classList.add(t);else{let a=e.$$classes;a||(a=e.$$classes={}),a[t]=!0}}function jf(e,t){if(e.classList)e.classList.remove(t);else{let a=e.$$classes;a&&delete a[t]}}function Wf(e,t,a){Um(a).onDone(()=>e.processLeaveNode(t))}function zf(e,t){for(let a=0;a<e.length;a++){const n=e[a];n instanceof Qm?zf(n.players,t):t.push(n)}}function Bf(e,t,a){const n=a.get(e);if(!n)return!1;let i=t.get(e);return i?n.forEach(e=>i.add(e)):t.set(e,n),a.delete(e),!0}class Gf{constructor(e,t,a){this.bodyNode=e,this._driver=t,this._triggerCache={},this.onRemovalComplete=(e,t)=>{},this._transitionEngine=new Rf(e,t,a),this._timelineEngine=new wf(e,t,a),this._transitionEngine.onRemovalComplete=(e,t)=>this.onRemovalComplete(e,t)}registerTrigger(e,t,a,n,i){const r=e+"-"+n;let s=this._triggerCache[r];if(!s){const e=[],t=Qg(this._driver,i,e);if(e.length)throw new Error(`The animation trigger "${n}" has failed to build due to the following errors:\n - ${e.join("\n - ")}`);s=function(e,t){return new ff(e,t)}(n,t),this._triggerCache[r]=s}this._transitionEngine.registerTrigger(t,n,s)}register(e,t){this._transitionEngine.register(e,t)}destroy(e,t){this._transitionEngine.destroy(e,t)}onInsert(e,t,a,n){this._transitionEngine.insertNode(e,t,a,n)}onRemove(e,t,a,n){this._transitionEngine.removeNode(e,t,n||!1,a)}disableAnimations(e,t){this._transitionEngine.markElementAsDisabled(e,t)}process(e,t,a,n){if("@"==a.charAt(0)){const[e,i]=$m(a);this._timelineEngine.command(e,t,i,n)}else this._transitionEngine.trigger(e,t,a,n)}listen(e,t,a,n,i){if("@"==a.charAt(0)){const[e,n]=$m(a);return this._timelineEngine.listen(e,t,n,i)}return this._transitionEngine.listen(e,t,a,n,i)}flush(e=-1){this._transitionEngine.flush(e)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function Hf(e,t){let a=null,n=null;return Array.isArray(t)&&t.length?(a=qf(t[0]),t.length>1&&(n=qf(t[t.length-1]))):t&&(a=qf(t)),a||n?new Ff(e,a,n):null}let Ff=(()=>{class e{constructor(t,a,n){this._element=t,this._startStyles=a,this._endStyles=n,this._state=0;let i=e.initialStylesByElement.get(t);i||e.initialStylesByElement.set(t,i={}),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&Cg(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Cg(this._element,this._initialStyles),this._endStyles&&(Cg(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(e.initialStylesByElement.delete(this._element),this._startStyles&&(Eg(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Eg(this._element,this._endStyles),this._endStyles=null),Cg(this._element,this._initialStyles),this._state=3)}}return e.initialStylesByElement=new WeakMap,e})();function qf(e){let t=null;const a=Object.keys(e);for(let n=0;n<a.length;n++){const i=a[n];Qf(i)&&(t=t||{},t[i]=e[i])}return t}function Qf(e){return"display"===e||"position"===e}const Yf="animation",Uf="animationend";class Vf{constructor(e,t,a,n,i,r,s){this._element=e,this._name=t,this._duration=a,this._delay=n,this._easing=i,this._fillMode=r,this._onDoneFn=s,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=e=>this._handleCallback(e)}apply(){!function(e,t){const a=eb(e,"").trim();a.length&&(function(e,t){let a=0;for(let n=0;n<e.length;n++)","===e.charAt(n)&&a++}(a),t=`${a}, ${t}`),$f(e,"",t)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),Zf(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){Kf(this._element,this._name,"paused")}resume(){Kf(this._element,this._name,"running")}setPosition(e){const t=Xf(this._element,this._name);this._position=e*this._duration,$f(this._element,"Delay",`-${this._position}ms`,t)}getPosition(){return this._position}_handleCallback(e){const t=e._ngTestManualTimestamp||Date.now(),a=1e3*parseFloat(e.elapsedTime.toFixed(3));e.animationName==this._name&&Math.max(t-this._startTime,0)>=this._delay&&a>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),Zf(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(e,t){const a=eb(e,"").split(","),n=Jf(a,t);n>=0&&(a.splice(n,1),$f(e,"",a.join(",")))}(this._element,this._name))}}function Kf(e,t,a){$f(e,"PlayState",a,Xf(e,t))}function Xf(e,t){const a=eb(e,"");return a.indexOf(",")>0?Jf(a.split(","),t):Jf([a],t)}function Jf(e,t){for(let a=0;a<e.length;a++)if(e[a].indexOf(t)>=0)return a;return-1}function Zf(e,t,a){a?e.removeEventListener(Uf,t):e.addEventListener(Uf,t)}function $f(e,t,a,n){const i=Yf+t;if(null!=n){const t=e.style[i];if(t.length){const e=t.split(",");e[n]=a,a=e.join(",")}}e.style[i]=a}function eb(e,t){return e.style[Yf+t]}class tb{constructor(e,t,a,n,i,r,s,o){this.element=e,this.keyframes=t,this.animationName=a,this._duration=n,this._delay=i,this._finalStyles=s,this._specialStyles=o,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this.currentSnapshot={},this._state=0,this.easing=r||"linear",this.totalTime=n+i,this._buildStyler()}onStart(e){this._onStartFns.push(e)}onDone(e){this._onDoneFns.push(e)}onDestroy(e){this._onDestroyFns.push(e)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(e=>e()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(e=>e()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(e=>e()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(e){this._styler.setPosition(e)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new Vf(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(e){const t="start"==e?this._onStartFns:this._onDoneFns;t.forEach(e=>e()),t.length=0}beforeDestroy(){this.init();const e={};if(this.hasStarted()){const t=this._state>=3;Object.keys(this._finalStyles).forEach(a=>{"offset"!=a&&(e[a]=t?this._finalStyles[a]:Wg(this.element,a))})}this.currentSnapshot=e}}class ab extends qm{constructor(e,t){super(),this.element=e,this._startingStyles={},this.__initialized=!1,this._styles=hg(t)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(e=>{this._startingStyles[e]=this.element.style[e]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(e=>this.element.style.setProperty(e,this._styles[e])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(e=>{const t=this._startingStyles[e];t?this.element.style.setProperty(e,t):this.element.style.removeProperty(e)}),this._startingStyles=null,super.destroy())}}class nb{constructor(){this._count=0,this._head=document.querySelector("head"),this._warningIssued=!1}validateStyleProperty(e){return sg(e)}matchesElement(e,t){return og(e,t)}containsElement(e,t){return lg(e,t)}query(e,t,a){return cg(e,t,a)}computeStyle(e,t,a){return window.getComputedStyle(e)[t]}buildKeyframeElement(e,t,a){a=a.map(e=>hg(e));let n=`@keyframes ${t} {\n`,i="";a.forEach(e=>{i=" ";const t=parseFloat(e.offset);n+=`${i}${100*t}% {\n`,i+=" ",Object.keys(e).forEach(t=>{const a=e[t];switch(t){case"offset":return;case"easing":return void(a&&(n+=`${i}animation-timing-function: ${a};\n`));default:return void(n+=`${i}${t}: ${a};\n`)}}),n+=i+"}\n"}),n+="}\n";const r=document.createElement("style");return r.textContent=n,r}animate(e,t,a,n,i,r=[],s){s&&this._notifyFaultyScrubber();const o=r.filter(e=>e instanceof tb),l={};Ng(a,n)&&o.forEach(e=>{let t=e.currentSnapshot;Object.keys(t).forEach(e=>l[e]=t[e])});const c=function(e){let t={};return e&&(Array.isArray(e)?e:[e]).forEach(e=>{Object.keys(e).forEach(a=>{"offset"!=a&&"easing"!=a&&(t[a]=e[a])})}),t}(t=Og(e,t,l));if(0==a)return new ab(e,c);const h="gen_css_kf_"+this._count++,d=this.buildKeyframeElement(e,h,t);document.querySelector("head").appendChild(d);const u=Hf(e,t),p=new tb(e,t,h,a,n,i,c,u);return p.onDestroy(()=>{var e;(e=d).parentNode.removeChild(e)}),p}_notifyFaultyScrubber(){this._warningIssued||(console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n","  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."),this._warningIssued=!0)}}class ib{constructor(e,t,a,n){this.element=e,this.keyframes=t,this.options=a,this._specialStyles=n,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=a.duration,this._delay=a.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(e=>e()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const e=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,e,this.options),this._finalKeyframe=e.length?e[e.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(e,t,a){return e.animate(t,a)}onStart(e){this._onStartFns.push(e)}onDone(e){this._onDoneFns.push(e)}onDestroy(e){this._onDestroyFns.push(e)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(e=>e()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(e=>e()),this._onDestroyFns=[])}setPosition(e){this.domPlayer.currentTime=e*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const e={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(t=>{"offset"!=t&&(e[t]=this._finished?this._finalKeyframe[t]:Wg(this.element,t))}),this.currentSnapshot=e}triggerCallback(e){const t="start"==e?this._onStartFns:this._onDoneFns;t.forEach(e=>e()),t.length=0}}class rb{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(sb().toString()),this._cssKeyframesDriver=new nb}validateStyleProperty(e){return sg(e)}matchesElement(e,t){return og(e,t)}containsElement(e,t){return lg(e,t)}query(e,t,a){return cg(e,t,a)}computeStyle(e,t,a){return window.getComputedStyle(e)[t]}overrideWebAnimationsSupport(e){this._isNativeImpl=e}animate(e,t,a,n,i,r=[],s){if(!s&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(e,t,a,n,i,r);const o={duration:a,delay:n,fill:0==n?"both":"forwards"};i&&(o.easing=i);const l={},c=r.filter(e=>e instanceof ib);Ng(a,n)&&c.forEach(e=>{let t=e.currentSnapshot;Object.keys(t).forEach(e=>l[e]=t[e])});const h=Hf(e,t=Og(e,t=t.map(e=>kg(e,!1)),l));return new ib(e,t,o,h)}}function sb(){return"undefined"!=typeof window&&void 0!==window.document&&Element.prototype.animate||{}}let ob=(()=>{class e extends Lm{constructor(e,t){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(t.body,{id:"0",encapsulation:lt.None,styles:[],data:{animation:[]}})}build(e){const t=this._nextAnimationId.toString();this._nextAnimationId++;const a=Array.isArray(e)?Wm(e):e;return hb(this._renderer,null,t,"register",[a]),new lb(t,this._renderer)}}return e.\u0275fac=function(t){return new(t||e)(Ye(Hs),Ye(Bl))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();class lb extends class{}{constructor(e,t){super(),this._id=e,this._renderer=t}create(e,t){return new cb(this._id,e,t||{},this._renderer)}}class cb{constructor(e,t,a,n){this.id=e,this.element=t,this._renderer=n,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",a)}_listen(e,t){return this._renderer.listen(this.element,`@@${this.id}:${e}`,t)}_command(e,...t){return hb(this._renderer,this.element,this.id,e,t)}onDone(e){this._listen("done",e)}onStart(e){this._listen("start",e)}onDestroy(e){this._listen("destroy",e)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset")}setPosition(e){this._command("setPosition",e)}getPosition(){return 0}}function hb(e,t,a,n,i){return e.setProperty(t,`@@${a}:${n}`,i)}const db="@",ub="@.disabled";let pb=(()=>{class e{constructor(e,t,a){this.delegate=e,this.engine=t,this._zone=a,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),t.onRemovalComplete=(e,t)=>{t&&t.parentNode(e)&&t.removeChild(e.parentNode,e)}}createRenderer(e,t){const a=this.delegate.createRenderer(e,t);if(!(e&&t&&t.data&&t.data.animation)){let e=this._rendererCache.get(a);return e||(e=new mb("",a,this.engine),this._rendererCache.set(a,e)),e}const n=t.id,i=t.id+"-"+this._currentId;this._currentId++,this.engine.register(i,e);const r=t=>{Array.isArray(t)?t.forEach(r):this.engine.registerTrigger(n,i,e,t.name,t)};return t.data.animation.forEach(r),new gb(this,i,a,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,t,a){e>=0&&e<this._microtaskId?this._zone.run(()=>t(a)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(e=>{const[t,a]=e;t(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([t,a]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return e.\u0275fac=function(t){return new(t||e)(Ye(Hs),Ye(Gf),Ye(cl))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();class mb{constructor(e,t,a){this.namespaceId=e,this.delegate=t,this.engine=a,this.destroyNode=this.delegate.destroyNode?e=>t.destroyNode(e):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(e,t){return this.delegate.createElement(e,t)}createComment(e){return this.delegate.createComment(e)}createText(e){return this.delegate.createText(e)}appendChild(e,t){this.delegate.appendChild(e,t),this.engine.onInsert(this.namespaceId,t,e,!1)}insertBefore(e,t,a,n=!0){this.delegate.insertBefore(e,t,a),this.engine.onInsert(this.namespaceId,t,e,n)}removeChild(e,t,a){this.engine.onRemove(this.namespaceId,t,this.delegate,a)}selectRootElement(e,t){return this.delegate.selectRootElement(e,t)}parentNode(e){return this.delegate.parentNode(e)}nextSibling(e){return this.delegate.nextSibling(e)}setAttribute(e,t,a,n){this.delegate.setAttribute(e,t,a,n)}removeAttribute(e,t,a){this.delegate.removeAttribute(e,t,a)}addClass(e,t){this.delegate.addClass(e,t)}removeClass(e,t){this.delegate.removeClass(e,t)}setStyle(e,t,a,n){this.delegate.setStyle(e,t,a,n)}removeStyle(e,t,a){this.delegate.removeStyle(e,t,a)}setProperty(e,t,a){t.charAt(0)==db&&t==ub?this.disableAnimations(e,!!a):this.delegate.setProperty(e,t,a)}setValue(e,t){this.delegate.setValue(e,t)}listen(e,t,a){return this.delegate.listen(e,t,a)}disableAnimations(e,t){this.engine.disableAnimations(e,t)}}class gb extends mb{constructor(e,t,a,n){super(t,a,n),this.factory=e,this.namespaceId=t}setProperty(e,t,a){t.charAt(0)==db?"."==t.charAt(1)&&t==ub?this.disableAnimations(e,a=void 0===a||!!a):this.engine.process(this.namespaceId,e,t.substr(1),a):this.delegate.setProperty(e,t,a)}listen(e,t,a){if(t.charAt(0)==db){const n=function(e){switch(e){case"body":return document.body;case"document":return document;case"window":return window;default:return e}}(e);let i=t.substr(1),r="";return i.charAt(0)!=db&&([i,r]=function(e){const t=e.indexOf(".");return[e.substring(0,t),e.substr(t+1)]}(i)),this.engine.listen(this.namespaceId,n,i,r,e=>{this.factory.scheduleListenerCallback(e._data||-1,a,e)})}return this.delegate.listen(e,t,a)}}let fb=(()=>{class e extends Gf{constructor(e,t,a){super(e.body,t,a)}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl),Ye(ug),Ye(cf))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const bb=new Ne("AnimationModuleType"),yb=[{provide:ug,useFactory:function(){return"function"==typeof sb()?new rb:new nb}},{provide:bb,useValue:"BrowserAnimations"},{provide:Lm,useClass:ob},{provide:cf,useFactory:function(){return new hf}},{provide:Gf,useClass:fb},{provide:Hs,useFactory:function(e,t,a){return new pb(e,t,a)},deps:[Wc,Gf,cl]}];let wb=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},providers:yb,imports:[Xc]}),e})();const vb=new Us("10.2.7"),_b=new Ne("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let xb,kb=(()=>{class e{constructor(e,t,a){this._hasDoneGlobalChecks=!1,this._document=a,e._applyBodyHighContrastModeCssClasses(),this._sanityChecks=t,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getDocument(){const e=this._document||document;return"object"==typeof e&&e?e:null}_getWindow(){const e=this._getDocument(),t=(null==e?void 0:e.defaultView)||window;return"object"==typeof t&&t?t:null}_checksAreEnabled(){return _n()&&!this._isTestEnv()}_isTestEnv(){const e=this._getWindow();return e&&(e.__karma__||e.jasmine)}_checkDoctypeIsDefined(){const e=this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype),t=this._getDocument();e&&t&&!t.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){const e=!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme,t=this._getDocument();if(e||!t||!t.body||"function"!=typeof getComputedStyle)return;const a=t.createElement("div");a.classList.add("mat-theme-loaded-marker"),t.body.appendChild(a);const n=getComputedStyle(a);n&&"none"!==n.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),t.body.removeChild(a)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&vb.full!==Dm.full&&console.warn("The Angular Material version ("+vb.full+") does not match the Angular CDK version ("+Dm.full+").\nPlease ensure the versions of these two packages exactly match.")}}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)(Ye(Am),Ye(_b,8),Ye(Bl,8))},imports:[[Pm],Pm]}),e})();function Sb(e){return class extends e{constructor(...e){super(...e),this._disabled=!1}get disabled(){return this._disabled}set disabled(e){this._disabled=om(e)}}}function Tb(e,t){return class extends e{constructor(...e){super(...e),this.defaultColor=t,this.color=t}get color(){return this._color}set color(e){const t=e||this.defaultColor;t!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove("mat-"+this._color),t&&this._elementRef.nativeElement.classList.add("mat-"+t),this._color=t)}}}function Cb(e){return class extends e{constructor(...e){super(...e),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(e){this._disableRipple=om(e)}}}try{xb="undefined"!=typeof Intl}catch(jw){xb=!1}class Eb{constructor(e,t,a){this._renderer=e,this.element=t,this.config=a,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const Ab={enterDuration:450,exitDuration:400},Ib=Zp({passive:!0}),Rb=["mousedown","touchstart"],Mb=["mouseup","mouseleave","touchend","touchcancel"];class Pb{constructor(e,t,a,n){this._target=e,this._ngZone=t,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,n.isBrowser&&(this._containerElement=hm(a))}fadeInRipple(e,t,a={}){const n=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i=Object.assign(Object.assign({},Ab),a.animation);a.centered&&(e=n.left+n.width/2,t=n.top+n.height/2);const r=a.radius||function(e,t,a){const n=Math.max(Math.abs(e-a.left),Math.abs(e-a.right)),i=Math.max(Math.abs(t-a.top),Math.abs(t-a.bottom));return Math.sqrt(n*n+i*i)}(e,t,n),s=e-n.left,o=t-n.top,l=i.enterDuration,c=document.createElement("div");c.classList.add("mat-ripple-element"),c.style.left=s-r+"px",c.style.top=o-r+"px",c.style.height=2*r+"px",c.style.width=2*r+"px",null!=a.color&&(c.style.backgroundColor=a.color),c.style.transitionDuration=l+"ms",this._containerElement.appendChild(c),window.getComputedStyle(c).getPropertyValue("opacity"),c.style.transform="scale(1)";const h=new Eb(this,c,a);return h.state=0,this._activeRipples.add(h),a.persistent||(this._mostRecentTransientRipple=h),this._runTimeoutOutsideZone(()=>{const e=h===this._mostRecentTransientRipple;h.state=1,a.persistent||e&&this._isPointerDown||h.fadeOut()},l),h}fadeOutRipple(e){const t=this._activeRipples.delete(e);if(e===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!t)return;const a=e.element,n=Object.assign(Object.assign({},Ab),e.config.animation);a.style.transitionDuration=n.exitDuration+"ms",a.style.opacity="0",e.state=2,this._runTimeoutOutsideZone(()=>{e.state=3,a.parentNode.removeChild(a)},n.exitDuration)}fadeOutAll(){this._activeRipples.forEach(e=>e.fadeOut())}setupTriggerEvents(e){const t=hm(e);t&&t!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=t,this._registerEvents(Rb))}handleEvent(e){"mousedown"===e.type?this._onMousedown(e):"touchstart"===e.type?this._onTouchStart(e):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(Mb),this._pointerUpEventsRegistered=!0)}_onMousedown(e){const t=vm(e),a=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||t||a||(this._isPointerDown=!0,this.fadeInRipple(e.clientX,e.clientY,this._target.rippleConfig))}_onTouchStart(e){if(!this._target.rippleDisabled){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const t=e.changedTouches;for(let e=0;e<t.length;e++)this.fadeInRipple(t[e].clientX,t[e].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(e=>{!e.config.persistent&&(1===e.state||e.config.terminateOnPointerUp&&0===e.state)&&e.fadeOut()}))}_runTimeoutOutsideZone(e,t=0){this._ngZone.runOutsideAngular(()=>setTimeout(e,t))}_registerEvents(e){this._ngZone.runOutsideAngular(()=>{e.forEach(e=>{this._triggerElement.addEventListener(e,this,Ib)})})}_removeTriggerEvents(){this._triggerElement&&(Rb.forEach(e=>{this._triggerElement.removeEventListener(e,this,Ib)}),this._pointerUpEventsRegistered&&Mb.forEach(e=>{this._triggerElement.removeEventListener(e,this,Ib)}))}}const Db=new Ne("mat-ripple-global-options");let Lb=(()=>{class e{constructor(e,t,a,n,i){this._elementRef=e,this._animationMode=i,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=n||{},this._rippleRenderer=new Pb(this,t,e,a)}get disabled(){return this._disabled}set disabled(e){this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,t=0,a){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,t,Object.assign(Object.assign({},this.rippleConfig),a)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),e))}}return e.\u0275fac=function(t){return new(t||e)(Xr(Bs),Xr(cl),Xr(Xp),Xr(Db,8),Xr(bb,8))},e.\u0275dir=yt({type:e,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,t){2&e&&ys("mat-ripple-unbounded",t.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),e})(),Nb=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},imports:[[kb,Jp],kb]}),e})();const Ob=["mat-button",""],jb=["*"],Wb=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class zb{constructor(e){this._elementRef=e}}const Bb=Tb(Sb(Cb(zb)));let Gb=(()=>{class e extends Bb{constructor(e,t,a){super(e),this._focusMonitor=t,this._animationMode=a,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const n of Wb)this._hasHostAttributes(n)&&this._getHostElement().classList.add(n);e.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e="program",t){this._focusMonitor.focusVia(this._getHostElement(),e,t)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...e){return e.some(e=>this._getHostElement().hasAttribute(e))}}return e.\u0275fac=function(t){return new(t||e)(Xr(Bs),Xr(km),Xr(bb,8))},e.\u0275cmp=ut({type:e,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(e,t){if(1&e&&(a=Lb,n=!0,function(e,t,a,n,i,r){e.firstCreatePass&&Bo(e,new Ro(a,n,!1,i),-1),zo(e,t)}(la(),oa(),a,n,i)),2&e){let e;jo(e=Wo())&&(t.ripple=e.first)}var a,n,i},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(e,t){2&e&&(Vr("disabled",t.disabled||null),ys("_mat-animation-noopable","NoopAnimations"===t._animationMode)("mat-button-disabled",t.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[jr],attrs:Ob,ngContentSelectors:jb,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(e,t){1&e&&(us(),es(0,"span",0),ps(1),ts(),as(2,"span",1),as(3,"span",2)),2&e&&(ui(2),ys("mat-button-ripple-round",t.isRoundButton||t.isIconButton),Zr("matRippleDisabled",t._isRippleDisabled())("matRippleCentered",t.isIconButton)("matRippleTrigger",t._getHostElement()))},directives:[Lb],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"],encapsulation:2,changeDetection:0}),e})(),Hb=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},imports:[[Nb,kb],kb]}),e})();function Fb(e,t,a,i){return n(a)&&(i=a,a=void 0),i?Fb(e,t,a).pipe(C(e=>l(e)?i(...e):i(e))):new y(n=>{qb(e,t,function(e){n.next(arguments.length>1?Array.prototype.slice.call(arguments):e)},n,a)})}function qb(e,t,a,n,i){let r;if(function(e){return e&&"function"==typeof e.addEventListener&&"function"==typeof e.removeEventListener}(e)){const n=e;e.addEventListener(t,a,i),r=()=>n.removeEventListener(t,a,i)}else if(function(e){return e&&"function"==typeof e.on&&"function"==typeof e.off}(e)){const n=e;e.on(t,a),r=()=>n.off(t,a)}else if(function(e){return e&&"function"==typeof e.addListener&&"function"==typeof e.removeListener}(e)){const n=e;e.addListener(t,a),r=()=>n.removeListener(t,a)}else{if(!e||!e.length)throw new TypeError("Invalid event target");for(let r=0,s=e.length;r<s;r++)qb(e[r],t,a,n,i)}n.add(r)}class Qb{constructor(e){this.durationSelector=e}call(e,t){return t.subscribe(new Yb(e,this.durationSelector))}}class Yb extends W{constructor(e,t){super(e),this.durationSelector=t,this.hasValue=!1}_next(e){if(this.value=e,this.hasValue=!0,!this.throttled){let a;try{const{durationSelector:t}=this;a=t(e)}catch(t){return this.destination.error(t)}const n=z(a,new j(this));!n||n.closed?this.clearThrottle():this.add(this.throttled=n)}}clearThrottle(){const{value:e,hasValue:t,throttled:a}=this;a&&(this.remove(a),this.throttled=void 0,a.unsubscribe()),t&&(this.value=void 0,this.hasValue=!1,this.destination.next(e))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function Ub(e){return!l(e)&&e-parseFloat(e)+1>=0}function Vb(e){const{index:t,period:a,subscriber:n}=e;if(n.next(t),!n.closed){if(-1===a)return n.complete();e.index=t+1,this.schedule(e,a)}}function Kb(e,t=nm){return a=()=>function(e=0,t,a){let n=-1;return Ub(t)?n=Number(t)<1?1:Number(t):T(t)&&(a=t),T(a)||(a=nm),new y(t=>{const i=Ub(e)?e:+e-a.now();return a.schedule(Vb,i,{index:0,period:n,subscriber:t})})}(e,t),function(e){return e.lift(new Qb(a))};var a}function Xb(e){return t=>t.lift(new Jb(e))}class Jb{constructor(e){this.notifier=e}call(e,t){const a=new Zb(e),n=z(this.notifier,new j(a));return n&&!a.seenValue?(a.add(n),t.subscribe(a)):a}}class Zb extends W{constructor(e){super(e),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}let $b=(()=>{class e{constructor(e,t,a){this._ngZone=e,this._platform=t,this._scrolled=new k,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=a}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const t=this.scrollContainers.get(e);t&&(t.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new y(t=>{this._globalSubscription||this._addGlobalListener();const a=e>0?this._scrolled.pipe(Kb(e)).subscribe(t):this._scrolled.subscribe(t);return this._scrolledCount++,()=>{a.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Jc()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,t)=>this.deregister(t)),this._scrolled.complete()}ancestorScrolled(e,t){const a=this.getAncestorScrollContainers(e);return this.scrolled(t).pipe(dh(e=>!e||a.indexOf(e)>-1))}getAncestorScrollContainers(e){const t=[];return this.scrollContainers.forEach((a,n)=>{this._scrollableContainsElement(n,e)&&t.push(n)}),t}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_scrollableContainsElement(e,t){let a=t.nativeElement,n=e.getElementRef().nativeElement;do{if(a==n)return!0}while(a=a.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>Fb(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return e.\u0275fac=function(t){return new(t||e)(Ye(cl),Ye(Xp),Ye(Bl,8))},e.\u0275prov=ce({factory:function(){return new e(Ye(cl),Ye(Xp),Ye(Bl,8))},token:e,providedIn:"root"}),e})(),ey=(()=>{class e{constructor(e,t,a){this._platform=e,this._change=new k,this._changeListener=e=>{this._change.next(e)},this._document=a,t.runOutsideAngular(()=>{if(e.isBrowser){const e=this._getWindow();e.addEventListener("resize",this._changeListener),e.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:t,height:a}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+a,right:e.left+t,height:a,width:t}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._getDocument(),t=this._getWindow(),a=e.documentElement,n=a.getBoundingClientRect();return{top:-n.top||e.body.scrollTop||t.scrollY||a.scrollTop||0,left:-n.left||e.body.scrollLeft||t.scrollX||a.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(Kb(e)):this._change}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return e.\u0275fac=function(t){return new(t||e)(Ye(Xp),Ye(cl),Ye(Bl,8))},e.\u0275prov=ce({factory:function(){return new e(Ye(Xp),Ye(cl),Ye(Bl,8))},token:e,providedIn:"root"}),e})(),ty=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)}}),e})(),ay=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},imports:[[Pm,Jp,ty],Pm,ty]}),e})();class ny{attach(e){return this._attachedHost=e,e.attach(this)}detach(){let e=this._attachedHost;null!=e&&(this._attachedHost=null,e.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(e){this._attachedHost=e}}class iy extends ny{constructor(e,t,a,n){super(),this.component=e,this.viewContainerRef=t,this.injector=a,this.componentFactoryResolver=n}}class ry extends ny{constructor(e,t,a){super(),this.templateRef=e,this.viewContainerRef=t,this.context=a}get origin(){return this.templateRef.elementRef}attach(e,t=this.context){return this.context=t,super.attach(e)}detach(){return this.context=void 0,super.detach()}}class sy extends ny{constructor(e){super(),this.element=e instanceof Bs?e.nativeElement:e}}class oy extends class{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(e){return e instanceof iy?(this._attachedPortal=e,this.attachComponentPortal(e)):e instanceof ry?(this._attachedPortal=e,this.attachTemplatePortal(e)):this.attachDomPortal&&e instanceof sy?(this._attachedPortal=e,this.attachDomPortal(e)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(e){this._disposeFn=e}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}{constructor(e,t,a,n,i){super(),this.outletElement=e,this._componentFactoryResolver=t,this._appRef=a,this._defaultInjector=n,this.attachDomPortal=e=>{const t=e.element,a=this._document.createComment("dom-portal");t.parentNode.insertBefore(a,t),this.outletElement.appendChild(t),super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(t,a)})},this._document=i}attachComponentPortal(e){const t=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component);let a;return e.viewContainerRef?(a=e.viewContainerRef.createComponent(t,e.viewContainerRef.length,e.injector||e.viewContainerRef.injector),this.setDisposeFn(()=>a.destroy())):(a=t.create(e.injector||this._defaultInjector),this._appRef.attachView(a.hostView),this.setDisposeFn(()=>{this._appRef.detachView(a.hostView),a.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(a)),a}attachTemplatePortal(e){let t=e.viewContainerRef,a=t.createEmbeddedView(e.templateRef,e.context);return a.rootNodes.forEach(e=>this.outletElement.appendChild(e)),a.detectChanges(),this.setDisposeFn(()=>{let e=t.indexOf(a);-1!==e&&t.remove(e)}),a}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(e){return e.hostView.rootNodes[0]}}let ly=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)}}),e})();class cy{constructor(e,t){this._viewportRuler=e,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=t}attach(){}enable(){if(this._canBeEnabled()){const e=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=e.style.left||"",this._previousHTMLStyles.top=e.style.top||"",e.style.left=cm(-this._previousScrollPosition.left),e.style.top=cm(-this._previousScrollPosition.top),e.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const e=this._document.documentElement,t=e.style,a=this._document.body.style,n=t.scrollBehavior||"",i=a.scrollBehavior||"";this._isEnabled=!1,t.left=this._previousHTMLStyles.left,t.top=this._previousHTMLStyles.top,e.classList.remove("cdk-global-scrollblock"),t.scrollBehavior=a.scrollBehavior="auto",window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),t.scrollBehavior=n,a.scrollBehavior=i}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,t=this._viewportRuler.getViewportSize();return e.scrollHeight>t.height||e.scrollWidth>t.width}}class hy{constructor(e,t,a,n){this._scrollDispatcher=e,this._ngZone=t,this._viewportRuler=a,this._config=n,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(e){this._overlayRef=e}enable(){if(this._scrollSubscription)return;const e=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=e.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=e.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class dy{enable(){}disable(){}attach(){}}function uy(e,t){return t.some(t=>e.bottom<t.top||e.top>t.bottom||e.right<t.left||e.left>t.right)}function py(e,t){return t.some(t=>e.top<t.top||e.bottom>t.bottom||e.left<t.left||e.right>t.right)}class my{constructor(e,t,a,n){this._scrollDispatcher=e,this._viewportRuler=t,this._ngZone=a,this._config=n,this._scrollSubscription=null}attach(e){this._overlayRef=e}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:t,height:a}=this._viewportRuler.getViewportSize();uy(e,[{width:t,height:a,bottom:a,right:t,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let gy=(()=>{class e{constructor(e,t,a,n){this._scrollDispatcher=e,this._viewportRuler=t,this._ngZone=a,this.noop=()=>new dy,this.close=e=>new hy(this._scrollDispatcher,this._ngZone,this._viewportRuler,e),this.block=()=>new cy(this._viewportRuler,this._document),this.reposition=e=>new my(this._scrollDispatcher,this._viewportRuler,this._ngZone,e),this._document=n}}return e.\u0275fac=function(t){return new(t||e)(Ye($b),Ye(ey),Ye(cl),Ye(Bl))},e.\u0275prov=ce({factory:function(){return new e(Ye($b),Ye(ey),Ye(cl),Ye(Bl))},token:e,providedIn:"root"}),e})();class fy{constructor(e){if(this.scrollStrategy=new dy,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,e){const t=Object.keys(e);for(const a of t)void 0!==e[a]&&(this[a]=e[a])}}}class by{constructor(e,t,a,n,i){this.offsetX=a,this.offsetY=n,this.panelClass=i,this.originX=e.originX,this.originY=e.originY,this.overlayX=t.overlayX,this.overlayY=t.overlayY}}class yy{constructor(e,t){this.connectionPair=e,this.scrollableViewProperties=t}}let wy=(()=>{class e{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const t=this._attachedOverlays.indexOf(e);t>-1&&this._attachedOverlays.splice(t,1),0===this._attachedOverlays.length&&this.detach()}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl))},e.\u0275prov=ce({factory:function(){return new e(Ye(Bl))},token:e,providedIn:"root"}),e})(),vy=(()=>{class e extends wy{constructor(e){super(e),this._keydownListener=e=>{const t=this._attachedOverlays;for(let a=t.length-1;a>-1;a--)if(t[a]._keydownEvents.observers.length>0){t[a]._keydownEvents.next(e);break}}}add(e){super.add(e),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl))},e.\u0275prov=ce({factory:function(){return new e(Ye(Bl))},token:e,providedIn:"root"}),e})(),_y=(()=>{class e extends wy{constructor(e,t){super(e),this._platform=t,this._cursorStyleIsSet=!1,this._clickListener=e=>{const t=e.composedPath?e.composedPath()[0]:e.target,a=this._attachedOverlays.slice();for(let n=a.length-1;n>-1;n--){const i=a[n];if(!(i._outsidePointerEvents.observers.length<1)&&i.hasAttached()){if(i.overlayElement.contains(t))break;i._outsidePointerEvents.next(e)}}}}add(e){super.add(e),this._isAttached||(this._document.body.addEventListener("click",this._clickListener,!0),this._document.body.addEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=this._document.body.style.cursor,this._document.body.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("click",this._clickListener,!0),this._document.body.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(this._document.body.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1)}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl),Ye(Xp))},e.\u0275prov=ce({factory:function(){return new e(Ye(Bl),Ye(Xp))},token:e,providedIn:"root"}),e})();const xy=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let ky=(()=>{class e{constructor(e,t){this._platform=t,this._document=e}ngOnDestroy(){const e=this._containerElement;e&&e.parentNode&&e.parentNode.removeChild(e)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e=this._platform?this._platform.isBrowser:"undefined"!=typeof window,t="cdk-overlay-container";if(e||xy){const e=this._document.querySelectorAll(`.${t}[platform="server"], .${t}[platform="test"]`);for(let t=0;t<e.length;t++)e[t].parentNode.removeChild(e[t])}const a=this._document.createElement("div");a.classList.add(t),xy?a.setAttribute("platform","test"):e||a.setAttribute("platform","server"),this._document.body.appendChild(a),this._containerElement=a}}return e.\u0275fac=function(t){return new(t||e)(Ye(Bl),Ye(Xp))},e.\u0275prov=ce({factory:function(){return new e(Ye(Bl),Ye(Xp))},token:e,providedIn:"root"}),e})();class Sy{constructor(e,t,a,n,i,r,s,o,l){this._portalOutlet=e,this._host=t,this._pane=a,this._config=n,this._ngZone=i,this._keyboardDispatcher=r,this._document=s,this._location=o,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new k,this._attachments=new k,this._detachments=new k,this._locationChanges=d.EMPTY,this._backdropClickHandler=e=>this._backdropClick.next(e),this._keydownEvents=new k,this._outsidePointerEvents=new k,n.scrollStrategy&&(this._scrollStrategy=n.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=n.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(e){let t=this._portalOutlet.attach(e);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Ah(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&this._location&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher&&this._outsideClickDispatcher.add(this),t}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const e=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher&&this._outsideClickDispatcher.remove(this),e}dispose(){const e=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher&&this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,e&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(e){e!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=e,this.hasAttached()&&(e.attach(this),this.updatePosition()))}updateSize(e){this._config=Object.assign(Object.assign({},this._config),e),this._updateElementSize()}setDirection(e){this._config=Object.assign(Object.assign({},this._config),{direction:e}),this._updateElementDirection()}addPanelClass(e){this._pane&&this._toggleClasses(this._pane,e,!0)}removePanelClass(e){this._pane&&this._toggleClasses(this._pane,e,!1)}getDirection(){const e=this._config.direction;return e?"string"==typeof e?e:e.value:"ltr"}updateScrollStrategy(e){e!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=e,this.hasAttached()&&(e.attach(this),e.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const e=this._pane.style;e.width=cm(this._config.width),e.height=cm(this._config.height),e.minWidth=cm(this._config.minWidth),e.minHeight=cm(this._config.minHeight),e.maxWidth=cm(this._config.maxWidth),e.maxHeight=cm(this._config.maxHeight)}_togglePointerEvents(e){this._pane.style.pointerEvents=e?"auto":"none"}_attachBackdrop(){const e="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(e)})}):this._backdropElement.classList.add(e)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let e,t=this._backdropElement;if(!t)return;let a=()=>{t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",a),t.parentNode&&t.parentNode.removeChild(t)),this._backdropElement==t&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(t,this._config.backdropClass,!1),clearTimeout(e)};t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",a)}),t.style.pointerEvents="none",e=this._ngZone.runOutsideAngular(()=>setTimeout(a,500))}_toggleClasses(e,t,a){const n=e.classList;lm(t).forEach(e=>{e&&(a?n.add(e):n.remove(e))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const e=this._ngZone.onStable.pipe(Xb(Q(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),e.unsubscribe())})})}_disposeScrollStrategy(){const e=this._scrollStrategy;e&&(e.disable(),e.detach&&e.detach())}}const Ty="cdk-overlay-connected-position-bounding-box",Cy=/([A-Za-z%]+)$/;class Ey{constructor(e,t,a,n,i){this._viewportRuler=t,this._document=a,this._platform=n,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new k,this._resizeSubscription=d.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(e)}get positions(){return this._preferredPositions}attach(e){this._validatePositions(),e.hostElement.classList.add(Ty),this._overlayRef=e,this._boundingBox=e.hostElement,this._pane=e.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const e=this._originRect,t=this._overlayRect,a=this._viewportRect,n=[];let i;for(let r of this._preferredPositions){let s=this._getOriginPoint(e,r),o=this._getOverlayPoint(s,t,r),l=this._getOverlayFit(o,t,a,r);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(r,s);this._canFitWithFlexibleDimensions(l,o,a)?n.push({position:r,origin:s,overlayRect:t,boundingBoxRect:this._calculateBoundingBoxRect(s,r)}):(!i||i.overlayFit.visibleArea<l.visibleArea)&&(i={overlayFit:l,overlayPoint:o,originPoint:s,position:r,overlayRect:t})}if(n.length){let e=null,t=-1;for(const a of n){const n=a.boundingBoxRect.width*a.boundingBoxRect.height*(a.position.weight||1);n>t&&(t=n,e=a)}return this._isPushed=!1,void this._applyPosition(e.position,e.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(i.position,i.originPoint);this._applyPosition(i.position,i.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&Ay(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(Ty),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const e=this._lastPosition||this._preferredPositions[0],t=this._getOriginPoint(this._originRect,e);this._applyPosition(e,t)}}withScrollableContainers(e){return this._scrollables=e,this}withPositions(e){return this._preferredPositions=e,-1===e.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(e){return this._viewportMargin=e,this}withFlexibleDimensions(e=!0){return this._hasFlexibleDimensions=e,this}withGrowAfterOpen(e=!0){return this._growAfterOpen=e,this}withPush(e=!0){return this._canPush=e,this}withLockedPosition(e=!0){return this._positionLocked=e,this}setOrigin(e){return this._origin=e,this}withDefaultOffsetX(e){return this._offsetX=e,this}withDefaultOffsetY(e){return this._offsetY=e,this}withTransformOriginOn(e){return this._transformOriginSelector=e,this}_getOriginPoint(e,t){let a,n;if("center"==t.originX)a=e.left+e.width/2;else{const n=this._isRtl()?e.right:e.left,i=this._isRtl()?e.left:e.right;a="start"==t.originX?n:i}return n="center"==t.originY?e.top+e.height/2:"top"==t.originY?e.top:e.bottom,{x:a,y:n}}_getOverlayPoint(e,t,a){let n,i;return n="center"==a.overlayX?-t.width/2:"start"===a.overlayX?this._isRtl()?-t.width:0:this._isRtl()?0:-t.width,i="center"==a.overlayY?-t.height/2:"top"==a.overlayY?0:-t.height,{x:e.x+n,y:e.y+i}}_getOverlayFit(e,t,a,n){let{x:i,y:r}=e,s=this._getOffset(n,"x"),o=this._getOffset(n,"y");s&&(i+=s),o&&(r+=o);let l=0-r,c=r+t.height-a.height,h=this._subtractOverflows(t.width,0-i,i+t.width-a.width),d=this._subtractOverflows(t.height,l,c),u=h*d;return{visibleArea:u,isCompletelyWithinViewport:t.width*t.height===u,fitsInViewportVertically:d===t.height,fitsInViewportHorizontally:h==t.width}}_canFitWithFlexibleDimensions(e,t,a){if(this._hasFlexibleDimensions){const n=a.bottom-t.y,i=a.right-t.x,r=Iy(this._overlayRef.getConfig().minHeight),s=Iy(this._overlayRef.getConfig().minWidth),o=e.fitsInViewportHorizontally||null!=s&&s<=i;return(e.fitsInViewportVertically||null!=r&&r<=n)&&o}return!1}_pushOverlayOnScreen(e,t,a){if(this._previousPushAmount&&this._positionLocked)return{x:e.x+this._previousPushAmount.x,y:e.y+this._previousPushAmount.y};const n=this._viewportRect,i=Math.max(e.x+t.width-n.width,0),r=Math.max(e.y+t.height-n.height,0),s=Math.max(n.top-a.top-e.y,0),o=Math.max(n.left-a.left-e.x,0);let l=0,c=0;return l=t.width<=n.width?o||-i:e.x<this._viewportMargin?n.left-a.left-e.x:0,c=t.height<=n.height?s||-r:e.y<this._viewportMargin?n.top-a.top-e.y:0,this._previousPushAmount={x:l,y:c},{x:e.x+l,y:e.y+c}}_applyPosition(e,t){if(this._setTransformOrigin(e),this._setOverlayElementStyles(t,e),this._setBoundingBoxStyles(t,e),e.panelClass&&this._addPanelClasses(e.panelClass),this._lastPosition=e,this._positionChanges.observers.length){const t=this._getScrollVisibility(),a=new yy(e,t);this._positionChanges.next(a)}this._isInitialRender=!1}_setTransformOrigin(e){if(!this._transformOriginSelector)return;const t=this._boundingBox.querySelectorAll(this._transformOriginSelector);let a,n=e.overlayY;a="center"===e.overlayX?"center":this._isRtl()?"start"===e.overlayX?"right":"left":"start"===e.overlayX?"left":"right";for(let i=0;i<t.length;i++)t[i].style.transformOrigin=`${a} ${n}`}_calculateBoundingBoxRect(e,t){const a=this._viewportRect,n=this._isRtl();let i,r,s,o,l,c;if("top"===t.overlayY)r=e.y,i=a.height-r+this._viewportMargin;else if("bottom"===t.overlayY)s=a.height-e.y+2*this._viewportMargin,i=a.height-s+this._viewportMargin;else{const t=Math.min(a.bottom-e.y+a.top,e.y),n=this._lastBoundingBoxSize.height;i=2*t,r=e.y-t,i>n&&!this._isInitialRender&&!this._growAfterOpen&&(r=e.y-n/2)}if("end"===t.overlayX&&!n||"start"===t.overlayX&&n)c=a.width-e.x+this._viewportMargin,o=e.x-this._viewportMargin;else if("start"===t.overlayX&&!n||"end"===t.overlayX&&n)l=e.x,o=a.right-e.x;else{const t=Math.min(a.right-e.x+a.left,e.x),n=this._lastBoundingBoxSize.width;o=2*t,l=e.x-t,o>n&&!this._isInitialRender&&!this._growAfterOpen&&(l=e.x-n/2)}return{top:r,left:l,bottom:s,right:c,width:o,height:i}}_setBoundingBoxStyles(e,t){const a=this._calculateBoundingBoxRect(e,t);this._isInitialRender||this._growAfterOpen||(a.height=Math.min(a.height,this._lastBoundingBoxSize.height),a.width=Math.min(a.width,this._lastBoundingBoxSize.width));const n={};if(this._hasExactPosition())n.top=n.left="0",n.bottom=n.right=n.maxHeight=n.maxWidth="",n.width=n.height="100%";else{const e=this._overlayRef.getConfig().maxHeight,i=this._overlayRef.getConfig().maxWidth;n.height=cm(a.height),n.top=cm(a.top),n.bottom=cm(a.bottom),n.width=cm(a.width),n.left=cm(a.left),n.right=cm(a.right),n.alignItems="center"===t.overlayX?"center":"end"===t.overlayX?"flex-end":"flex-start",n.justifyContent="center"===t.overlayY?"center":"bottom"===t.overlayY?"flex-end":"flex-start",e&&(n.maxHeight=cm(e)),i&&(n.maxWidth=cm(i))}this._lastBoundingBoxSize=a,Ay(this._boundingBox.style,n)}_resetBoundingBoxStyles(){Ay(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){Ay(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(e,t){const a={},n=this._hasExactPosition(),i=this._hasFlexibleDimensions,r=this._overlayRef.getConfig();if(n){const n=this._viewportRuler.getViewportScrollPosition();Ay(a,this._getExactOverlayY(t,e,n)),Ay(a,this._getExactOverlayX(t,e,n))}else a.position="static";let s="",o=this._getOffset(t,"x"),l=this._getOffset(t,"y");o&&(s+=`translateX(${o}px) `),l&&(s+=`translateY(${l}px)`),a.transform=s.trim(),r.maxHeight&&(n?a.maxHeight=cm(r.maxHeight):i&&(a.maxHeight="")),r.maxWidth&&(n?a.maxWidth=cm(r.maxWidth):i&&(a.maxWidth="")),Ay(this._pane.style,a)}_getExactOverlayY(e,t,a){let n={top:"",bottom:""},i=this._getOverlayPoint(t,this._overlayRect,e);this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,a));let r=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return i.y-=r,"bottom"===e.overlayY?n.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":n.top=cm(i.y),n}_getExactOverlayX(e,t,a){let n,i={left:"",right:""},r=this._getOverlayPoint(t,this._overlayRect,e);return this._isPushed&&(r=this._pushOverlayOnScreen(r,this._overlayRect,a)),n=this._isRtl()?"end"===e.overlayX?"left":"right":"end"===e.overlayX?"right":"left","right"===n?i.right=this._document.documentElement.clientWidth-(r.x+this._overlayRect.width)+"px":i.left=cm(r.x),i}_getScrollVisibility(){const e=this._getOriginRect(),t=this._pane.getBoundingClientRect(),a=this._scrollables.map(e=>e.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:py(e,a),isOriginOutsideView:uy(e,a),isOverlayClipped:py(t,a),isOverlayOutsideView:uy(t,a)}}_subtractOverflows(e,...t){return t.reduce((e,t)=>e-Math.max(t,0),e)}_getNarrowedViewportRect(){const e=this._document.documentElement.clientWidth,t=this._document.documentElement.clientHeight,a=this._viewportRuler.getViewportScrollPosition();return{top:a.top+this._viewportMargin,left:a.left+this._viewportMargin,right:a.left+e-this._viewportMargin,bottom:a.top+t-this._viewportMargin,width:e-2*this._viewportMargin,height:t-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(e,t){return"x"===t?null==e.offsetX?this._offsetX:e.offsetX:null==e.offsetY?this._offsetY:e.offsetY}_validatePositions(){}_addPanelClasses(e){this._pane&&lm(e).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(e=>{this._pane.classList.remove(e)}),this._appliedPanelClasses=[])}_getOriginRect(){const e=this._origin;if(e instanceof Bs)return e.nativeElement.getBoundingClientRect();if(e instanceof Element)return e.getBoundingClientRect();const t=e.width||0,a=e.height||0;return{top:e.y,bottom:e.y+a,left:e.x,right:e.x+t,height:a,width:t}}}function Ay(e,t){for(let a in t)t.hasOwnProperty(a)&&(e[a]=t[a]);return e}function Iy(e){if("number"!=typeof e&&null!=e){const[t,a]=e.split(Cy);return a&&"px"!==a?null:parseFloat(t)}return e||null}class Ry{constructor(e,t,a,n,i,r,s){this._preferredPositions=[],this._positionStrategy=new Ey(a,n,i,r,s).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(e,t),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(e){this._overlayRef=e,this._positionStrategy.attach(e),this._direction&&(e.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(e){this._positionStrategy.withScrollableContainers(e)}withFallbackPosition(e,t,a,n){const i=new by(e,t,a,n);return this._preferredPositions.push(i),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(e){return this._overlayRef?this._overlayRef.setDirection(e):this._direction=e,this}withOffsetX(e){return this._positionStrategy.withDefaultOffsetX(e),this}withOffsetY(e){return this._positionStrategy.withDefaultOffsetY(e),this}withLockedPosition(e){return this._positionStrategy.withLockedPosition(e),this}withPositions(e){return this._preferredPositions=e.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(e){return this._positionStrategy.setOrigin(e),this}}const My="cdk-global-overlay-wrapper";class Py{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(e){const t=e.getConfig();this._overlayRef=e,this._width&&!t.width&&e.updateSize({width:this._width}),this._height&&!t.height&&e.updateSize({height:this._height}),e.hostElement.classList.add(My),this._isDisposed=!1}top(e=""){return this._bottomOffset="",this._topOffset=e,this._alignItems="flex-start",this}left(e=""){return this._rightOffset="",this._leftOffset=e,this._justifyContent="flex-start",this}bottom(e=""){return this._topOffset="",this._bottomOffset=e,this._alignItems="flex-end",this}right(e=""){return this._leftOffset="",this._rightOffset=e,this._justifyContent="flex-end",this}width(e=""){return this._overlayRef?this._overlayRef.updateSize({width:e}):this._width=e,this}height(e=""){return this._overlayRef?this._overlayRef.updateSize({height:e}):this._height=e,this}centerHorizontally(e=""){return this.left(e),this._justifyContent="center",this}centerVertically(e=""){return this.top(e),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const e=this._overlayRef.overlayElement.style,t=this._overlayRef.hostElement.style,a=this._overlayRef.getConfig(),{width:n,height:i,maxWidth:r,maxHeight:s}=a,o=!("100%"!==n&&"100vw"!==n||r&&"100%"!==r&&"100vw"!==r),l=!("100%"!==i&&"100vh"!==i||s&&"100%"!==s&&"100vh"!==s);e.position=this._cssPosition,e.marginLeft=o?"0":this._leftOffset,e.marginTop=l?"0":this._topOffset,e.marginBottom=this._bottomOffset,e.marginRight=this._rightOffset,o?t.justifyContent="flex-start":"center"===this._justifyContent?t.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?t.justifyContent="flex-end":"flex-end"===this._justifyContent&&(t.justifyContent="flex-start"):t.justifyContent=this._justifyContent,t.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const e=this._overlayRef.overlayElement.style,t=this._overlayRef.hostElement,a=t.style;t.classList.remove(My),a.justifyContent=a.alignItems=e.marginTop=e.marginBottom=e.marginLeft=e.marginRight=e.position="",this._overlayRef=null,this._isDisposed=!0}}let Dy=(()=>{class e{constructor(e,t,a,n){this._viewportRuler=e,this._document=t,this._platform=a,this._overlayContainer=n}global(){return new Py}connectedTo(e,t,a){return new Ry(t,a,e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(e){return new Ey(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return e.\u0275fac=function(t){return new(t||e)(Ye(ey),Ye(Bl),Ye(Xp),Ye(ky))},e.\u0275prov=ce({factory:function(){return new e(Ye(ey),Ye(Bl),Ye(Xp),Ye(ky))},token:e,providedIn:"root"}),e})(),Ly=0,Ny=(()=>{class e{constructor(e,t,a,n,i,r,s,o,l,c,h){this.scrollStrategies=e,this._overlayContainer=t,this._componentFactoryResolver=a,this._positionBuilder=n,this._keyboardDispatcher=i,this._injector=r,this._ngZone=s,this._document=o,this._directionality=l,this._location=c,this._outsideClickDispatcher=h}create(e){const t=this._createHostElement(),a=this._createPaneElement(t),n=this._createPortalOutlet(a),i=new fy(e);return i.direction=i.direction||this._directionality.value,new Sy(n,t,a,i,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(e){const t=this._document.createElement("div");return t.id="cdk-overlay-"+Ly++,t.classList.add("cdk-overlay-pane"),e.appendChild(t),t}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(Al)),new oy(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return e.\u0275fac=function(t){return new(t||e)(Ye(gy),Ye(ky),Ye(zs),Ye(Dy),Ye(vy),Ye(Dr),Ye(cl),Ye(Bl),Ye(Mm),Ye(tc),Ye(_y))},e.\u0275prov=ce({token:e,factory:e.\u0275fac}),e})();const Oy={provide:new Ne("cdk-connected-overlay-scroll-strategy"),deps:[Ny],useFactory:function(e){return()=>e.scrollStrategies.reposition()}};let jy=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},providers:[Ny,Oy],imports:[[Pm,ly,ay],ay]}),e})();class Wy{constructor(e){this.total=e}call(e,t){return t.subscribe(new zy(e,this.total))}}class zy extends m{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){++this.count>this.total&&this.destination.next(e)}}const By=new Set;let Gy,Hy=(()=>{class e{constructor(e){this._platform=e,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):Fy}matchMedia(e){return this._platform.WEBKIT&&function(e){if(!By.has(e))try{Gy||(Gy=document.createElement("style"),Gy.setAttribute("type","text/css"),document.head.appendChild(Gy)),Gy.sheet&&(Gy.sheet.insertRule(`@media ${e} {.fx-query-test{ }}`,0),By.add(e))}catch(t){console.error(t)}}(e),this._matchMedia(e)}}return e.\u0275fac=function(t){return new(t||e)(Ye(Xp))},e.\u0275prov=ce({factory:function(){return new e(Ye(Xp))},token:e,providedIn:"root"}),e})();function Fy(e){return{matches:"all"===e||""===e,media:e,addListener:()=>{},removeListener:()=>{}}}let qy=(()=>{class e{constructor(e,t){this._mediaMatcher=e,this._zone=t,this._queries=new Map,this._destroySubject=new k}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return Qy(lm(e)).some(e=>this._registerQuery(e).mql.matches)}observe(e){let t=nh(Qy(lm(e)).map(e=>this._registerQuery(e).observable));return t=Mh(t.pipe(Ah(1)),t.pipe(e=>e.lift(new Wy(1)),function(e,t=nm){return a=>a.lift(new im(e,t))}(0))),t.pipe(C(e=>{const t={matches:!1,breakpoints:{}};return e.forEach(({matches:e,query:a})=>{t.matches=t.matches||e,t.breakpoints[a]=e}),t}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const t=this._mediaMatcher.matchMedia(e),a={observable:new y(e=>{const a=t=>this._zone.run(()=>e.next(t));return t.addListener(a),()=>{t.removeListener(a)}}).pipe(Ph(t),C(({matches:t})=>({query:e,matches:t})),Xb(this._destroySubject)),mql:t};return this._queries.set(e,a),a}}return e.\u0275fac=function(t){return new(t||e)(Ye(Hy),Ye(cl))},e.\u0275prov=ce({factory:function(){return new e(Ye(Hy),Ye(cl))},token:e,providedIn:"root"}),e})();function Qy(e){return e.map(e=>e.split(",")).reduce((e,t)=>e.concat(t)).map(e=>e.trim())}const Yy={tooltipState:Om("state",[Bm("initial, void, hidden",zm({opacity:0,transform:"scale(0)"})),Bm("visible",zm({transform:"scale(1)"})),Hm("* => visible",jm("200ms cubic-bezier(0, 0, 0.2, 1)",Gm([zm({opacity:0,transform:"scale(0)",offset:0}),zm({opacity:.5,transform:"scale(0.99)",offset:.5}),zm({opacity:1,transform:"scale(1)",offset:1})]))),Hm("* => hidden",jm("100ms cubic-bezier(0, 0, 0.2, 1)",zm({opacity:0})))])},Uy=Zp({passive:!0}),Vy=new Ne("mat-tooltip-scroll-strategy"),Ky={provide:Vy,deps:[Ny],useFactory:function(e){return()=>e.scrollStrategies.reposition({scrollThrottle:20})}},Xy=new Ne("mat-tooltip-default-options",{providedIn:"root",factory:function(){return{showDelay:0,hideDelay:0,touchendHideDelay:1500}}});let Jy=(()=>{class e{constructor(e,t,a,n,i,r,s,o,l,c,h){this._overlay=e,this._elementRef=t,this._scrollDispatcher=a,this._viewContainerRef=n,this._ngZone=i,this._platform=r,this._ariaDescriber=s,this._focusMonitor=o,this._dir=c,this._defaultOptions=h,this._position="below",this._disabled=!1,this._viewInitialized=!1,this._pointerExitEventsInitialized=!1,this.showDelay=this._defaultOptions.showDelay,this.hideDelay=this._defaultOptions.hideDelay,this.touchGestures="auto",this._message="",this._passiveListeners=[],this._destroyed=new k,this._handleKeydown=e=>{this._isTooltipVisible()&&27===e.keyCode&&!function(e,...t){return t.length?t.some(t=>e[t]):e.altKey||e.shiftKey||e.ctrlKey||e.metaKey}(e)&&(e.preventDefault(),e.stopPropagation(),this._ngZone.run(()=>this.hide(0)))},this._scrollStrategy=l,h&&(h.position&&(this.position=h.position),h.touchGestures&&(this.touchGestures=h.touchGestures)),i.runOutsideAngular(()=>{t.nativeElement.addEventListener("keydown",this._handleKeydown)})}get position(){return this._position}set position(e){e!==this._position&&(this._position=e,this._overlayRef&&(this._updatePosition(),this._tooltipInstance&&this._tooltipInstance.show(0),this._overlayRef.updatePosition()))}get disabled(){return this._disabled}set disabled(e){this._disabled=om(e),this._disabled?this.hide(0):this._setupPointerEnterEventsIfNeeded()}get message(){return this._message}set message(e){this._ariaDescriber.removeDescription(this._elementRef.nativeElement,this._message),this._message=null!=e?String(e).trim():"",!this._message&&this._isTooltipVisible()?this.hide(0):(this._setupPointerEnterEventsIfNeeded(),this._updateTooltipMessage(),this._ngZone.runOutsideAngular(()=>{Promise.resolve().then(()=>{this._ariaDescriber.describe(this._elementRef.nativeElement,this.message)})}))}get tooltipClass(){return this._tooltipClass}set tooltipClass(e){this._tooltipClass=e,this._tooltipInstance&&this._setTooltipClass(this._tooltipClass)}ngAfterViewInit(){this._viewInitialized=!0,this._setupPointerEnterEventsIfNeeded(),this._focusMonitor.monitor(this._elementRef).pipe(Xb(this._destroyed)).subscribe(e=>{e?"keyboard"===e&&this._ngZone.run(()=>this.show()):this._ngZone.run(()=>this.hide(0))})}ngOnDestroy(){const e=this._elementRef.nativeElement;clearTimeout(this._touchstartTimeout),this._overlayRef&&(this._overlayRef.dispose(),this._tooltipInstance=null),e.removeEventListener("keydown",this._handleKeydown),this._passiveListeners.forEach(([t,a])=>{e.removeEventListener(t,a,Uy)}),this._passiveListeners.length=0,this._destroyed.next(),this._destroyed.complete(),this._ariaDescriber.removeDescription(e,this.message),this._focusMonitor.stopMonitoring(e)}show(e=this.showDelay){if(this.disabled||!this.message||this._isTooltipVisible()&&!this._tooltipInstance._showTimeoutId&&!this._tooltipInstance._hideTimeoutId)return;const t=this._createOverlay();this._detach(),this._portal=this._portal||new iy(Zy,this._viewContainerRef),this._tooltipInstance=t.attach(this._portal).instance,this._tooltipInstance.afterHidden().pipe(Xb(this._destroyed)).subscribe(()=>this._detach()),this._setTooltipClass(this._tooltipClass),this._updateTooltipMessage(),this._tooltipInstance.show(e)}hide(e=this.hideDelay){this._tooltipInstance&&this._tooltipInstance.hide(e)}toggle(){this._isTooltipVisible()?this.hide():this.show()}_isTooltipVisible(){return!!this._tooltipInstance&&this._tooltipInstance.isVisible()}_createOverlay(){if(this._overlayRef)return this._overlayRef;const e=this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),t=this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(".mat-tooltip").withFlexibleDimensions(!1).withViewportMargin(8).withScrollableContainers(e);return t.positionChanges.pipe(Xb(this._destroyed)).subscribe(e=>{this._tooltipInstance&&e.scrollableViewProperties.isOverlayClipped&&this._tooltipInstance.isVisible()&&this._ngZone.run(()=>this.hide(0))}),this._overlayRef=this._overlay.create({direction:this._dir,positionStrategy:t,panelClass:"mat-tooltip-panel",scrollStrategy:this._scrollStrategy()}),this._updatePosition(),this._overlayRef.detachments().pipe(Xb(this._destroyed)).subscribe(()=>this._detach()),this._overlayRef}_detach(){this._overlayRef&&this._overlayRef.hasAttached()&&this._overlayRef.detach(),this._tooltipInstance=null}_updatePosition(){const e=this._overlayRef.getConfig().positionStrategy,t=this._getOrigin(),a=this._getOverlayPosition();e.withPositions([Object.assign(Object.assign({},t.main),a.main),Object.assign(Object.assign({},t.fallback),a.fallback)])}_getOrigin(){const e=!this._dir||"ltr"==this._dir.value,t=this.position;let a;"above"==t||"below"==t?a={originX:"center",originY:"above"==t?"top":"bottom"}:"before"==t||"left"==t&&e||"right"==t&&!e?a={originX:"start",originY:"center"}:("after"==t||"right"==t&&e||"left"==t&&!e)&&(a={originX:"end",originY:"center"});const{x:n,y:i}=this._invertPosition(a.originX,a.originY);return{main:a,fallback:{originX:n,originY:i}}}_getOverlayPosition(){const e=!this._dir||"ltr"==this._dir.value,t=this.position;let a;"above"==t?a={overlayX:"center",overlayY:"bottom"}:"below"==t?a={overlayX:"center",overlayY:"top"}:"before"==t||"left"==t&&e||"right"==t&&!e?a={overlayX:"end",overlayY:"center"}:("after"==t||"right"==t&&e||"left"==t&&!e)&&(a={overlayX:"start",overlayY:"center"});const{x:n,y:i}=this._invertPosition(a.overlayX,a.overlayY);return{main:a,fallback:{overlayX:n,overlayY:i}}}_updateTooltipMessage(){this._tooltipInstance&&(this._tooltipInstance.message=this.message,this._tooltipInstance._markForCheck(),this._ngZone.onMicrotaskEmpty.pipe(Ah(1),Xb(this._destroyed)).subscribe(()=>{this._tooltipInstance&&this._overlayRef.updatePosition()}))}_setTooltipClass(e){this._tooltipInstance&&(this._tooltipInstance.tooltipClass=e,this._tooltipInstance._markForCheck())}_invertPosition(e,t){return"above"===this.position||"below"===this.position?"top"===t?t="bottom":"bottom"===t&&(t="top"):"end"===e?e="start":"start"===e&&(e="end"),{x:e,y:t}}_setupPointerEnterEventsIfNeeded(){!this._disabled&&this.message&&this._viewInitialized&&!this._passiveListeners.length&&(this._platformSupportsMouseEvents()?this._passiveListeners.push(["mouseenter",()=>{this._setupPointerExitEventsIfNeeded(),this.show()}]):"off"!==this.touchGestures&&(this._disableNativeGesturesIfNecessary(),this._passiveListeners.push(["touchstart",()=>{this._setupPointerExitEventsIfNeeded(),clearTimeout(this._touchstartTimeout),this._touchstartTimeout=setTimeout(()=>this.show(),500)}])),this._addListeners(this._passiveListeners))}_setupPointerExitEventsIfNeeded(){if(this._pointerExitEventsInitialized)return;this._pointerExitEventsInitialized=!0;const e=[];if(this._platformSupportsMouseEvents())e.push(["mouseleave",()=>this.hide()]);else if("off"!==this.touchGestures){this._disableNativeGesturesIfNecessary();const t=()=>{clearTimeout(this._touchstartTimeout),this.hide(this._defaultOptions.touchendHideDelay)};e.push(["touchend",t],["touchcancel",t])}this._addListeners(e),this._passiveListeners.push(...e)}_addListeners(e){e.forEach(([e,t])=>{this._elementRef.nativeElement.addEventListener(e,t,Uy)})}_platformSupportsMouseEvents(){return!this._platform.IOS&&!this._platform.ANDROID}_disableNativeGesturesIfNecessary(){const e=this.touchGestures;if("off"!==e){const t=this._elementRef.nativeElement,a=t.style;("on"===e||"INPUT"!==t.nodeName&&"TEXTAREA"!==t.nodeName)&&(a.userSelect=a.msUserSelect=a.webkitUserSelect=a.MozUserSelect="none"),"on"!==e&&t.draggable||(a.webkitUserDrag="none"),a.touchAction="none",a.webkitTapHighlightColor="transparent"}}}return e.\u0275fac=function(t){return new(t||e)(Xr(Ny),Xr(Bs),Xr($b),Xr(po),Xr(cl),Xr(Xp),Xr(wm),Xr(km),Xr(Vy),Xr(Mm,8),Xr(Xy,8))},e.\u0275dir=yt({type:e,selectors:[["","matTooltip",""]],hostAttrs:[1,"mat-tooltip-trigger"],inputs:{showDelay:["matTooltipShowDelay","showDelay"],hideDelay:["matTooltipHideDelay","hideDelay"],touchGestures:["matTooltipTouchGestures","touchGestures"],position:["matTooltipPosition","position"],disabled:["matTooltipDisabled","disabled"],message:["matTooltip","message"],tooltipClass:["matTooltipClass","tooltipClass"]},exportAs:["matTooltip"]}),e})(),Zy=(()=>{class e{constructor(e,t){this._changeDetectorRef=e,this._breakpointObserver=t,this._visibility="initial",this._closeOnInteraction=!1,this._onHide=new k,this._isHandset=this._breakpointObserver.observe("(max-width: 599.99px) and (orientation: portrait), (max-width: 959.99px) and (orientation: landscape)")}show(e){this._hideTimeoutId&&(clearTimeout(this._hideTimeoutId),this._hideTimeoutId=null),this._closeOnInteraction=!0,this._showTimeoutId=setTimeout(()=>{this._visibility="visible",this._showTimeoutId=null,this._markForCheck()},e)}hide(e){this._showTimeoutId&&(clearTimeout(this._showTimeoutId),this._showTimeoutId=null),this._hideTimeoutId=setTimeout(()=>{this._visibility="hidden",this._hideTimeoutId=null,this._markForCheck()},e)}afterHidden(){return this._onHide}isVisible(){return"visible"===this._visibility}ngOnDestroy(){this._onHide.complete()}_animationStart(){this._closeOnInteraction=!1}_animationDone(e){const t=e.toState;"hidden"!==t||this.isVisible()||this._onHide.next(),"visible"!==t&&"hidden"!==t||(this._closeOnInteraction=!0)}_handleBodyInteraction(){this._closeOnInteraction&&this.hide(0)}_markForCheck(){this._changeDetectorRef.markForCheck()}}return e.\u0275fac=function(t){return new(t||e)(Xr(br),Xr(qy))},e.\u0275cmp=ut({type:e,selectors:[["mat-tooltip-component"]],hostAttrs:["aria-hidden","true"],hostVars:2,hostBindings:function(e,t){1&e&&os("click",function(){return t._handleBodyInteraction()},!1,Ot),2&e&&bs("zoom","visible"===t._visibility?1:null)},decls:3,vars:7,consts:[[1,"mat-tooltip",3,"ngClass"]],template:function(e,t){if(1&e&&(es(0,"div",0),os("@state.start",function(){return t._animationStart()})("@state.done",function(e){return t._animationDone(e)}),function(e,t){const a=la();let n;a.firstCreatePass?(n=function(e,t){if(t)for(let a=t.length-1;a>=0;a--){const n=t[a];if(e===n.name)return n}throw new Pt("302","The pipe 'async' could not be found!")}("async",a.pipeRegistry),a.data[21]=n,n.onDestroy&&(a.destroyHooks||(a.destroyHooks=[])).push(21,n.onDestroy)):n=a.data[21];const i=n.factory||(n.factory=_t(n.type)),r=qe(Xr);try{const e=Ja(!1),t=i();Ja(e),function(e,t,a,n){21>=e.data.length&&(e.data[21]=null,e.blueprint[21]=null),t[21]=n}(a,oa(),0,t)}finally{qe(r)}}(),Ss(2),ts()),2&e){let e=null;ys("mat-tooltip-handset",null==(e=function(e,t,a){const n=e+kt,i=oa(),r=function(e,t){return e[t]}(i,n);return function(e,t){return qr.isWrapped(t)&&(t=qr.unwrap(t),e[ba()]=di),t}(i,function(e,t){return e[1].data[t].pure}(i,n)?So(i,fa(),t,r.transform,a,r):r.transform(a))}(1,5,t._isHandset))?null:e.matches),Zr("ngClass",t.tooltipClass)("@state",t._visibility),ui(2),Ts(t.message)}},directives:[oc],pipes:[yc],styles:[".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"],encapsulation:2,data:{animation:[Yy.tooltipState]},changeDetection:0}),e})(),$y=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},providers:[Ky],imports:[[Im,wc,jy,kb],kb,ty]}),e})();function ew(e,t){if(1&e&&(es(0,"a",4),Ss(1),ts()),2&e){const e=hs().$implicit;Zr("href",e.url,Tn),ui(1),Ts(e.title)}}function tw(e,t){if(1&e&&(ns(0),Ss(1),is()),2&e){const e=hs().$implicit;ui(1),Ts(e.title)}}function aw(e,t){1&e&&(es(0,"button",5),Ss(1,"Abstract"),ts()),2&e&&Zr("matTooltip",hs().$implicit.abstract)}const nw=function(e){return["/","people",e]};function iw(e,t){if(1&e&&(es(0,"a",7),Ss(1),ts()),2&e){const e=hs().$implicit,t=hs(2);Zr("routerLink",(2,a=nw,n=t.peopleMap[e].id,So(oa(),fa(),2,a,n,undefined))),ui(1),Ts(e)}var a,n}function rw(e,t){if(1&e&&(ns(0),Ss(1),is()),2&e){const e=hs().$implicit;ui(1),Ts(e)}}function sw(e,t){if(1&e&&(es(0,"span"),Kr(1,iw,2,4,"a",6),Kr(2,rw,2,1,"ng-container",2),ts()),2&e){const e=t.$implicit,a=hs(2);ui(1),Zr("ngIf",a.peopleMap[e]),ui(1),Zr("ngIf",!a.peopleMap[e])}}function ow(e,t){if(1&e&&(es(0,"div"),es(1,"h3"),Kr(2,ew,2,2,"a",1),Kr(3,tw,2,1,"ng-container",2),Kr(4,aw,2,1,"button",3),ts(),Kr(5,sw,3,2,"span",0),ts()),2&e){const e=t.$implicit;ui(2),Zr("ngIf",e.url),ui(1),Zr("ngIf",!e.url),ui(1),Zr("ngIf",e.abstract),ui(1),Zr("ngForOf",e.authors)}}let lw=(()=>{class e{constructor(){this.publications=[],this.peopleMap=Qp}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-publications-list"]],inputs:{publications:"publications"},decls:1,vars:1,consts:[[4,"ngFor","ngForOf"],["target","_blank",3,"href",4,"ngIf"],[4,"ngIf"],["mat-button","","color","accent","aria-label","Show publication abstract",3,"matTooltip",4,"ngIf"],["target","_blank",3,"href"],["mat-button","","color","accent","aria-label","Show publication abstract",3,"matTooltip"],[3,"routerLink",4,"ngIf"],[3,"routerLink"]],template:function(e,t){1&e&&Kr(0,ow,6,4,"div",0),2&e&&Zr("ngForOf",t.publications)},directives:[cc,dc,Gb,Jy,wp],styles:['div[_ngcontent-%COMP%]:not(:last-child){padding-bottom:8px;border-bottom:1px solid rgba(0,0,0,.10196078431372549)}span[_ngcontent-%COMP%]{font-style:italic;padding:0 2px}span[_ngcontent-%COMP%]:not(:last-child):after{content:","}h3[_ngcontent-%COMP%]{margin:0}']}),e})();function cw(e,t){if(1&e&&(es(0,"div"),es(1,"h2"),Ss(2),ts(),as(3,"app-publications-list",1),ts()),2&e){const e=t.$implicit,a=hs();ui(2),Ts(e),ui(1),Zr("publications",a.publicationsMap[e])}}let hw=(()=>{class e{constructor(){this.publicationsMap=Hp,this.years=Object.keys(this.publicationsMap).sort().reverse()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-publications"]],decls:1,vars:1,consts:[[4,"ngFor","ngForOf"],[3,"publications"]],template:function(e,t){1&e&&Kr(0,cw,4,2,"div",0),2&e&&Zr("ngForOf",t.years)},directives:[cc,lw],styles:["h2[_ngcontent-%COMP%]{margin:16px 0}"]}),e})();function dw(e,t){if(1&e&&(es(0,"h6",6),Ss(1),ts()),2&e){const e=hs(2);ui(1),Ts(e.person.advisors.join("\n"))}}function uw(e,t){if(1&e&&(es(0,"div",1),as(1,"img",2),es(2,"div",3),es(3,"h5",4),Ss(4),ts(),Kr(5,dw,2,1,"h6",5),ts(),ts()),2&e){const e=hs();ui(1),Zr("src","assets/people/"+e.person.imagePath+".jpg",Tn)("alt","Photo of a "+e.person.name),ui(3),Ts(e.person.name),ui(1),Zr("ngIf",e.person.advisors)}}let pw=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-person-card"]],inputs:{person:"person"},decls:1,vars:1,consts:[["class","person-card",4,"ngIf"],[1,"person-card"],[1,"card-image",3,"src","alt"],[1,"container"],[1,"title"],["class","subtitle",4,"ngIf"],[1,"subtitle"]],template:function(e,t){1&e&&Kr(0,uw,6,4,"div",0),2&e&&Zr("ngIf",t.person)},directives:[dc],styles:[".with-hover[_nghost-%COMP%]:hover   .card-image[_ngcontent-%COMP%]{transform:scale(.95);filter:brightness(1.15)}.with-hover[_nghost-%COMP%]:hover   .container[_ngcontent-%COMP%]{transform:translateY(-8px)}.card-image[_ngcontent-%COMP%]{width:100%;background:none no-repeat 50%/cover;border-radius:32px}.card-image[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]{transition:all .25s ease}.container[_ngcontent-%COMP%]{padding:16px;display:flex;flex-direction:column;gap:4px;box-sizing:border-box}.title[_ngcontent-%COMP%]{font-size:24px;font-weight:500;margin:0;line-height:125%}.subtitle[_ngcontent-%COMP%]{font-size:16px;margin:0;opacity:.5;white-space:pre}"]}),e})();function mw(e,t){if(1&e&&as(0,"app-person-card",5),2&e){const e=t.$implicit;Zr("person",e)("routerLink",e.id)}}function gw(e,t){if(1&e&&(es(0,"div",3),Kr(1,mw,1,2,"app-person-card",4),ts()),2&e){const e=t.ngIf;ui(1),Zr("ngForOf",e)}}function fw(e,t){if(1&e&&(es(0,"section",1),es(1,"h2"),Ss(2),ts(),Kr(3,gw,2,1,"div",2),ts()),2&e){const e=t.$implicit,a=hs();Vr("data-group",e),ui(2),Ts(a.groupName(e)),ui(1),Zr("ngIf",a.groups[e])}}let bw=(()=>{class e{constructor(){this.groupsOrder=["Faculty","PhD Student","MSc Student","Alumni","Employee"],this.groups=qp,this.groupsOrder.forEach(e=>{this.groups[e]=this.groups[e].sort("Alumni"===e?(e,t)=>(e.endYear||0)<(t.endYear||0)?1:-1:(e,t)=>e.name>t.name?1:-1)})}groupName(e){return"Faculty"!==e&&"Alumni"!==e?e+"s":e}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-people"]],decls:1,vars:1,consts:[["class","people-section",4,"ngFor","ngForOf"],[1,"people-section"],["class","peoples-grid",4,"ngIf"],[1,"peoples-grid"],["class","with-hover",3,"person","routerLink",4,"ngFor","ngForOf"],[1,"with-hover",3,"person","routerLink"]],template:function(e,t){1&e&&Kr(0,fw,4,3,"section",0),2&e&&Zr("ngForOf",t.groupsOrder)},directives:[cc,dc,pw,yp],styles:[".people-section[_ngcontent-%COMP%]{margin:48px 16px 0}@media (min-width:768px){.people-section[data-group=Faculty][_ngcontent-%COMP%]   app-person-card[_ngcontent-%COMP%]{width:calc(100% / 3)}}.peoples-grid[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;align-items:stretch;justify-content:stretch}h2[_ngcontent-%COMP%]{font-size:32px;font-weight:300}app-person-card[_ngcontent-%COMP%]{width:100%;padding:12px;box-sizing:border-box;cursor:pointer}@media (min-width:768px){app-person-card[_ngcontent-%COMP%]{width:25%}}@media (min-width:1024px){app-person-card[_ngcontent-%COMP%]{width:20%}}[_nghost-%COMP%]   div[_ngcontent-%COMP%]{margin-top:24px}"]}),e})(),yw=(()=>{class e{constructor(){}ngOnInit(){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-resources"]],decls:2,vars:0,template:function(e,t){1&e&&(es(0,"p"),Ss(1,"resources works!"),ts())},styles:[""]}),e})();function ww(e,t){if(1&e&&(es(0,"div"),Ss(1),ts()),2&e){const e=hs(2);ui(1),Es("",e.person.current.position," @ ",e.person.current.employer,"")}}function vw(e,t){if(1&e&&(es(0,"div"),Ss(1),ts()),2&e){const e=hs(2);ui(1),Ts(e.person.interests)}}function _w(e,t){if(1&e&&(es(0,"a",8),Ss(1),ts()),2&e){const e=hs(2);Zr("href",e.person.homepage,Tn),ui(1),Ts(e.person.homepage)}}function xw(e,t){if(1&e&&(es(0,"div",6),Kr(1,ww,2,2,"div",4),Kr(2,vw,2,1,"div",4),Kr(3,_w,2,2,"a",7),ts()),2&e){const e=hs();ui(1),Zr("ngIf",e.person.current),ui(1),Zr("ngIf",e.person.interests),ui(1),Zr("ngIf",e.person.homepage)}}function kw(e,t){1&e&&(es(0,"div"),Ss(1,"No Publications"),ts())}function Sw(e,t){1&e&&as(0,"app-publications-list",9),2&e&&Zr("publications",hs().publications)}const Tw=[{path:"",component:Bp},{path:"people",component:bw},{path:"people/:id",component:(()=>{class e{constructor(e,t){this.route=e,this.router=t,this.publications=[]}ngOnInit(){this.route.params.subscribe(e=>{const t=e.id,a=Yp.find(e=>e.id===t);if(a){this.person=a;const e=[this.person.name].concat(this.person.aliases||[]);this.publications=Gp.filter(t=>e.some(e=>t.authors.indexOf(e)>-1))}else this.router.navigate(["/people"])})}}return e.\u0275fac=function(t){return new(t||e)(Xr(Zd),Xr(bp))},e.\u0275cmp=ut({type:e,selectors:[["app-person"]],decls:8,vars:4,consts:[["id","info"],[3,"person"],["id","other-info",4,"ngIf"],[1,"publications"],[4,"ngIf"],[3,"publications",4,"ngIf"],["id","other-info"],["target","_blank",3,"href",4,"ngIf"],["target","_blank",3,"href"],[3,"publications"]],template:function(e,t){1&e&&(es(0,"div",0),as(1,"app-person-card",1),Kr(2,xw,4,3,"div",2),ts(),es(3,"div",3),es(4,"h3"),Ss(5,"Publications"),ts(),Kr(6,kw,2,0,"div",4),Kr(7,Sw,1,1,"app-publications-list",5),ts()),2&e&&(ui(1),Zr("person",t.person),ui(1),Zr("ngIf",t.person),ui(4),Zr("ngIf",0==t.publications.length),ui(1),Zr("ngIf",t.publications.length>0))},directives:[pw,dc,lw],styles:["[_nghost-%COMP%]{display:flex;width:100%;margin:40px 8px}[_nghost-%COMP%] > *[_ngcontent-%COMP%]{padding:8px}@media (max-width:768px){[_nghost-%COMP%]{display:block}}.publications[_ngcontent-%COMP%]{flex-grow:1}#info[_ngcontent-%COMP%]{width:256px;min-width:256px;margin:0 auto;display:block}#info[_ngcontent-%COMP%]   #other-info[_ngcontent-%COMP%]{padding:0 16px}"]}),e})()},{path:"publications",component:hw},{path:"resources",component:yw}];let Cw=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},imports:[[Mp.forRoot(Tw)],Mp]}),e})();const Ew=["*",[["mat-toolbar-row"]]],Aw=["*","mat-toolbar-row"];class Iw{constructor(e){this._elementRef=e}}const Rw=Tb(Iw);let Mw=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275dir=yt({type:e,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),e})(),Pw=(()=>{class e extends Rw{constructor(e,t,a){super(e),this._platform=t,this._document=a}ngAfterViewInit(){this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){}}return e.\u0275fac=function(t){return new(t||e)(Xr(Bs),Xr(Xp),Xr(Bl))},e.\u0275cmp=ut({type:e,selectors:[["mat-toolbar"]],contentQueries:function(e,t,a){if(1&e&&(n=a,i=Mw,r=!0,function(e,t,a,n,i,r,s,o){e.firstCreatePass&&(Bo(e,new Ro(a,n,!1,i),s.index),function(e,t){const a=e.contentQueries||(e.contentQueries=[]);t!==(a.length?a[a.length-1]:-1)&&a.push(e.queries.length-1,t)}(e,o)),zo(e,t)}(la(),oa(),i,r,s,0,ca(),n)),2&e){let e;jo(e=Wo())&&(t._toolbarRows=e)}var n,i,r,s},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(e,t){2&e&&ys("mat-toolbar-multiple-rows",t._toolbarRows.length>0)("mat-toolbar-single-row",0===t._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[jr],ngContentSelectors:Aw,decls:2,vars:0,template:function(e,t){1&e&&(us(Ew),ps(0),ps(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),e})(),Dw=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},imports:[[kb],kb]}),e})(),Lw=(()=>{class e{constructor(){this.title="lab-website"}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-root"]],decls:13,vars:0,consts:[["color","primary"],[1,"container"],["routerLink","/","id","nav-main"],[1,"nav-spacer"],["mat-button","","aria-label","Navigate to 'people' page","routerLink","/people"],["mat-button","","aria-label","Navigate to 'publications' page","routerLink","/publications"]],template:function(e,t){1&e&&(es(0,"mat-toolbar",0),es(1,"div",1),es(2,"span",2),Ss(3,"BIU NLP Lab"),ts(),as(4,"span",3),es(5,"button",4),es(6,"span"),Ss(7,"People"),ts(),ts(),es(8,"button",5),es(9,"span"),Ss(10,"Publications"),ts(),ts(),ts(),ts(),es(11,"div",1),as(12,"router-outlet"),ts())},directives:[Pw,yp,Gb,_p],styles:[".nav-spacer[_ngcontent-%COMP%]{flex:1 1 auto}#nav-main[_ngcontent-%COMP%]{cursor:pointer}"]}),e})(),Nw=(()=>{class e{}return e.\u0275mod=ft({type:e}),e.\u0275inj=he({factory:function(t){return new(t||e)},imports:[[kb],kb]}),e})(),Ow=(()=>{class e{}return e.\u0275mod=ft({type:e,bootstrap:[Lw]}),e.\u0275inj=he({factory:function(t){return new(t||e)},providers:[],imports:[[Xc,wb,Cw,Dw,Hb,Nw,$y]]}),e})();(function(){if(vn)throw new Error("Cannot enable prod mode after platform setup.");wn=!1})(),Vc().bootstrapModule(Ow).catch(e=>console.error(e))},zn8P:function(e,t){function a(e){return Promise.resolve().then(function(){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}a.keys=function(){return[]},a.resolve=a,e.exports=a,a.id="zn8P"}},[[0,0]]]);